<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">Foreword</a></li><li class="affix"><a href="ch00-00-introduction.html">Introduction</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Referring to Names in Different Modules</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning our Single Threaded Server into a Multithreaded Server</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Translations</a></li><li><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Newest Features</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#foreword" id="foreword"><h1>Foreword</h1></a>
<p>It wasn’t always so clear, but the Rust programming language is fundamentally
about <em>empowerment</em>: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.</p>
<p>Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.</p>
<p>Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.</p>
<p>Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or exploits.</p>
<p>But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.</p>
<p>This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!</p>
<p>— Nicholas Matsakis and Aaron Turon</p>
<a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<a class="header" href="print.html#Встановлення" id="Встановлення"><h2>Встановлення</h2></a>
<p>Перше, що треба зробити, щоб почати використовувати Rust - це встановити її. Щоб
запускати команди з цього розділу, вам знадобиться з'єднання з Інтернетом, бо
ми завантажимо Rust з Інтернету.</p>
<p>Ми напишемо ряд команд за допомогою терміналу; ці стрічки будуть починатися з
символа <code>$</code>. Вам не треба набирати символ <code>$</code>; він просто позначає початок
кожної команди. Ви можете побачити багато інструкцій та прикладів в мережі, що
дотримуються цієї умовності: <code>$</code> позначає команди, які виконує звичайний
користувач, та <code>#</code> - команди, які треба запускати від адміністратора. Стрічки,
що не починаються з <code>$</code> зазвичай відображають вивід попередньої команди.</p>
<a class="header" href="print.html#Встановлення-на-linux-або-mac" id="Встановлення-на-linux-або-mac"><h3>Встановлення на Linux або Mac</h3></a>
<p>Якщо ви користувач Linux або Mac, все, що вам потрібно - запустити термінал і
набрати це:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Це завантажить сценарій і почне встановлення. Можливо, у вас запитають ваш
пароль. Якщо все буде гараз, ви побачите повідомлення:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Звісно, якщо ви не схвалюєте використання шаблону <code>curl | sh</code>, ви можете
завантажити, дослідити і запустити сценарій у зручний для вас спосіб.</p>
<a class="header" href="print.html#Встановлення-на-windows" id="Встановлення-на-windows"><h3>Встановлення на Windows</h3></a>
<p>На Windows перйдіть на <a href="https://rustup.rs/">https://rustup.rs</a><!-- ignore -->
і дотримуйтесь інструкцій, щоб завантажити rustup-init.exe. Запустіть його і
виконайте подальші інструкції, які він надасть вам.</p>
<p>Для решти специфічних для Windows команд у цій книзі ми будемо вважати, що ви
використовуєте командний рядок <code>cmd</code>. Якщо ви користуєтеся іншою оболонкою,
можливо, ви можете скористатися тими ж командами, що й користувачі Linux та Mac.
Якщо жоден із цих варіантів не спрацює, зверністься до документації оболонки,
яку ви використовуєте.</p>
<a class="header" href="print.html#Настроюване-користувачем-встановлення" id="Настроюване-користувачем-встановлення"><h3>Настроюване користувачем встановлення</h3></a>
<p>Якщо ви маєте підстави для невикористання rustup.rs, будь ласка, перегляньте
<a href="https://www.rust-lang.org/install.html">сторінку встановлення Rust</a>, щоб
дізнатися про інші варіанти.</p>
<a class="header" href="print.html#Видалення" id="Видалення"><h3>Видалення</h3></a>
<p>Видалення Rust таке саме просте, як і встановлення. Запустіть
сценарій видалення з вашої оболонки :</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#Вирішення-проблем" id="Вирішення-проблем"><h3>Вирішення проблем</h3></a>
<p>Якщо у вас встановлений Rust, ви можете відкрити оболонку і ввести наступне:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>Ви маєте побачити номер версії, хеш-код та дату коміту в форматі, близькому до
цього, для останньої стабільної версії на час встановлення:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Якщо ви це бачите, Rust було успішно встановлено! Вітаємо!</p>
<p>Як ні і ви в Windows, переконайтеся, що Rust є у змінній оточення <code>%PATH%</code> вашої
системи.</p>
<p>Якщо вона все ще не працює, є кілька місць, де вам можуть надати допомогу.
Найпростіше - це <a href="irc://irc.mozilla.org/#rust">IRC-канал #rust на irc.mozilla.org</a><!-- ignore -->, на
який ви можете потрапити за допомгою <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Перейдіть за цією
адресою, і ви зможете поспілкуватися з іншими растацеанцями (кумедне ім'я, яким
ми звемо себе), які зможуть допомогти вам. Також дуже корисними можуть бути
<a href="https://users.rust-lang.org/">користувацький форум</a> та <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<a class="header" href="print.html#Локальна-документація" id="Локальна-документація"><h3>Локальна документація</h3></a>
<p>Програма встановлення також включає локальну копію документації, тож ви можете
читати її без підключення до мережі. Запустіть <code>rustup doc</code>, щоб відкрити
локальну документацію у веб-переглядачі.</p>
<p>Кожного разу коли ви зустрінете тип чи функцію у стандартній бібліотеці і
матимете питання стосовно їхнього призначення, скористайтеся документацією API,
щоб з'ясувати це!</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h2>Hello, World!</h2></a>
<p>Після встановлення Rust напишемо першу програму цією мовою. Давно стало
традицією при вивченні нової мови програмування писати маленьку програму, що
виводить на екран текст  “Hello, world!”, і ми не будемо відступати від цієї
традиції.</p>
<blockquote>
<p>Примітка: ця книжка передбачає базове знайомство із командним рядком. Rust
як така не висуває особливих вимог до редакторів, інструментів і розміщення
коду, тому якщо вам зручніше використовувати IDE замість командного рядка,
можете користуватися вашим улюбленим IDE.</p>
</blockquote>
<a class="header" href="print.html#Створення-теки-проекту" id="Створення-теки-проекту"><h3>Створення теки проекту</h3></a>
<p>Для початку, створіть теку для розміщення вашого коду на Rust. Для Rust немає
значення, де розміщено ваш код, але в цій книжці ми рекомендуємо зробити теку
<em>projects</em> (проекти) у вашій домашній теці і тримати всі проекти там. Запустіть
термінал і введіть такі команди, щоб створити теку для проекту з цього розділу:</p>
<p>Linux і Mac:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projects
&gt; cd %USERPROFILE%\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<a class="header" href="print.html#Написання-і-запуск-програми-на-rust" id="Написання-і-запуск-програми-на-rust"><h3>Написання і запуск програми на Rust</h3></a>
<p>Теперь створіть новий сирцевий файл і назвіть його <em>main.rs</em>. Файли на Rust
завжди закінчуються розширенням <em>.rs</em>. Якщо у назві файлу використовується більш
ніж одне слово, для розділення використовується підкреслення. Наприклад, можна
назвати файл <em>hello_world.rs</em>, але не <em>helloworld.rs</em>.</p>
<p>Тепер відкрийте файл <em>main.rs</em>, який ви щойно створили, і наберіть такий код:</p>
<p><span class="filename">Файл: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Збережіть цей файл і поверніться до вікна терміналу. На Linux або Mac наберіть
такі команди:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>У Windows запустіть <code>.\main.exe</code> замість <code>./main</code>. Незалежно від вашої
операційної системи, ви побачите у терміналі стрічку <code>Hello, world!</code>. Якщо
побачили - вітаємо! Ви щойно написали програму на Rust і офіційно стали
програмістом на Rust! Ласкаво просимо до спільноти!</p>
<a class="header" href="print.html#Анатомія-програми-на-rust" id="Анатомія-програми-на-rust"><h3>Анатомія програми на Rust</h3></a>
<p>Тепер давайте детально пройдемося по тому, що щойно сталося у вашій програмі
&quot;Hello, world!&quot;. Ось перший шматок пазла:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Ці рядки на Rust визначають <em>функцію</em>. Функція <code>main</code> особлива: це перше, що
запускається у кожній виконанній програмі на Rust. Перший рядок каже: &quot;я
проголошую функцію з назовою <code>main</code> без параметрів і яка нічого не повертає.
Якби були параметри, їхні імена треба було розмістити між дужками <code>(</code> та <code>)</code>.</p>
<p>Також зверніть увагу, що тіло функції взято у фігурні дужки <code>{</code> та <code>}</code>. Rust
вимагає таких дужок навколо тіл усіх функцій. Вважається хорошим стилем
розміщувати відкриваючу дужку на тому ж рядку, що й проголошення функції, з
відступом в один пробіл.</p>
<p>Всередині функції <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<p>Цей рядок виконує всю роботу в цій маленькій програмі: виводить текст на екран.
Тут треба зазначити ряд деталей. По-перше, у Rust прийнято робити відступи в
чотири пробіли, а не табуляцію.</p>
<p>Друга важлива деталь - це <code>println!</code>. Це виклик <em>макросу</em> (<em>macro</em>), реалізації
метапрограмування в Rust. Якби ми викликали функцію, то це виглядало б як
<code>println</code> (без <code>!</code>). Макроси в Rust детальніше обговорюються в Розділі 24, а
поки що достатньо знати, що коли ви бачите <code>!</code>, це означає, що викликається
макрос, а не звичайна функція.</p>
<p>Далі іде <code>&quot;Hello, world!&quot;</code>  - це <em>стрічка</em> (<em>string</em>). Ми передаємо цю стрічку
аргументом до <code>println!</code>, який виводить стрічку на екран. Досить просто!</p>
<p>Рядок завершується крапкою із комою (<code>;</code>). Це означає, що цей вираз завершено, і
можна починати наступний. Більшість рядків в коді на Rust завершується <code>;</code>.</p>
<a class="header" href="print.html#Компіляція-і-запуск---окремі-кроки" id="Компіляція-і-запуск---окремі-кроки"><h3>Компіляція і запуск - окремі кроки</h3></a>
<p>В підрозділі &quot;Написання і запуск програми на Rust&quot; ми показали вам, як запускати
щойно створену програму. Тепер розділимо цей процес на частини і дослідимо кожну
з них окремо.</p>
<p>Перед запуском програми на Rust необхідно її скомпілювати. Можна скористатися
компілятором Rust, набравши команду rustc і передавши їй ім'я сирцевого файлу:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>Якщо ви маєте досвід роботи з C чи C++, ви можете помітити, що це схоже на <code>gcc</code>
чи <code>clang</code>. Після вдалої компіляції Rust створює двійковий виконанний файл, який
можна побачити на Linux чи Mac, ввівши команду <code>ls</code> у вашій оболонці:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>В Windows введіть <code>dir /B</code> (опція /B каже показувати імена тільки файлів):</p>
<pre><code class="language-cmd">&gt; dir /B
main.exe
main.rs
</code></pre>
<p>Ми бачиому, що в нас є два файли: сирцевий код, з розширенням <em>.rs</em>, та
виконанний файл (<em>main.exe</em> у Windows, <em>main</em> деінде). Все, що лишається на цей
момент - запустити файл <em>main</em> чи <em>main.exe</em>:</p>
<pre><code class="language-text">$ ./main  # чи .\main.exe у Windows
</code></pre>
<p>Якщо <em>main.rs</em> - це ваша програма &quot;Hello, world!&quot;, вона виведе повідомлення
<code>Hello, world!</code> у вашому терміналі.</p>
<p>Якщо ви переходите з інтерпретованої мови на кшталт Ruby, Python чи JavaScript,
вам може бути незвичним, що компіляція і виконання програми - окремі кроки. Rust
є <em>завчасно компільованою</em> мовою, тобто ви можете скомпілювати програму,
передати її комусь іншому, і він зможе запустити її навіть якщо у нього не
встановлено Rust. Якщо ви передаєте комусь файл <code>.rb</code>, <code>.py</code> чи <code>.js</code>, йому,
натомість, буде потрібна встановлена реалізація мови Ruby, Python чи Javascript,
відповідно, але вам потрібна тільки одна команда щоб скомпілювати та запустити
вашу програму. В
If you come from a dynamic language like Ruby, Python, or JavaScript, you may
not be used to compiling and running a program being separate steps. Rust is an
<em>ahead-of-time compiled</em> language, which means that you can compile a program,
give it to someone else, and they can run it even without having Rust
installed. If you give someone a <code>.rb</code>, <code>.py</code>, or <code>.js</code> file, on the other
hand, they need to have a Ruby, Python, or JavaScript implementation installed
(respectively), but you only need one command to both compile and run your
program. Всі переваги мови програмування мають свою ціну.</p>
<p>Проста компіляція за допомогою <code>rustc</code> годиться для простеньких програм, але зі
зростанням вашого проекту, вам захочеться мати можливість керувати всіма
параметрами, що є у вашому проекті і легко ділитися кодом з іншими людьми та
проектами. Наступний крок - інструмент, що зветься Cargo, який допоможе вам
писати програми на Rust для реального світу.</p>
<a class="header" href="print.html#hello-cargo" id="hello-cargo"><h2>Hello, Cargo!</h2></a>
<p>Cargo is Rust’s build system and package manager, and Rustaceans use Cargo to
manage their Rust projects because it makes a lot of tasks easier. For example,
Cargo takes care of building your code, downloading the libraries your code
depends on, and building those libraries. We call libraries your code needs
<em>dependencies</em>.</p>
<p>The simplest Rust programs, like the one we've written so far, don’t have any
dependencies, so right now, you'd only be using the part of Cargo that can take
care of building your code. As you write more complex Rust programs, you’ll
want to add dependencies, and if you start off using Cargo, that will be a lot
easier to do.</p>
<p>As the vast, vast majority of Rust projects use Cargo, we will assume that
you’re using it for the rest of the book. Cargo comes installed with Rust
itself, if you used the official installers as covered in the Installation
chapter. If you installed Rust through some other means, you can check if you
have Cargo installed by typing the following into your terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>If you see a version number, great! If you see an error like <code>command not found</code>, then you should look at the documentation for your method of
installation to determine how to install Cargo separately.</p>
<a class="header" href="print.html#creating-a-project-with-cargo" id="creating-a-project-with-cargo"><h3>Creating a Project with Cargo</h3></a>
<p>Let's create a new project using Cargo and look at how it differs from our
project in <code>hello_world</code>. Go back to your projects directory (or wherever you
decided to put your code):</p>
<p>Linux and Mac:</p>
<pre><code class="language-text">$ cd ~/projects
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projects
</code></pre>
<p>And then on any operating system run:</p>
<pre><code class="language-text">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<p>We passed the <code>--bin</code> argument to <code>cargo new</code> because our goal is to make an
executable application, as opposed to a library. Executables are binary
executable files often called just <em>binaries</em>. We've given <code>hello_cargo</code>
as the name for our project, and Cargo creates its files in a directory
of the same name that we can then go into.</p>
<p>If we list the files in the <em>hello_cargo</em> directory, we can see that Cargo has
generated two files and one directory for us: a <em>Cargo.toml</em> and a <em>src</em>
directory with a <em>main.rs</em> file inside. It has also initialized a new git
repository in the <em>hello_cargo</em> directory for us, along with a <em>.gitignore</em>
file; you can change this to use a different version control system, or no
version control system, by using the <code>--vcs</code> flag.</p>
<p>Open up <em>Cargo.toml</em> in your text editor of choice. It should look something
like this:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>This file is in the <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (Tom's Obvious, Minimal
Language) format. TOML is similar to INI but has some extra goodies and is used
as Cargo’s configuration format.</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.</p>
<p>The next three lines set the three bits of configuration that Cargo needs to
see in order to know that it should compile your program: its name, what
version it is, and who wrote it. Cargo gets your name and email information
from your environment. If it’s not correct, go ahead and fix that and save the
file.</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any
<em>crates</em> (which is what we call packages of Rust code) that your project will
depend on so that Cargo knows to download and compile those too. We won't need
any other crates for this project, but we will in the guessing game tutorial in
the next chapter.</p>
<p>Now let's look at <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo has generated a &quot;Hello World!&quot; for you, just like the one we wrote
earlier! So that part is the same. The differences between our previous project
and the project generated by Cargo that we've seen so far are:</p>
<ul>
<li>Our code goes in the <em>src</em> directory</li>
<li>The top level contains a <em>Cargo.toml</em> configuration file</li>
</ul>
<p>Cargo expects your source files to live inside the <em>src</em> directory so that the
top-level project directory is just for READMEs, license information,
configuration files, and anything else not related to your code. In this way,
using Cargo helps you keep your projects nice and tidy. There's a place for
everything, and everything is in its place.</p>
<p>If you started a project that doesn't use Cargo, as we did with our project in
the <em>hello_world</em> directory, you can convert it to a project that does use
Cargo by moving your code into the <em>src</em> directory and creating an appropriate
<em>Cargo.toml</em>.</p>
<a class="header" href="print.html#building-and-running-a-cargo-project" id="building-and-running-a-cargo-project"><h3>Building and Running a Cargo Project</h3></a>
<p>Now let's look at what's different about building and running your Hello World
program through Cargo! To do so, enter the following commands:</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
</code></pre>
<p>This should have created an executable file in <em>target/debug/hello_cargo</em> (or
<em>target\debug\hello_cargo.exe</em> on Windows), which you can run with this command:</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>Bam! If all goes well, <code>Hello, world!</code> should print to the terminal once more.</p>
<p>Running <code>cargo build</code> for the first time also causes Cargo to create a new file
at the top level called <em>Cargo.lock</em>, which looks like this:</p>
<p><span class="filename">Filename: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>Cargo uses the <em>Cargo.lock</em> to keep track of dependencies in your application.
This project doesn't have dependencies, so the file is a bit sparse.
Realistically, you won't ever need to touch this file yourself; just let Cargo
handle it.</p>
<p>We just built a project with <code>cargo build</code> and ran it with
<code>./target/debug/hello_cargo</code>, but we can also use <code>cargo run</code> to compile
and then run:</p>
<pre><code class="language-text">$ cargo run
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Notice that this time, we didn't see the output telling us that Cargo was
compiling <code>hello_cargo</code>. Cargo figured out that the files haven’t changed, so
it just ran the binary. If you had modified your source code, Cargo would have
rebuilt the project before running it, and you would have seen something like
this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>So a few more differences we've now seen:</p>
<ul>
<li>Instead of using <code>rustc</code>, build a project using <code>cargo build</code> (or build and
run it in one step with <code>cargo run</code>)</li>
<li>Instead of the result of the build being put in the same directory as our
code, Cargo will put it in the <em>target/debug</em> directory.</li>
</ul>
<p>The other advantage of using Cargo is that the commands are the same no matter
what operating system you're on, so at this point we will no longer be
providing specific instructions for Linux and Mac versus Windows.</p>
<a class="header" href="print.html#building-for-release" id="building-for-release"><h3>Building for Release</h3></a>
<p>When your project is finally ready for release, you can use <code>cargo build --release</code> to compile your project with optimizations. This will create an
executable in <em>target/release</em> instead of <em>target/debug</em>. These optimizations
make your Rust code run faster, but turning them on makes your program take
longer to compile. This is why there are two different profiles: one for
development when you want to be able to rebuild quickly and often, and one for
building the final program you’ll give to a user that won't be rebuilt and
that we want to run as fast as possible. If you're benchmarking the running
time of your code, be sure to run <code>cargo build --release</code> and benchmark with
the executable in <em>target/release</em>.</p>
<a class="header" href="print.html#cargo-as-convention" id="cargo-as-convention"><h3>Cargo as Convention</h3></a>
<p>With simple projects, Cargo doesn't provide a whole lot of value over just
using <code>rustc</code>, but it will prove its worth as you continue. With complex
projects composed of multiple crates, it’s much easier to let Cargo coordinate
the build. With Cargo, you can just run <code>cargo build</code>, and it should work the
right way. Even though this project is simple, it now uses much of the real
tooling you’ll use for the rest of your Rust career. In fact, you can get
started with virtually all Rust projects you want to work
on with the following commands:</p>
<pre><code class="language-text">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<blockquote>
<p>Note: If you want to look at Cargo in more detail, check out the official
<a href="http://doc.crates.io/guide.html">Cargo guide</a>, which covers all of its features.</p>
</blockquote>
<a class="header" href="print.html#hello-cargo-1" id="hello-cargo-1"><h1>Hello, Cargo!</h1></a>
<a class="header" href="print.html#Гра-відгадай-число" id="Гра-відгадай-число"><h1>Гра &quot;відгадай число&quot;</h1></a>
<p>Розпочнемо вивчення Rust зі спільної розробки проекта! Цей розділ ознайомить вас
із кількома поширеними концепціями Rust, показавши вам, як вони використовуються
у реальній програмі. Ви дізнаєтеся про <code>let</code>, <code>match</code>, методи, асоційовані
функції, використання зовнішніх ящиків (crate), і навіть більше! Наступні
розділи розкриють більше деталей цих ідей. У цьому розділі, ви займатиметеся
основами.</p>
<p>Ми розв'язуватимемо класичну задачу для програмістів-початківців: гру &quot;відгадай
число&quot;. Умови такі: програма генерує випадкове ціле число між 1 та 100. Потім
пропонує гравцю відгадати. Ввівши спробу, вона скаже, чи число більше або менше
за неї. Якщо відгадано правильно, гра виведе вітання і припиниться.</p>
<a class="header" href="print.html#Початок-нового-проекту" id="Початок-нового-проекту"><h2>Початок нового проекту</h2></a>
<p>Щоб розпочати новий проект, перейдіть до папки <em>projects</em>, яку ви створили у
Розділі 1, і створіть новий проект за допомогою Cargo, ось так:</p>
<pre><code class="language-text">$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>Перша команда, <code>cargo new</code>, приймає першим параметром ім'я проекту
(<code>guessing_game</code>). Прапорець <code>--bin</code> каже Cargo зробити двійковий проект, так
само, як і в Розділі 1. Друга команда переходить до теки нового проекту.</p>
<p>Переглянемо щойно створений файл <em>Cargo.toml</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Ваше ім'я &lt;адреса@поштовий.сайт&gt;&quot;]

[dependencies]
</code></pre>
<p>Якщо інформація про автора, отримана Cargo з вашого середовища, неправильна,
виправіть це і знову збережіть файл.</p>
<p>Як ви вже бачили у Розділі 1, <code>cargo new</code> створює програму &quot;Hello, world!&quot;.
Подивимося, що міститься у файлі <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Скомпілюймо цю програму “Hello, world!” і запустимо її за один крок за допомогою
команди <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Команда <code>run</code> стає в нагоді, коли треба швидко розвивати проект, і ця гра є
якраз таким проектом: ви хочемо швидко тестувати кожну ітерацію перед тим, як
переходити до наступної.</p>
<p>Знову відкрийте файл <em>src/main.rs</em>. Весь код ви будете писати у ньому.</p>
<a class="header" href="print.html#Обробляємо-здогадку" id="Обробляємо-здогадку"><h2>Обробляємо здогадку</h2></a>
<p>Перша частина програми буде запитувати у користувача ввести здогадку, обробляти
те, що він увів, і перевіряти, чи ввів він дані у потрібній формі. Для початку,
дозволимо користувачеві ввести здогадку. Введіть код з Роздруку 2-1 до
<em>src/main.rs</em>.</p>
<figure>
<span class="filename">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Відгадай число!&quot;);

    println!(&quot;Введіть здогадку.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не вдалося прочитати рядок&quot;);

    println!(&quot;Ваша здогадка: {}&quot;, guess);
}
</code></pre>
<figcaption>
<p>Роздрук 2-1: Код, що отримує здогадку у користувача і виводить її</p>
</figcaption>
</figure>
<p>Цей код містить багато інформації, тому розбиратимемо його шматок за шматком.
Щоб отримати, що ввів користувач, і вивести результат, нам треба ввести
бібліотеку <code>io</code> (ввід/вивід, англ. input/output) в область видимості. Бібліотека
<code>io</code> входить до стандартної бібліотеки, яка зветься <code>std</code>.</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Типово, Rust вводить в область видимості тільки декілька типів у
<a href="https://doc.rust-lang.org/std/prelude/"><em>прелюдії</em> (<em>prelude</em>)</a><!-- ignore -->. Якщо типу, який ви хочете
використати, нема у прелюдії, вам доведеться явно вносити цей тип у область
видимості за допомогою виразу <code>use</code>.  Використання бібліотеки <code>std::io</code> надає
вам ряд корисних речей, пов'язаних із введенням-виведенням, включно з
функціональністю для користувацького вводу.</p>
<p>Як ви бачили у Розділі 1, функція <code>main</code> - це точка входу в програму:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>Синтаксична конструкція <code>fn</code> проголошує нову функцію, <code>()</code> показує, що вона не
має параметрів, і <code>{</code> починає тіло функції.</p>
<p>Як ви вже знаєте з Розділу 1, <code>println!</code> - це макрос, що виводить стрічку на
екран:</p>
<pre><code class="language-rust ignore">println!(&quot;Відгадай число!&quot;);

println!(&quot;Введіть здогадку.&quot;);
</code></pre>
<p>Цей код просто виводить повідомлення, що це за гра і запит введення у
користувача.</p>
<a class="header" href="print.html#Зберігання-значень-у-змінних" id="Зберігання-значень-у-змінних"><h3>Зберігання значень у змінних</h3></a>
<p>Тепер створімо місце для зберігання вводу користувача:</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<p>Тепер програма стає цікавішою! В цьому коротенькому рядку відбувається багато
всього. Зверніть увагу на інструкцію <code>let</code>, що використовується для створення
<em>змінних</em> (<em>variable</em>). Ось інший приклад:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Цей рядок створить нову змінну з назвою <code>foo</code> і зв'яже (bind) її зі значенням
<code>bar</code>. У Rust, змінні типово є сталими (immutable). Наступний
приклад показує, як використовується <code>mut</code> перед іменем змінної, зробити її
несталою (mutable):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5;     // стала
let mut bar = 5; // нестала
#}</code></pre></pre>
<blockquote>
<p>Зверніть увагу: синаксична конструкція <code>//</code> починає коментар, що продовжується
до кінця рядка. Rust ігнорує весь вміст коментаря.</p>
</blockquote>
<p>Тепео ви знаєте, що <code>let mut guess</code> створить несталу змінну, на ім'я <code>guess</code>. З
іншого боку знаку рівності <code>=</code> знаходиться значення, з яким зв'язується <code>guess</code>,
а саме - результат виклику <code>String::new</code>, функції, що повертає новий екземпляр
(instance) стрічки String. <a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> - це тип стрічки,
що надається стандартною бібліотекою; це кодовані в UTF-8 шматки тексту, які
можна нарощувати.</p>
<p>Синаксична конструкція <code>::</code> в рядку <code>::new</code> позначає, що <code>new</code> - це <em>асоційована
функція</em> типу <code>String</code>. Асоційована функція є втіленою (implemented) на типі, в
цьому випадку <code>String</code>, а не на конкретному екземплярі <code>String</code>. В деяких мовах
це зветься <em>статичним методом</em>.</p>
<p>Ця функція <code>new</code> створює нову, пусту <code>String</code>. Функція <code>new</code> зустрінеться вам у
багатьох типах, оскільки це звичайна назва функції, що створює нове значення
певного виду.</p>
<p>Підсумуємо: рядок <code>let mut guess = String::new();</code> створив несталу змінну, зараз
прив'язану до нового, пустого екземпляру <code>String</code>. Уф!</p>
<p>Згадаймо, що ми додали функціональність введення/виведення зі стандартної
бібліотеки за допогою <code>use std::io;</code> у першому рядку програми. Тепер ми
викличемо асоційовану функцію, <code>stdin</code>, з <code>io</code>.</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Не вдалося прочитати рядок.&quot;);
</code></pre>
<p>Якби на початку програми не було рядка <code>use std::io</code>, ми могли б записати цей
виклик функції як <code>std::io::stdin</code>. Функциія <code>stdin</code> повертає екземпляр
<a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->; цей тип репрезентує дескриптор
(handle) стандартного потоку введення терміналу.</p>
<p>Наступна частина коду, <code>.read_line(&amp;mut guess)</code>, викликає метод
<a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> на дескрипторі стандартного потоку
введення, щоб отримати, що ввів користувач. Також ми передаємо <code>read_line</code> один
параметр: <code>&amp;mut guess</code>.</p>
<p><code>read_line</code> бере все, що користувач вводить у стандартний потік введення, і
розміщує це в стрічці, тому приймає цю стрічку аргументом. Цей аргумент мусить
бути несталим, щоб метод змінив вміст стрічки, додавши те, що ввів користувач.</p>
<p><code>&amp;</code> позначає, що цей аргумент - <em>посилання</em> (<em>reference</em>), що дає вам можливість
надати кільком частинам вашого коду доступ до одного фрагменту даних без
кількаразового копіювання цих даних. Посилання - складна тема, але одна з
основних переваг Rust полягає в безпеці і легкості використання посилань. Для
завершення цієї програми вам не знадобляться особливо детальні знання про
посилання; в Розділі 4 будуть надані докладніші пояснення. Поки що, все, що вам
треба знати - що посилання, як і зміні, типово є сталими. Тому необхідно писати
<code>&amp;mut guess</code>, а не просто <code>&amp;guess</code>, щоб зробити її несталою.</p>
<p>Ми ще не закінчили розбиратися із цим рядком коду. Хоча це один рядок тексту, це
лише перша частина єдиного логічного рядка коду. Друга частина - це ось цей
метод:</p>
<pre><code class="language-rust ignore">.expect(&quot;Не вдалося прочитати рядок&quot;);
</code></pre>
<p>Коли ви викликаєте метод за допомогою синтаксичної конструкції <code>.foo()</code> часто
має сенс розпочати новий рядок і додати відступи, щоб розділити довгі рядки. Ми
могли б написати цей код так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Не вдалося прочитати рядок&quot;);
</code></pre>
<p>Але довгий рядок важко читати, тому краще поділити його на два рядки для виклику
двох методів. Тепер розглянемо, що цей рядок робить.</p>
<a class="header" href="print.html#Керування-потенційною-невдачую-за-допомогою-типу-result" id="Керування-потенційною-невдачую-за-допомогою-типу-result"><h3>Керування потенційною невдачую за допомогою типу <code>Result</code></h3></a>
<p>Як вже було сказано, <code>read_line</code> виводить те, що ввів користувач, у стрічку, яку
ми їй передали, але також повертає значення - в цьому випадку,
<a href="../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. В стандартній бібліотеці Rust є кілька
типів, що звуться Result: як звичайний <a href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->, так і
спеціалізовані версії в підмодулях, як-от <code>io::Result</code>.</p>
<p>Типи <code>Result</code> - це <a href="ch06-00-enums.html"><em>переліки</em> (<em>enumeration</em>)</a><!-- ignore -->, які часто
звуть просто <em>енум</em>. Перелік - це тип, який може набувати значення з визначеного
набору, і ці значення звуться <em>варіантами</em> переліку. Розділ 6 детальніше розкриє
роботу енумів.</p>
<p><code>Result</code> має варіанти <code>Ok</code> та <code>Err</code>. <code>Ok</code> показує, що операція була вдалою, і
всередині варіанту <code>Ok</code> знаходиться успішно згенероване значення. <code>Err</code> позначає
відмову, і містить інформацію, як і чому операція була невдалою.</p>
<p>Призначення типів <code>Result</code> - кодувати інформацію про обробку помилок. Значення
типу <code>Result</code>, які інших типів, мають методи, визначені для них. Екземпляр
<code>io::Result</code> має <a href="../std/result/enum.Result.html#method.expect">метод <code>expect</code></a><!-- ignore -->, який можна викликати.
Якщо цей екземпляр <code>io::Result</code> має значення <code>Err</code>, то <code>expect</code> викличе аварійне
завершення програми і виведе повідомлення, яке ви передали параметром <code>expect</code>.
Якщо метод <code>read_line</code> поверне <code>Err</code>, це, швидше за все, буде результатом
помилки в операційній системі. Якщо цей екземлпяр <code>io::Result</code> має значення
<code>Ok</code>, <code>expect</code> візьме значення, яке знаходиться в <code>Ok</code>, і поверне тільки це
значення, щоб їм можна було скористатися. В цьому випадку це значення -
кількість байтів, введених користувачем до стандартного потоку.</p>
<p>Якщо ми не викличемо <code>expect</code>, програма скомпілюється, проте ми отримаємо
попередження:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust попереджає, що ми не використали значення <code>Result</code>, повернуте з
<code>read_line</code>, що означає, що програма не обробила можливу помилку. Правильний
спосіб пригнітити попередження - власне, обробити помилку, але оскільки ми
просто хочемо, щоб програма аварійно завершилася, якщо виникне проблема, можна
скористатися <code>expect</code>. Ви дізнаєтеся про те, як відновити роботу програми при
помилці, у Розділі 9.</p>
<a class="header" href="print.html#Вивід-значень-за-допомогою-заповнювачів-println" id="Вивід-значень-за-допомогою-заповнювачів-println"><h3>Вивід значень за допомогою заповнювачів <code>println!</code></h3></a>
<p>Якщо не враховувати закриваючої фігурної дужки, поки щолишився лише один рядок,
який ми ще не обговорили, а саме:</p>
<pre><code class="language-rust ignore">println!(&quot;Ваша здогадка: {}&quot;, guess);
</code></pre>
<p>Цей рядок виводить стрічку, в якій ми зберегли те, що ввів користувач. Символи
<code>{}</code> - це заповнювач, який замінюється значенням. Ви можете вивести більше
одного значення за допомогою <code>{}</code>: перший набір <code>{}</code> замінюється першим
значенням після форматної стрічки, другий набір - другим значенням і так далі.
Вивід багатьох значень за один виклик <code>println!</code> виглядатиме так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} і y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Цей код виведе <code>x = 5 і y = 10</code>.</p>
<a class="header" href="print.html#Тестування-першої-частини" id="Тестування-першої-частини"><h3>Тестування першої частини</h3></a>
<p>Протестуймо першу частину гри &quot;відгадай число&quot;. Запустіть її за допомогою
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Відгадай число!
Введіть здогадку.     
6
Ваша здогадка: 6
</code></pre>
<p>На цей момент, перша частина гри завершена: ви отримуємо дані з клавіатури і
виводимо їх.</p>
<a class="header" href="print.html#Генерація-таємного-числа" id="Генерація-таємного-числа"><h2>Генерація таємного числа</h2></a>
<p>Тепер нам треба згенерувати таємне число, яке користувач пробуватиме відгадати.
Таємне число має бути різним кожного разу, щоб у гру було цікаво грати більше
одного разу. Використаймо випадкове число від 1 до 100, щоб гра була не надто
складною. Rust поки що не має функціональності для генерації випадкових чисел у
стандартній бібліотеці; натомість команда Rust надає <a href="https://crates.io/crates/rand">ящик <code>rand</code></a>.</p>
<a class="header" href="print.html#Використання-ящика-для-отримання-додаткової-функціональності" id="Використання-ящика-для-отримання-додаткової-функціональності"><h3>Використання ящика для отримання додаткової функціональності</h3></a>
<p>Згадаймо, що <em>ящик</em> - це пакет коду на Rust. Проект, який ми робимо -
<em>двійковий ящик</em> і є виконанним. Ящик <code>rand</code> - <em>бібліотечний ящик</em>, і містить
код, призначений для використання в інших програмах.</p>
<p>Використання зовнішніх ящиків - найсильніший бік Cargo. Перед тим, як писати
код, що використовує <code>rand</code>, ми маємо модифікувати файл <em>Cargo.toml</em>, додавши
туди ящик <code>rand</code> як залежність. Відкрийте цей файл і додайте такий рядок униз,
під заголовком секції <code>[dependencies]</code> (&quot;залежності&quot;), яку Cargo створив для
вас:</p>
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>У файлі <em>Cargo.toml</em> все, що йде після заголовку - частина секції, що
продовжується до початку нової секції. У секції <code>[dependencies]</code> ви повідомляєте
Cargo, від яких зовнішніх ящиків залежить і які версії цих ящиків вам потрібні.
У цьому випадку, ми зазначаємо ящик <code>rand</code> зі семантичним версіонуванням
<code>0.3.14</code>. Cargo розуміє <a href="http://semver.org">семантичне версіонування</a><!-- ignore -->
(також зване <em>SemVer</em>), що є стандартом для запису номеру версії. Запис <code>0.3.14</code>
насправді є скороченням для <code>^0.3.14</code>, що означає &quot;будь-яка версія, що має
публічний API, сумісний із версією 0.3.14&quot;.</p>
<p>Тепер, не змінюючи коду, побудуємо проект, як показано в Роздруку 2-2:</p>
<figure>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<figcaption>
<p>Роздрук 2-2: Вивід команди <code>cargo build</code> після додавання ящика rand як
залежність.</p>
</figcaption>
</figure>
<p>Ви можете побачити інші номери версій (але вони будуть сумісні з кодом завдяки
SemVer!), і рядки можуть бути в іншому порядку.</p>
<p>Тепер, коли ми маємо зовнішню залежність, Cargo витягає останні версії всього,
що нам треба, з <em>реєстру</em>, тобто копії даних з <a href="https://crates.io">Crates.io</a>. На
crates.io в екосистемі Rust люди викладають свої проекти з відкритим кодом, щоб
ними могли скористатися інші.</p>
<p>Після оновлення реєстру, Cargo перевіряє розділ <code>[dependencies]</code> і завантажує
ті, яких у вас бракує. В цьому випадку, хоча ми вказали тільки залежність від
<code>rand</code>, Cargo також завантажив копію <code>libc</code>, тому що <code>rand</code> залежить від <code>libc</code>.
Після завантаження, Rust компілює їх і потім компілює проект.</p>
<p>Якщо ви знову запустите <code>cargo build</code>, не зрозбивши жодних змін, ви не отримаєте
ніякої відповіді. Cargo знає, що він вже завантажив і скомпілював залежності, а
ви не змінили нічого у своєму коді, тому він теж не буде перекомпільований.
Оскільки роботи у Cargo немає, він просто завершує роботу. Якщо ви відкриєте
файл <em>src/main.rs</em>, зробите тривіальну зміну, збережете і знову побудуєте, то
побачите тільки один рядок виводу:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Цей рядок показує, що Cargo обробив тільки вашу дрібну зміну до файлу
<em>src/main.rs</em>. Залежності не змінилися, і Cargi знає, що може заново використати
те, що він вже завантажив і скомпілював. Він перебудовує тільки вашу частину
коду.</p>
<a class="header" href="print.html#Файл-cargolock-гарантує-відтворюваність-побудови" id="Файл-cargolock-гарантує-відтворюваність-побудови"><h4>Файл <em>Cargo.lock</em> гарантує відтворюваність побудови</h4></a>
<p>Cargo має механізм, що гарантує, що гарантує однаковість побудувати проекту
кожного разу, коли ви чи хтось інший будує ваш код: Cargo використає тільки ті
версії залежностей, які ви зазначили, доки ви не вкажете інші. Наприклад, якщо
наступного тижня вийде <code>rand</code> версії <code>0.3.15</code>, що міститиме важливе виправлення
вади, але також регресію, що зіпсує ваш код?</p>
<p>Відповідь на цю задачу - файл <em>Cargo.lock</em>, що створюється при першому запуску
<code>cargo build</code> і розміщується у теці <em>guessing_game</em>. Коли ви збираєте проект
вперше, Cargo визначає всі версії залежностей, що відповідають критерію, і
записує їх у файл <em>Cargo.lock</em>. Коли ви пізніше збиратимете проект, Cargo
побачить, що файл <em>Cargo.lock</em> існує, і використає версії, зазначені там, а не
буде наново визначати версії. Це дозволяє вам автоматично мати відтворювану
збірку. Іншими словами, ваш проект залишиться на версії <code>0.3.14</code>, доки ви самі
не захочете оновити її, завдяки файлу <em>Cargo.lock</em>.</p>
<a class="header" href="print.html#Оновлення-ящика-для-отримання-нової-версії" id="Оновлення-ящика-для-отримання-нової-версії"><h4>Оновлення ящика для отримання нової версії</h4></a>
<p>Коли ви <em>хочете</em> оновити ящик, Cargo надає іншу команду, <code>update</code>, яка:</p>
<ol>
<li>Ігнорує файл <em>Cargo.lock</em> і визначає всі останні версії, що відповідають
специфікаціям в <em>Cargo.toml</em>.</li>
<li>Якщо це вдалося, Cargo напише ці версії до файлу <em>Cargo.lock</em>.</li>
</ol>
<p>Але типово Cargo шукатиме тільки  версії, більші за <code>0.3.0</code> і менші <code>0.4.0</code>.
Якщо ящик <code>rand</code> вийшов у двох нових версіях, <code>0.3.15</code> та <code>0.4.0</code>, ви побачите
таке, запустивши <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Також можна звернути увагу на зміну у файлі <em>Cargo.lock</em> - версія ящика <code>rand</code>,
яку ви використовуєте, тепер <code>0.3.15</code>.</p>
<p>Якщо вам потрібен <code>rand</code> версії <code>0.4.0</code> чи будь-якої версії у гілці <code>0.4.x</code>, вам
доведеться оновити файл <em>Cargo.toml</em>, щоб він мав такий рядок:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Наступного разу, коли ви запустите <code>cargo build</code>, Cargo оновить реєстр доступних
ящиків і переоцінить вимоги до <code>rand</code> відповідно до вказаної вами нової версії.</p>
<p>Можна багато сказати про <a href="http://doc.crates.io">Cargo</a><!-- ignore --> і
<a href="http://doc.crates.io/crates-io.html">його екосистему</a><!-- ignore -->, яка обговорюється у Розділі 14,
але поки що цього знати достатньо. Cargo робить використання бібліотек дуже
простим, що дозволяє растацеанцям писати менші проекти, зібрані з кількох
пакетів.</p>
<a class="header" href="print.html#Генерація-випадкового-числа" id="Генерація-випадкового-числа"><h3>Генерація випадкового числа</h3></a>
<p>Почнемо <em>використовувати</em> <code>rand</code>. Наступний крок - оновити <em>src/main.rs</em>, як
показано в Роздруку 2-3:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Відгадай число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Таємне число: {}&quot;, secret_number);

    println!(&quot;Будь ласка, введіть здогадку:&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не вдалося прочитати рядок&quot;);

    println!(&quot;Ваша здогадка: {}&quot;, guess);
}
</code></pre>
<figcaption>
<p>Роздрук 2-3: Зміни в коді, необхідні для генерації випадкового числа</p>
</figcaption>
</figure>
<p>Ми додаємо рядок <code>extern crate rand;</code> на початок, що дає Rust знати, що ми
будемо використовувати зовнішню залежність. Це, на додачу, виконує функцію,
еквівалентну <code>use rand</code>, так що тепер ми можемо викликати будь-що з ящика
<code>rand</code>, додавши префікс <code>rand::</code>.</p>
<p>Далі ми додаємо ще один рядок із <code>use</code> - <code>use rand::Rng</code>. <code>Rng</code> - це риса, що
визначає методи, втілені генераторами випадкових чисел, і ця риса має бути в
області видимості, щоб можна було використовувати ці методи. Риси детальніше
розкриваються у Розділі 10.</p>
<p>Також, ми додали ще два рядки всередині. Функція <code>rand::thread_rng</code> дає нам
конкретний генератор випадкових чисел, який ми будемо використовувати: локальний
для чинного потоку виконання і ініціалізований операційною системою. Далі, ви
викликаємо метод <code>gen_range</code> цього генератора. Цей метод визначений рисою <code>Rng</code>,
яку ми внесли до області видимості за допомогою інструкції <code>use rand::Rng</code>. Метод
<code>gen_range</code> приймає два числа параметрами і генерує випадкове число між ними,
включно з нижньою межею, але виключаючи верхню, тому треба вказувати <code>1</code> та
<code>101</code>, щоб отримати число між 1 та 100 включно.</p>
<p>Знання, які риси використати і які функції та методи викликати з ящика не є
чимось таким, що треба знати напам'ять. Інструкції з використання ящика є в
документації цього ящика. Ще одна корисна особливість Cargo полягає в тому, що
запуск команди <code>cargo doc --open</code> побудує на вашому комп'ютері документацію,
надану всіма залежностями, і відкриє її у вашому переглядачі. Якщо вам цікава
інша функціональність ящика <code>rand</code>, запустіть <code>cargo doc --open</code> і клацніть
<code>rand</code> на боковій панелі ліворуч.</p>
<p>Другий рядок, який ми додали до коду, виводить таємне число. Це корисно, коли
ми розробляємо програму, щоб можна було перевірити її роботу, але ми видалимо її
у фінальній версії. Буде не дуже цікаво, якщо програма виводитиме відповідь <br />
одразу по запуску!</p>
<p>Спробуємо запустити програму кілька разів:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Відгадай число!
Таємне число: 7
Будь ласка, введіть здогадку:
4
Ваша здогадка: 4
$ cargo run
     Running `target/debug/guessing_game`
Відгадай число!
Таємне число: 83
Будь ласка, введіть здогадку:
5
Ваша здогадка: 5
</code></pre>
<p>Ви маєте побачити різні випадкові числа, і вони мають бути між 1 та 100. Чудово!</p>
<a class="header" href="print.html#Порівняння-здогадки-з-таємним-числом" id="Порівняння-здогадки-з-таємним-числом"><h2>Порівняння здогадки з таємним числом</h2></a>
<p>Тепер, коли ми маємо введене користувачем і випадкове числа, ми можемо їх
порівняти. Цей крок показано в Роздруку 2-4:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Відгадай число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Таємне число: {}&quot;, secret_number);

    println!(&quot;Будь ласка, введіть здогадку:&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не вдалося прочитати рядок&quot;);

    println!(&quot;Ваша здогадка: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Замало!&quot;),
        Ordering::Greater =&gt; println!(&quot;Забагато!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Ви перемогли!&quot;),
    }
}
</code></pre>
<figcaption>
<p>Роздрук 2-4: Різні дії в залежності від порівняння двох чисел</p>
</figcaption>
</figure>
<p>Перше нововведення - ще один <code>use</code>, який вводить тип <code>std::cmp::Ordering</code> зі
стандартної бібліотеки до області видимості. <code>Ordering</code> (&quot;впорядкування&quot;) - це
ще один енум, як і <code>Result</code>, але варіанти <code>Ordering</code> такі: <code>Less</code> (&quot;менше&quot;),
<code>Greater</code> (&quot;більше&quot;), and <code>Equal</code> (&quot;рівно&quot;). Це три можливі результати при
порівнянні двох чисел.</p>
<p>Потім ми додали в кінець коду п'ять нових рядків, в яких використали тип
<code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Замало!&quot;),
    Ordering::Greater =&gt; println!(&quot;Забагато!&quot;),
    Ordering::Equal   =&gt; println!(&quot;Ви перемогли!&quot;),
}
</code></pre>
<p>Метод <code>cmp</code> порівнює два значення і може бути викликаний для всього, що можна
порівнювати. Він приймає параметром посилання на те, що ви хочете порівнювати із
ним: тут він порівнює <code>guess</code> із <code>secret_number</code>. <code>cmp</code> повертає варіант з енуму
<code>Ordering</code>, який ми внесли у область видимості за допомогою інструкції <code>use</code>. Ми
скористалися виразом <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->, щоб визначити, що робити
далі залежно від варіанту <code>Ordering</code>, що його повернув виклик <code>cmp</code> зі
значеннями <code>guess</code> та <code>secret_number</code>.</p>
<p>Вираз <code>match</code> збирається з <em>рукавів</em> (у інших мовах такі конструкції зазвичай
звуться гілками). Рукав складається зі <em>зразка</em> (<em>pattern</em>) та коду, який буде
виконано, якщо значення, передане виразу <code>match</code>, відповідає зразку цього
рукава. Rust бере значення, передане <code>match</code>, і по черзі переверяє зразки
рукавів. Конструкція <code>match</code> і зразки - потужні засоби мови Rust, які дозволяють
вам виражати різноманітні ситуації, які можуть трапитися вам при програмуванні,
і допомагають переконатися, що ви обробили їх усіх. Детально ці можливості
будуть розглянуті в Розділах 5 і 18, відповідно.</p>
<p>Давайте розберемо, як спрацює в цьому коді вираз <code>match</code>. Нехай користувач увів
50, а випадково згенероване цього разу таємне число - 38. Коли код порівнює 50
і 38, метод <code>cmp</code> поверне <code>Ordering::Greater</code>, бо 50 більше за 38. Це значення
отримує вираз <code>match</code>. Він перевіряє зразок першого рукава, <code>Ordering::Less</code>,
але значення <code>Ordering::Greater</code> не відповідає <code>Ordering::Less</code>. Тому код цього
рукава ігнорується і ми переходимо до наступного рукава. Зразок другого рукава,
<code>Ordering::Greater</code>, <em>відповідає</em> <code>Ordering::Greater</code>! Код цього рукава буде
виконано і виведе на екран <code>Забагато!</code>. Вираз <code>match</code> завершується, бо в цьому
конкретному випадку більше нема сенсу перевіряти останній рукав.</p>
<p>Але код у Роздруку 2-4 все ще не компілюється. Спробуємо його скопмілювати:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>Суть цієї помилки в тому, що тут є <em>невідопвідні типи</em>. Rust має сильну,
статичну систему типів. Разом із тим, він має систему виведення типів. Коли ви
писали <code>let guess = String::new()</code>, Rust зміг вивести, що <code>guess</code> має бути типу
<code>String</code> і не просив нас написати тип. <code>secret_number</code>, з іншого боку, числового
типу. Кілька числових типів можуть мати значення між 1 та 100: <code>i32</code>, знакове
32-бітне число; <code>u32</code>, беззнакове 32-бітне число; <code>i64</code>, знакове 64-бітне число
і кілька інших. Типовий вибір Rust <code>i32</code>, і це й буде типом <code>secret_number</code>,
якщо ми не додамо інформацію про тип деінде, щоб змусити Rust вивести інший
числовий тип. Причина ж цієї помилки полягає в тому, що Rust не може порівнювати
стрічку і числовий тип.</p>
<p>Зрештою, ми хочемо перетворити стрічку <code>String</code>, яку програма прочитала з
клавіатури, в числовий тип, щоб можна було порівняти його зі таємним числом. Це
можна зробити, додавши такі рядки до функції <code>main</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Відгадай число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Таємне число: {}&quot;, secret_number);

    println!(&quot;Будь ласка, введіть здогадку:&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не вдалося прочитати рядок&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Будь ласка, введіть число!&quot;);

    println!(&quot;Ваша здогадка: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Замало!&quot;),
        Ordering::Greater =&gt; println!(&quot;Забагато!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Ви перемогли!&quot;),
    }
}
</code></pre>
<p>Ось два нові рядки:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Будь ласка, введіть число!&quot;);
</code></pre>
<p>Ми створили змінну з назвою <code>guess</code>. Але чекайте, в програмі вже ніби існує
змінна з назвою <code>guess</code>? Так, але Rust дозволяє <em>затінювати</em> попереднє значення
<code>guess</code> новим. Ця особливість часто використовується у схожих ситуаціях, коли
нам треба перевторити значення з одного типу в інший. Затінення дозволяє нам
наново використати ім'я змінної <code>guess</code>, щобне довелося створювати дві окремі
змінні на кшталт <code>guess_str</code> і <code>guess</code>. Розділ 3 детальніше розповідає про
затінення.</p>
<p>Ми зв'зали <code>guess</code> з виразом <code>guess.trim().parse()</code>. <code>guess</code> в цьому виразі -
це перша змінна <code>guess</code>, яка має тип <code>String</code>, в якій міститься те, що ввів
користувач. Метод <code>trim</code>, застосований до екземпляру <code>String</code>, видалить всі
пробільні символи на початки і в кінці. <code>u32</code> може бути створений лише зі
стрічки, яка містить тільки цифри, але користувач має натиснути на Enter, щоб
спрацював метод <code>read_line</code>. При цьому в кінець стрічки додається символ нового
рядка. Наприклад, якщо користувач набере 5 і натисне Enter, <code>guess</code> буде
виглядати як <code>5\n</code>, де <code>\n</code> представляє символ нового рядка. Метод <code>trim</code>
видалить <code>\n</code>, і залишиться просто <code>5</code>.</p>
<p><a href="../std/primitive.str.html#method.parse">Метод <code>parse</code> для стрічок</a><!-- ignore --> розбирає стрічку, виділяючи
число певного виду. Оскільки цей метод може виділяти різні числові типи, там
необхідно вказати Rust, який саме числовий тип ми хочемо отримати - за допогомою
<code>let guess: u32</code>. Двокрапка <code>:</code> після <code>guess</code> каже Rust, що ми познааємо тип
змінної. В Rust є кільки вбудованих числових типів; ми вибрали <code>u32</code> -
беззнакове 32-бітне ціле. Це непоганий вибір для невеликих додатних чисел. Про
інші типи ви дізнаєтеся у Розділі 3. На додачу, саме позначка <code>u32</code> у цьому
прикладі і порівняння із <code>secret_number</code> дає Rust можливість вивести, що
<code>secret_number</code> теж має бути <code>u32</code>. І тепер порівнюватимуться два значення
одного типу!</p>
<p>Виклик <code>parse</code> може легко призвести до помилки. Якщо, наприклад, стрічка містить
<code>A👍%</code>, її неможливо перетворити на число. Оскільки метод може завержитися
невдачею, він повертає <code>Result</code>, майже так само, які  метод <code>read_line</code>, про
який ми вже говорили раніше в підрозділі &quot;Керування потенційною невдачую за
допомогою типу <code>Result</code>&quot;. Ви обробимо цей <code>Result</code> так само - за допомогою
методу <code>expect</code>. Якщо <code>parse</code> поверне варіант <code>Err</code>, значить, він не зміг
створити число зі стрічки, <code>expect</code> припинить гру і виведе повідомлення, яке ми
йому надали. Якщо <code>parse</code> вдало створив число зі стрічки, він поверне варіант
<code>Ok</code>, а <code>expect</code> поверне потрібне нам число зі значення <code>Ok</code>.</p>
<p>А тепер запустімо програму!</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Відгадай число!
Таємне число: 58
Будь ласка, введіть здогадку:
  76
Ваша здогадка: 76
Забагато!
</code></pre>
<p>Чудово! Хоча ми й додали пробіли перед здогадкою, програма все одно зрозуміла,
що користувач увів 76. Запустіть програму кілька разів, щоб перевірити різну
поведінку на різних введених даних: введіть таємне число, більше за нього і
менше.</p>
<p>Гра тепер майже працює, але користувачеві надається тільки одна можливість
вгадати. Змінимо це, додавши цикл!</p>
<a class="header" href="print.html#Введення-кількох-здогадок-за-допомогою-циклів" id="Введення-кількох-здогадок-за-допомогою-циклів"><h2>Введення кількох здогадок за допомогою циклів</h2></a>
<p>Ключове слово <code>loop</code> створює нескінчений цикл. Додамо його, щоб дати
користувачам більше можливостей відгадати число:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Відгадай число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Таємне число: {}&quot;, secret_number);

    loop {
        println!(&quot;Будь ласка, введіть здогадку:&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Не вдалося прочитати рядок&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Будь ласка, введіть число!&quot;);

        println!(&quot;Ваша здогадка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Замало!&quot;),
            Ordering::Greater =&gt; println!(&quot;Забагато!&quot;),
            Ordering::Equal   =&gt; println!(&quot;Ви перемогли!&quot;),
        }
    }
}
</code></pre>
<p>Як ви можете бачити, ми перенесли в цикл все від запрошення ввести здогадку і до
кінця. Зсуньте ці рядки ще чотирма пробіли кожен і знову запустіть програму.
Зверніть увагу, що виникла нова проблема, бо програма робить саме те, що ми їй
сказали: запрошує ввести нову здогадку до нескінченості! Схоже, користувач не
може вийти!</p>
<p>Користувач завжди може перервати програму, натиснувши клавіатурне скорочення
<code>Ctrl-C</code>. Але є інший спосіб втекти від цього ненажерного чудовиська - згаданий
при обговоренні <code>parse</code> в підрозділі “Порівняння здогадки з таємним числом”:
якщо користувач введе якесь не-числа, програма аварійно завершиться. Користувач
може цим скористатися, щоб вийти з програми:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Відгадай число!
Таємне число: 59
Будь ласка, введіть здогадку:
45
Ваша здогадка: 45
Замало!
Будь ласка, введіть здогадку:
60
Ваша здогадка: 60
Забагато!
Будь ласка, введіть здогадку:
59
Ваша здогадка: 59
Ви перемогли!
Будь ласка, введіть здогадку:
вийти
thread 'main' panicked at 'Будь ласка, введіть число!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
</code></pre>
<p>Введення <code>вийти</code> дійсно призводить до виходу з гри, але так само спрацює
будь-що, що не є числом. Тим не менше, це щонайменше не найкращий спосіб. Ми
хочемо, щоб гра сама зупинялася, коли ми відгадали число.</p>
<a class="header" href="print.html#Вихід-після-вдалої-здогадки" id="Вихід-після-вдалої-здогадки"><h3>Вихід після вдалої здогадки</h3></a>
<p>Запрограмуймо гру виходити, якщо користувач виграв, додавши <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Відгадай число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Таємне число: {}&quot;, secret_number);

    loop {
        println!(&quot;Будь ласка, введіть здогадку:&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Не вдалося прочитати рядок&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Будь ласка, введіть число!&quot;);

        println!(&quot;Ваша здогадка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Замало!&quot;),
            Ordering::Greater =&gt; println!(&quot;Забагато!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Ви перемогли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Додавання <code>break;</code> після <code>println!(&quot;Ви перемогли!&quot;);</code> примусить програму вийти з
циклу, якщо користувач відгадав таємне число. Вихід із циклу призведе до виходу
з програми, бо цикл - це остання частина функції <code>main</code>.</p>
<a class="header" href="print.html#Обробка-неправильного-вводу" id="Обробка-неправильного-вводу"><h3>Обробка неправильного вводу</h3></a>
<p>Для покращення роботи гри, замінимо аварійний вихід при введені не-числа на
ігнорування, щоб користувач міг продовжувати відгадувати. Ми можемо зробити це,
попрацювавши з рядком, де <code>guess</code> перетворюється з <code>String</code> на <code>u32</code>:</p>
<pre><code class="language-rust ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Заміна виклику <code>expect</code> на вираз <code>match</code> - загальний спосіб переходу від
аварійного завершення програми до реальної обробки помилки. Згадаємо, що метод
<code>parse</code> повертає тип <code>Result</code>, а <code>Result</code> - це енум, що має варіанти <code>Ok</code> та
<code>Err</code>. Ми використовуємо тут вираз <code>match</code>, так само, як робили з <code>Ordering</code>,
що його повертає метод <code>cmp</code>.</p>
<p>Якщо <code>parse</code> зможе вдало перетворити стрічку на число, він поверне значення
<code>Ok</code>, що міститиме число - результат. Це значення <code>Ok</code> буде відповідати зразку
першого рукава, і весь вираз <code>match</code> поверне значення <code>num</code>, яке <code>parse</code>
обчислив і поклав всередину значення <code>Ok</code>. Це число потрапить саме туди, куди
нам треба - в нову змінну <code>guess</code>, яку ми створюємо.</p>
<p>Якщо <code>parse</code> не зможе перетворити стрічку на число, він поверне значення <code>Err</code>,
що міститиме більше інформації про помилку. Значення <code>Err</code> не відпвідає зразку
<code>Ok(num)</code> у першому рукаві <code>match</code>, але відповідає зразку <code>Err(_)</code> у другому.
<code>_</code> - це узагальнене значення; в цьому випадку, ви кажемо, що хочемо відповідати
будь-якому <code>Err</code>, незалежно від інформації, що міститься у ньому. Програма
виконає код другого рукава, <code>continue</code>, що означає - перейти на наступну
ітерацію циклу <code>loop</code> і, відтак, попросити про наступну спробу. Таким чином,
програма ігнорує всі помилки, які можуть зустрітися <code>parse</code>!</p>
<p>Нарешті все у нашій програмі має працювати як треба. Спробуємо запустити
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Відгадай число!
Таємне число: 61
Будь ласка, введіть здогадку:
10
Ваша здогадка: 10
Замало!
Будь ласка, введіть здогадку:
99
Ваша здогадка: 99
Забагато!
Будь ласка, введіть здогадку:
foo
Будь ласка, введіть здогадку:
61
Ваша здогадка: 61
Ви перемогли!
</code></pre>
<p>Відмінно! Лишилася тільки одна дрібна правка, і робота буде завершена: програма
все ще виводить таємне число. Це було необхідно для тестування, але псує гру.
Видаляємо <code>println!</code>, який виводить таємне число, і маємо на Роздруку 2-5
остаточний код:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Відгадай число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Будь ласка, введіть здогадку:&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Не вдалося прочитати рядок&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Ваша здогадка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Замало!&quot;),
            Ordering::Greater =&gt; println!(&quot;Забагато!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Ви перемогли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<figcaption>
<p>Роздрук 2-5: Повний код гри &quot;відгадай число!&quot;</p>
</figcaption>
</figure>
<a class="header" href="print.html#Підсумок" id="Підсумок"><h2>Підсумок</h2></a>
<p>Отже, ви зуміли вдало побудувати гри &quot;відгадай число&quot;! Вітаємо!</p>
<p>Цей проект був вступом до багатьох концепції мови Rust через практику: <code>let</code>,
<code>match</code>, методи, асоційонвані функції, використання зовнішніх ящиків і т.ін. У
кількох наступних розділах ми детальніше розберемо ці концепції. Розділ 3
розповідає про концепції, які є у більшості мов програмування, такі як змінні,
типи даних, функції і показує, як ними користуватися в Rust. Розділ 4 розповідає
про власність, концепцію мови Rust, що є найбільш відмінною від інших мов.
Розділ 5 обговорює структури і методи, а Розділ 6 детально розкриває енуми.</p>
<a class="header" href="print.html#Загальні-концепції-програмування" id="Загальні-концепції-програмування"><h1>Загальні концепції програмування</h1></a>
<p>Цей розділ описує концепції, які можна зустріти у майже кожній мові
програмування і як вони працюють у Rust. Чимало мов програмування мають багато
спільного в своїй основі. Жодна з концепцій, представлених у цьому розділі, не
унікальна для Rust, але ми говоритимемо про них в контексті Rust і роз'яснимо
пов'язані із ними погодження.</p>
<p>Зокрема, ви дізнаєтеся про змінні, базові типи, функції, коментарі і потік
керування. Ці базові понятті зустрічаються у кожній програмі на Rust, і початок
з їхнього вивчення надасть вам міцну основу для подальшого руху.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#Ключові-слова" id="Ключові-слова"><h3>Ключові слова</h3></a>
<p>У мові Rust є набір <em>ключових слів</em>, зарезерованих для використання виключно
самою мовою, так само, як це є в інших мовах. Пам'ятайте, що не можна
використовувати ці слова як назви змінних та функцій. Більшість ключових слів
мають особливе значення, і ви використовуватимете їх для виконання
різноманітних задач у ваших програмах на Rust; декілька наразі не мають
пов'язаної функціональності, проте лишаються зарезерованими для завдань, які
можуть бути додані до Rust в майбутньому. Список ключових слів можна знайти
у Додатку A.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="print.html#Змінні-і-сталість" id="Змінні-і-сталість"><h2>Змінні і сталість</h2></a>
<p>Як вже згадувалося у Розділі 2, типопо змінні є <em>сталими</em> (<em>immutable</em>). Це -
один з численних штурханців, якими Rust заохочує вас писати код, що користується
перевагами у безпеці та швидкості, які надає Rust. Тим не менш, ви все ж маєте
можливість зробити змінні несталими. Дослідимо, як і чому Rust заохочує вас
надавати перевагу сталості, та чому ви можете захотіти відмовитися від цього.</p>
<p>Якщо змінна є сталою, це означає, що відколи значення стає прив'язаним до імені,
ви не можете змінити це значення. Для прикладу згенеруємо новий проект з назвою
<em>variables</em> (&quot;змінні&quot;) у вашій теці <em>projects</em> за допомгою
<code>cargo new --bin variables</code>.</p>
<p>Потім, у новоствореній теці <em>variables</em>, відкрийте <em>src/main.rs</em> і замініть його
код таким:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;Значення x: {}&quot;, x);
    x = 6;
    println!(&quot;Значення x: {}&quot;, x);
}
</code></pre>
<p>Збережіть і запустіть програму за допомогою <code>cargo run</code>. Ви дістанете
повідомлення про помилку, як показано тут:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.0.1 (file:///projects/variables)
error[E0384]: re-assignment of immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;Значення x: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ re-assignment of immutable variable
</code></pre>
<p>Цей приклад показує, як компілятор допомагає вам знаходити помилки у ваших
програмах. Хоча повідомлення компілятора про помилки й можуть бути неприємними,
вони лише означають, що ваша програма ще не робить те, що ви хотіли, у безпечний
спосіб; вони <em>не</em> означають, що ви поганий програміст! Досвідчені растацеанці
також отримують повідомлення про помилки від компілятора. Повідомлення вказує,
що причиною помилки є &quot;переприсвоєння сталій змінній&quot; (<code>re-assignment of immutable variable</code>), бо ми намагалися присвоїти друге значення сталій змінній
<code>x</code>.</p>
<p>Важливо, що ми отримали помилку часу компіляції, коли намагалися змінити
значення, яке раніше визначили як стале, тому що ця ситуація може призвести до
вад у програмі. Якщо одна частина нашого коду працює з припущенням, що значення
не буде змінене, а інша частина нашого коду змінює це значення, можливо, що
перша частина коду буде робити не те, для чого вона була зроблена. Цю причину
вад важко відслідкувати після виявлення, особливо коли другий шмат коду змінює
значення лише <em>іноді</em>.</p>
<p>У Rust компілятор гарантує, що, якщо ми заявили, що змінна не зміниться, вона і
дійсно не зміниться. Це означає, що коли ви читаєте і пишете код, вам не треба
відстежувати, як і де значення може змінитися, що може полегшити обмірковування
коду.</p>
<p>Але несталість може бути вкрай корисною. Змінні є сталими тільки типово; ми
можемо зробити їх несталими, додавши <code>mut</code> перед ім'ям змінної. На додачу до
дозволу змінювати це значення, це попереджає майбутніх читачим коду про ваші
наміри, вказуючи, що інші частини коду будуть змінювати значення цієї змінної.</p>
<p>Наприклад, змінимо <em>src/main.rs</em> на такий код:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;Значення x: {}&quot;, x);
    x = 6;
    println!(&quot;Значення x: {}&quot;, x);
}
</code></pre></pre>
<p>Запустивши програму ми отримаємо:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
     Running `target/debug/variables`
Значення x: 5
Значення x: 6
</code></pre>
<p>Застосувавши <code>mut</code>, ми дозволили змінити значення, прив'язане до <code>x</code>, з <code>5</code> на
<code>6</code>. У деяких випадках, вам захочеться робити змінні несталими, бо так зручніше
писати код, ніж в реалізації з виключно сталими змінними.</p>
<p>Варто розглядати й інші аспекти, крім запобігання вадам. Наприклад, якщо ви
використовуєте великі структури даних, змінювати екземпляр на місці може бути
швидше, ніж копіювати і повертати наново виділений екземпляр. Для менших
структур даних може бути зручнішим розмірковувати про код, написаний у більш
функціональному стилі, з постійним створенням нових екземплярів, тому може бути
варто знизити продуктивність заради збільшення ясності.</p>
<a class="header" href="print.html#Різниця-між-змінними-та-константами" id="Різниця-між-змінними-та-константами"><h3>Різниця між змінними та константами</h3></a>
<p>Неможливість змінити значення змінної може нагадати вам про іншу концепцію
программування, що є в більшості мов: <em>константи</em>. Константи - це так само
значення, прив'язані до імені, які не можна змінювати, але є кілька відмінностей між константами і змінними. По-перше, використання <code>mut</code> з константами
неможливе: константи не тільки типово сталі, вони завжди сталі. Константи
проголошуються ключовим словом <code>const</code> замість <code>let</code>, і тип значення <em>має</em> явно
позначатися. Ми розкажемо про типи і позначки типів у наступному розділі, &quot;Типи
даних&quot;, тому не хвилюйтеся зараз про деталі. Константи можуть проголошуватися
в будь-якій області видимості, у тому числі глобальній, що робить їх корисними
для зберігання значення, яке використовується у багатьох частинах вашого коду.
Остання відмнінність полягає в тому, що константи можуть набувати тільки
значення константних виразів, а не результатів виклику функції чи інших значень,
які можуть бути використані лише під час виконання програми.</p>
<p>Ось приклад проголошення константи, де константа зветься <code>MAX_POINTS</code>, а її
значення є 100,000. Угода про назви констант в Rust вимагає використання
верхнього регістру із підкресленнями між словам:</p>
<pre><code>const MAX_POINTS: u32 = 100_000;
</code></pre>
<p>Константи діють протягом усього часу життя програми, всередині тієї області
видимості, де вони були проголошені. Це робить константи корисними для
зберігання значень у вашому додатку, про які необхідно знати багатьом частинам
програми, наприклад максимальна кількість балів, яку може отримати гравець чи
кількість секунд у році.</p>
<p>Корисно документувати жорстко задані значення, що використовуються по всій
програмі, позначаючи їх константами, щоб передати сенс цього значення тим, хто
супроводжуватиме код. Це також корисно тим, що ви в коді буде тільки одне місце,
яке буде необхідно змінити, у разі потреби оновити жорстко задане значення.</p>
<a class="header" href="print.html#Затінення" id="Затінення"><h3>Затінення</h3></a>
<p>Як ми бачили у Розділі 2, можна проголошувати нові змінні із таким самим іменем,
як і в минулих змінних, і нова змінна <em>затінює</em> (<em>shadows</em>) попередню змінну.
Растацеанці кажуть, що перша змінна <em>затінена</em> (<em>shadowed</em>) другою, що означає,
що при використанні змінної ми отримаємо значення другої змінної. Ми можемо
затінити змінну за допомогою ключового слова <code>let</code> та імені цієї змінної:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;Значення x: {}&quot;, x);
}
</code></pre></pre>
<p>Ця програма спершу прив'язує <code>x</code> до значення <code>5</code>. Потім затінює <code>x</code> повторенням
<code>let x =</code>, взявши початкове значення і додавши до нього <code>1</code>, так що значення <code>x</code>
стає <code>6</code>. Третя інструкція <code>let</code> також затінює <code>x</code>, бере попереднє значення і
множить його на <code>1</code>, щоб надати <code>x</code> остатночного значення <code>12</code>. Якщо запустити
цю програму, вона виведе:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
     Running `target/debug/variables`
Значення x: 12
</code></pre>
<p>Це відрізняється від позначення змінної <code>mut</code>, адже якщо ми знову не
використаємо ключове слово <code>let</code>, отримаємо помилку часу компіляції, якщо
випадково спробуємо переприсвоїти значення цієї змінної. Ми можемо перетворювати
значення, але змінна буде сталою після виконання цих перетворень.</p>
<p>Інша різниця між <code>mut</code> та затіненням полягає в тому, що оскільки коли пишемо
знову ключове слово <code>let</code>, насправді ми створюємо нову змінну, тоже можемо
змінити тип значення, але залишити ім'я. Наприклад, хай наша програма просить
користувача вказати, скільки пробілів має бути всередині якогось тексту, ввівши
символи пробілу, але насправді ми хочемо зберігати це значення як число:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let spaces = &quot;   &quot;;
let spaces = spaces.len();
#}</code></pre></pre>
<p>Ця конструкція можлива, бо перша змінна <code>spaces</code> має стрічковий тип, а друга
змінна <code>spaces</code>, що є повністю новою змінною, якій трапилося мати таке саме
ім'я, має числовий тип. Затінення, таким чином, позбавляє нас необхідності
придумувати різні імена, на кшталт <code>spaces_str</code> та <code>spaces_num</code>; натомість, ми
можемо заново використати простіше ім'я <code>spaces</code>. Але якщо ми спробуємо
скористатися <code>mut</code>, як показано:</p>
<pre><code class="language-rust ignore">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<p>ми отримаємо помилку часу компіляції, бо не можна змінювати тип змінної:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
  = note:    found type `usize`
</code></pre>
<p>Тепер, дослідивши, як працюють змінні, погляньмо, які типи данних вони можуть
зберігати.</p>
<a class="header" href="print.html#Типи-даних" id="Типи-даних"><h2>Типи даних</h2></a>
<p>Кожне значення в Rust має певний <em>тип</em>, який каже Rust, дані якого виду
визначаються, щоб компілятор знав, як працювати з цими даними. У цьому
підрозділі ми розберемо ряд типів, вбудованих у мову. Ми поділимо типи на дві
категорії: скалярні і складені.</p>
<p>У цьому підрозділі майте на увазі, що Rust - <em>статично типізована</em> мова, тобто
тип всіх змінних має бути відомим під час компіляції. Компілятор зазвичай може
вивести, який тип ми хочемо використати, виходячи зі значення і того, як ми його
використовуємо. У випадках, коли можливл багато типів, наприклад якщо ми
перетворюємо стрічку <code>String</code> на число за допомогою <code>parse</code> у Розділі 2, треба
додавати позначку типу:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
#}</code></pre></pre>
<p>Якщо ми не додамо позначку типу, Rust покаже помилку, яка означає, що
компілятору треба більше інфомрації від нас, щоб зрозуміти, який з можливих
типів ми хочемо використати:</p>
<pre><code class="language-text">error[E0282]: unable to infer enough type information about `_`
 --&gt; src/main.rs:2:5
  |
2 | let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |     ^^^^^ cannot infer type for `_`
  |
  = note: type annotations or generic parameter binding required
</code></pre>
<p>Під час подальшого обговорення різних типів даних ви побачите різні позначки
типів.</p>
<a class="header" href="print.html#Скалярні-типи" id="Скалярні-типи"><h3>Скалярні типи</h3></a>
<p><em>Скалярний</em> тип представляє єдине значення. У Rust є чотири первинні скалярні
типи: цілі, числа з рухомою комою, булівські та символи. Ви, швидше за все,
знаєте їх з інших мов програмування, але давайте поглянемо детальніше на їхню
роботу в Rust.</p>
<a class="header" href="print.html#Цілі-типи" id="Цілі-типи"><h4>Цілі типи</h4></a>
<p><em>Ціле</em> (<em>integer</em>) - це число без дробової частини. Ви використали один цілий
тип раніше в цьому розділі, а саме <code>i32</code>. Оголошення цього типу означає, що
асоційонване з ним значення має бути знаковим цілим (це і позначається <code>i</code> від
англ. integer, на відміну від беззнакового <code>u</code> від англ. unsigned) для з 32
двійковими розрядами. Таблиця 3-1 показує вбудовані цілі типи в Rust. Кожен
варіант в колонках &quot;Знаковий&quot; і &quot;Беззнаковий&quot; (наприклад, <em>i32</em>) може використовуватися для проголошення значення цілого типу.</p>
<figure>
<figcaption>
<p>Таблиця 3-1: Цілі типи в Rust</p>
</figcaption>
<table><thead><tr><th> Довжина </th><th> Знаковий </th><th> Беззнаковий </th></tr></thead><tbody>
<tr><td> 8 біт   </td><td> i8       </td><td> u8          </td></tr>
<tr><td> 16 біт  </td><td> i16      </td><td> u16         </td></tr>
<tr><td> 32 біти </td><td> i32      </td><td> u32         </td></tr>
<tr><td> 64 біти </td><td> i64      </td><td> u64         </td></tr>
<tr><td> архіт.  </td><td> isize    </td><td> usize       </td></tr>
</tbody></table>
</figure>
<p>Кожен варіант може бути знаковим чи беззнаковим і має явно зазначений розмір.
&quot;Знаковий&quot; і &quot;беззнаковий&quot; стосується того, чи може число бути від'ємним чи лише
додатним; іншими словами, чи має число знак (знакове) чи воно буде лише додатним
і, відтак, буде представлене без знаку (беззнакове). Це як запис чисел на
папері: якщо знак має значення, число записується зі знаком плюс чи знаком
мінус; але, якщо можна вважати, що число буде додатним, воно записується без
знаку. Знакові числа зберігаються у <a href="https://uk.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%B2%D0%BD%D1%8F%D0%BB%D1%8C%D0%BD%D0%B8%D0%B9_%D0%BA%D0%BE%D0%B4">доповняльному коді</a>.</p>
<p>Кожен знаковий варіант може зберігати числа від -(2<sup>n - 1</sup>) до 2<sup>n -
1</sup> - 1 включно, де <code>n</code> - кількість біт, які цей варіант використовує. Так,
<code>i8</code> може зберігати числа від -(2<sup>7</sup>) до 2<sup>7</sup> - 1, тобто від
-128 до 127. Беззнакові варіанти зберігають числа від 0 до 2<sup>n</sup> - 1,
так, <code>u8</code> може зберігати числа від 0 до 2<sup>8</sup> - 1, тобто від 0 до 255.</p>
<p>На додачу, типи <code>isize</code> та <code>usize</code> залежать від різновиду комп'ютера, на якому
працює ваша програма: 64 біти, якщо це 64-бітна архітектура, чи 32 біти, якщо
32-бітна.</p>
<p>Ви можете писати цілі літерали в будь-якій формі, вказаній у Таблиці 3-2.
Зверніть увагу, що всі числові літерали, крім байтових літералів, дозволяють
використовувати суфікс типу на кшталт <code>57u8</code>, і <code>_</code> як роздільник для поліпшення
читання, як-от <code>1_000</code> (те саме, що й <code>1000</code>).</p>
<figure>
<figcaption>
<p>Таблиця 3-2: Цілі літерали в Rust</p>
</figcaption>
<table><thead><tr><th> Числові літерали   </th><th> Приклад       </th></tr></thead><tbody>
<tr><td> Десятковий         </td><td> <code>98_222</code>      </td></tr>
<tr><td> Шістнадцятковий    </td><td> <code>0xff</code>        </td></tr>
<tr><td> Вісімковий         </td><td> <code>0o77</code>        </td></tr>
<tr><td> Двійковий          </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Байт (тільки <code>u8</code>) </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
</figure>
<p>Як же здогадатися, який тип цілого використати? Якщо ви непевні, типовий вібір
Rust зазвичай непоганий, а типовий цилий тип в Rust - <code>i32</code>: він зазвичай
найшвидший, навіть на 64-бітних системах. Основна ситуація, в якій варто
використовувати <code>isize</code> та <code>usize</code> - індексація якого виду колекції.</p>
<a class="header" href="print.html#Числа-з-рухомою-комою" id="Числа-з-рухомою-комою"><h4>Числа з рухомою комою</h4></a>
<p>Також Rust має два первинні типи для <em>чисел з рухомою комою</em>, тобто чисел з
десятковою комою. Числа з рухомою комою в Rust - це <code>f32</code> та <code>f64</code>, які мають
розмір у 32 біти та 64 біти відповідно. Типовий тип - <code>f64</code>, оскільки його
швидкість приблизно така ж сама, як і в <code>f32</code>, але він має вищу точність. На
32-бітних системах можна використовувати тип <code>f64</code>, але він буде повільнішим за
<code>f32</code> на цих системах. У більшості випадків, вища точність краща за потенційно
гіршу продуктивність, і варто провести оцінку часу виконання коду (англ.
benchmark), якщо ви підозрюєте, що розмір чисел з рухомою комою створює проблему
у вашій ситуації.</p>
<p>Ось приклад, що демонструє числа з рухомою комою у дії:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Числа з рухомою комою представлені у відповідності зі страндартом IEEE-754. Тип
<code>f32</code> є числом одинарної точності, а <code>f64</code> має подвійну точність.</p>
<a class="header" href="print.html#Числові-операції" id="Числові-операції"><h4>Числові операції</h4></a>
<p>Rust підтримує звичайні математичні операції, які ви очікуєте для будь-яких
типів чисел: додавання, віднімання, множення, ділення і остача. Наступний код
демонструє, як використовувати їх і інструкції <code>let</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // додавання
    let sum = 5 + 10;

    // віднімання
    let difference = 95.5 - 4.3;

    // множення
    let product = 4 * 30;

    // ділення
    let quotient = 56.7 / 32.2;

    // остача
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>Кожен вираз використовує математичну операцію і обчислює значення, яке
прив'язується до змінної. Додаток B містить список усіх операцій, які
використовуються в мові Rust.</p>
<a class="header" href="print.html#Булівський-тип" id="Булівський-тип"><h4>Булівський тип</h4></a>
<p>Як і в більшості інших мов програмування, булівський тип у Rust має два можливі
значення: <code>true</code> (&quot;істина&quot;) та <code>false</code> (&quot;неправда&quot;). Булівський тип у Rust
позначається <code>bool</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // із явною позначкою типу
}
</code></pre></pre>
<p>Основний спосіб використання булівських значень - умовні вирази, такі, як
інструкція <code>if</code>. Про ці вирази розповідається в розділі &quot;Управління потоком
виконання&quot;.</p>
<a class="header" href="print.html#Символьний-тип" id="Символьний-тип"><h4>Символьний тип</h4></a>
<p>Досі ми працювали тільки з числами, але Rust підтримує також літери. Тип <code>char</code>
в Rust є найпростішим алфавітним типом, і цей код демонструє один зі способів
його використання:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Тип <code>char</code> в Rust представляє Скалярне значення Юнікоду, тобто може представляти
значно більше, ніж самий лише ASCII. Наголошені літери,
китайські/японські/корейські ідеографи, емоджі, і пробіли нульової довжини є
коректними значеннями типу <code>char</code> в Rust. Скалярні значення Юнікоду варіюються
від <code>U+0000</code> до <code>U+D7FF</code> і від <code>U+E000</code> до <code>U+10FFFF</code> включно. Тим не менш,
&quot;символ&quot; насправді не є концепцією Юнікоду, тому інтуїція стосовно того, що таке
&quot;символ&quot; може не збігатися із <code>char</code> в Rust. Ми обговорюємо це питання
детальніше у підрозділі &quot;Стрічки&quot; в Розділі 8.</p>
<a class="header" href="print.html#Складені-типи" id="Складені-типи"><h3>Складені типи</h3></a>
<p><em>Складені типи</em> дозволяють об'єднувати багато значень інших типів у один тип.
Rust має два базових складених типи: кортежі (tuple) та масиви (array).</p>
<a class="header" href="print.html#Обєднання-значень-у-кортежі" id="Обєднання-значень-у-кортежі"><h4>Об'єднання значень у кортежі</h4></a>
<p>Кортеж - основний спосіб збирати до купи різні числа і інші значення <em>різних</em>
типів у один складений тип.</p>
<p>Кортеж утворюється списком значень, розділених комою, в дужках. Кожна позиція в
кортежі має тип, і типи різних значень у кортежі можуть різнитися. Ми додали
необов'язкову позначку типу у цьому прикладі:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>Змінна <code>tup</code> зв'язується з усім кортежем, оскільки кортеж розглядається як
єдиний складений елемент. Щоб отримати окремі значення з кортежу, можна
скористатися співставлянням зі зразком, щоб деструктуризувати значення кортежу,
на кшталт цього:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;Значення y: {}&quot;, y);
}
</code></pre></pre>
<p>Ця програма спершу створює кортеж і прив'язує його до змінної <code>tup</code>. Потім вона
використовує зразок із <code>let</code>, щоб взяти <code>tup</code> і перетворити його на три окремі
змінні, <code>x</code>, <code>y</code> та <code>z</code>. Це зветься <em>деструктуризацією</em>, бо розбирає структуру
кортежу на частини. Нарешті, програма виводить значення <code>y</code>, тобто <code>6.4</code>.</p>
<p>На додачу до деструктуризації через співставлення зі зразком, ми можемо також
досягати елементів кортежу напряму через точку(<code>.</code>), за якою написаний індекс
значення, яке ми хочемо отримати. Наприклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>Ця програма створює кортеж <code>x</code>, а потім створює нові змінні для кожного елементу
за допомогою їхніх індексів. Як і в більшості мов програмування, перший індекс
в кортежі - 0.</p>
<a class="header" href="print.html#Масиви" id="Масиви"><h4>Масиви</h4></a>
<p>Інший спосіб організувати колекцію з багатьох значень - це <em>масив</em>. На відміну
від кортежу, всі елементи масиву мають один тип. Масиви в Rust відрізняються
від масивів у деяких інших мовах, бо в Rust вони мають фіксовану довжину: після
проголошення, їхній розмір не може зростати чи скорочуватися.</p>
<p>У Rust, значення, що потрапляють до масиву, пишуться у вигляді списку,
розділеного комами, в квадратних дужках:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Масиви корисні, коли дані мають бути розмішені в стеку, а не в купі (детальніше
про це йдеться у Розділі 4), чи коли ви хочете бути певним, що завжди маєте
фіксовану кількість елементів. Втім, масиви не такі гнучкі, як вектори. Вектор -
це схожий тип-колекція, які можуть зростати і скорочуватися. Якщо ви не певні,
використовувати вам масив чи вектор, швидше за все варто використати вектор.
Детальніше про це можна прочитати у Розділі 8.</p>
<p>Приклад випадку, коли вам може знадобитися масив, а не вектор - програма, що
використовує назви місяців року. Навряд чи така програма потребуватиме додавання
чи усунення місяців, тому можна скористатися масивом, бо ви знаєте, що у ньому
завжди буде 12 елементів:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;Січень&quot;,   &quot;Лютий&quot;,   &quot;Березень&quot;, &quot;Квітень&quot;, 
              &quot;Травень&quot;,  &quot;Червень&quot;, &quot;Липень&quot;,   &quot;Серпень&quot;, 
              &quot;Вересень&quot;, &quot;Жовтень&quot;, &quot;Листопад&quot;, &quot;Грудень&quot;];
#}</code></pre></pre>
<a class="header" href="print.html#Доступ-до-елементів-масиву" id="Доступ-до-елементів-масиву"><h5>Доступ до елементів масиву</h5></a>
<p>Масив - це єдиний фрагмент пам'яті, віділений у стеку. До елементів масиву можна
отримати доступ за допомогою індексації, ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>У цьому прикладі, змінна з назвою <code>first</code> отримає значення <code>1</code>, бо це значення,
розташоване за індексом <code>[0]</code> у масиві. Змінна з назвою <code>second</code> отримає
значення <code>2</code> з індексу <code>[1]</code> в масиві.</p>
<a class="header" href="print.html#Некоректний-доступ-до-елементів-масиву" id="Некоректний-доступ-до-елементів-масиву"><h5>Некоректний доступ до елементів масиву</h5></a>
<p>Що станеться, якщо ми спробуємо дістатися до елементів масиву, що знаходяться
за кінцем масиву? Змінимо приклад на такий:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];

    let element = a[10];

    println!(&quot;Значення елементу: {}&quot;, element);
}
</code></pre>
<p>Запуск цього коду за допомогою <code>cargo run</code> видає такий результат:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/arrays` (exit code: 101)
</code></pre>
<p>Компіляція не повідомила про помилку, але програма аварійно завершилася помилкою
<em>часу виконання</em>. Коли ви намагаєтеся отримати доступ до елементу масиву, Rust
перевіряє, чи зазначений індекс менший за довжину масиву. Якщо індекс більший,
Rust <em>панікує</em>, що в Rust означає, що програма завершується помилкою.</p>
<p>Це перший приклад принципів безпеки Rust у дії. В багатьох мовах нищького рівня
такої перевірки не відбувається, і при запиті елементу з некоректним індексом,
відбувається доступ до пам'яті за межами масиву. Rust захищає вас від такої
помилки, одразу перериваючи роботу програми замість того, щоб дозволити
некоректний доступ і продовжити роботу. Розділ 9 розповідає більше про обробку
помилок у Rust.</p>
<a class="header" href="print.html#Як-працюють-функції" id="Як-працюють-функції"><h2>Як працюють функції</h2></a>
<p>Функції використовуються скрізь у коді на Rust. Ви вже бачили одну з
найважливіших функцій у мові - функцію <code>main</code>, яка є точкою входу багатьох
програм. Ви також бачили ключове слово <code>fn</code>, яке дозволяє вам оголошувати нові
функції.</p>
<p>У мові Rust для назв функцій і змінних прийнято використовувати <em>зміїний
регістр</em> - тобто всі літери маленькі, а слова відокремлюються підкресленянми.
Ось приклад програми, що містить визначення функції:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Привіт, світ!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Інша функція.&quot;);
}
</code></pre></pre>
<p>Визначення функцій у Rust починаються з <code>fn</code> і мають кілька пар дужок після
назви функції. Фігурні дужки кажуть компілятору, де починається і закінчується
тіло функції.</p>
<p>Ми можемо викликати будь-яку визначену нами функцію, написавши її назву і пару
дужок. Оскільки <code>another_function</code> визначена в програмі, її можна викликати
зсередини функції <code>main</code>. Зверніть увагу, що ми визначили <code>another_function</code>
у сирцевому коді <em>після</em> функції <code>main</code>; так само її можна було визначити до
функції <code>main</code>. Для Rust не має значення, де ви визначаєте функції, важливо,
щоб вони були визначені хоч десь.</p>
<p>Почнемо новий бінарний проект з назвою <em>functions</em>, щоб глибше дослідити
функції. Помістіть приклад <code>another_function</code> до файлу <em>src/main.rs</em> і запустіть
його. Ви побачите таке:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Привіт, світ!
Інша функція.
</code></pre>
<p>Рядки виконуються в порядку, в якому вони знаходяться в функції <code>main</code>. Спершу
виводиться повідомлення “Привіт, світ!”, а потім викликається <code>another_function</code>
і виводить своє повідомлення.</p>
<a class="header" href="print.html#Параметри-функції" id="Параметри-функції"><h3>Параметри функції</h3></a>
<p>При визначення функціям можна визначати <em>параметри</em> - особливі змінні, що є
частиною визначення функції. Коли функція має параметри, ми можемо надати
функції конкретні значення для цих параметрів. Формально, конкретні значення
звуться <em>аргументами</em> або <em>фактичними параметрами</em>, а параметри у визначенні
функції - <em>формальними параметрами</em>, але зазвичай слова &quot;параметр&quot; та &quot;аргумент&quot;
використовуються як для частини визначення функції, так і для конкретних
значень, які були передані при виклику функції.</p>
<p>Це переписана версія <code>another_function</code> демонструє, як виглядають параметри в
Rust:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;Значення x: {}&quot;, x);
}
</code></pre></pre>
<p>Запустіть цю програму; ви маєте побачити таке:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Значення x: 5
</code></pre>
<p>Проголошення <code>another_function</code> містить один параметр під назвою <code>x</code>. Тип <code>x</code>
визначено як <code>i32</code>. Коли в <code>another_function</code> передається <code>5</code>, макрос <code>println!</code>
виведе <code>5</code> на місце фігурних дужок у рядку формату.</p>
<p>У проголошенні функції ви <em>обов'язково</em> маєте проголошувати тип кожного
параметру. Це свідоме рішення у дизайні мови Rust: вимога позначати тип у
визначенні функції означає, що компілятору дуже рідко знадобиться просити вас
використовувати їх де-інде ще в коді, щоб зрозуміти, який тип вам потрібен.</p>
<p>Якщо ви хочете, щоб у функції було багато параметрів, відокремлюйте проголошення
параметрів комами, ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;Значення x: {}&quot;, x);
    println!(&quot;Значення y: {}&quot;, y);
}
</code></pre></pre>
<p>Цей приклад створює функцію з двома параметрами, обидва мають тип <code>i32</code>. Функція
виводить значення обох своїх параметрів. Звісно, параметрам функції зовсім не
обов'язково мати один тип - просто так зроблено в цьому прикладі.</p>
<p>Спробуймо запустити цей код. Замініть програму у файлі <em>src/main.rs</em> вашого
проекту <em>function</em> кодом вище, і запустіть його командою <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Значення x: 5
Значення y: 6
</code></pre>
<p>Оскільки ми викликали функцію зі значенням <code>5</code> для параметру <code>x</code> і значенням <code>6</code>
для <code>y</code>, обидві стрічки виведені зі цими значеннями.</p>
<a class="header" href="print.html#Тіла-функцій" id="Тіла-функцій"><h3>Тіла функцій</h3></a>
<p>Тіла функцій складаються з послідовності інструкцій, яка може закінчуватися
виразом. Поки що ми описували тільки функції без виразу наприкінці, але
використовували вирази як частини інструкцій. Оскільки Rust є мовою, базованою
на виразах, важливо розуміти цю відмінність. Інші мови можуть не мати таких
відмінностей, тому давайте розглянемо, що таке інструкції і вирази і як різниця
між ними впливає на тіла функцій.</p>
<a class="header" href="print.html#Інструкції-і-вирази" id="Інструкції-і-вирази"><h3>Інструкції і вирази</h3></a>
<p>Насправді ми вже використовували інструкції і вирази. <em>Інструкції</em> (statement) -
це команди, що виконують певні дії і не повертають значення. <em>Вирази</em>
(expression) обчислюються, в результаті даючи певне значення. Розглянемо
приклади.</p>
<p>Створення змінної і надання їй значення за допомогою ключового слова <code>let</code> - це
інструкція. У Роздруку 3-3 <code>let y = 6;</code> є інструкцією:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<figcaption>
<p>Listing 3-3: Проголошення функції <code>main</code>, що містить одну інструкцію.</p>
</figcaption>
</figure>
<p>Проголошення функцій - також інструкції; весь попередній приклад є однією
складною інструкцією.</p>
<p>Інструкції не повертають значень. Таким чином, не можна присвоїти інструкцію
<code>let</code> іншій змінній, на кшталт такого:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>При спробі запустити цю програму, ви отримаєте повідомлення про помилку:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p>Інструкція <code>let y = 6</code> не повертає значення, тому немає нічого, з чим можна було
б зв'язати <code>x</code>. Це відрізняється від інших мов, таких як C чи Ruby, де
присвоєння повертає значення, яке воно присвоїло. В тих мовах можна написати
<code>x = y = 6</code> і обидві змінні <code>x</code> та <code>y</code> набудуть значення <code>6</code>; у Rust так робити
не можна.</p>
<p>Вирази
Вирази обчислюються у певне значення і складають більшу частину решти коду, який
ви писатимете на Rust. Розглянемо просту математичну операцію, таку, як <code>5 + 6</code>,
яка є виразом, що обчислюється у значення <code>11</code>. Вирази можуть бути частинами
інструкцій: у Роздруку 3-3 в інструкції <code>let y = 6;</code>, <code>6</code> - це вираз, що
обчислюється у значення <code>6</code>. Виразами також є виклик функції чи макросу; блок,
що створює нову область видимості, <code>{}</code> - це також вираз, наприклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;Значення y: {}&quot;, y);
}
</code></pre></pre>
<p>Цей вираз:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>є блоком, який, в цьому випадку, обчислюється у <code>4</code>. Це значення прив'язується
до <code>y</code>, як частина інструкції <code>let</code>. Зверніть увагу на рядок без крапки з комою
наприкінці блоку, на відміну від більшості рядків, які нам поки що траплялися.
Вирази не мають крапки з комою наприкінці. Якщо ви додасьте крапу з комою в
кінець виразу, ви зробите його інструкцією, яка не повертає значення. Пам'ятайте
це, коли вивчатимете далі значення, які повертають функції та вирази.</p>
<a class="header" href="print.html#Функції-і-значення-які-вони-повертають" id="Функції-і-значення-які-вони-повертають"><h3>Функції і значення, які вони повертають</h3></a>
<p>Функції можуть повертать значення в код, який їх викликав. Ці значення не мають
власних імен, а їхній тип вказується після стрілочки (<code>-&gt;</code>). У Rust значення, що
його повертає функція - це те саме, що значення останнього виразу в блоці - тілі
функції. Ось приклад функції, що повертає значення:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;Значення x: {}&quot;, x);
}
</code></pre></pre>
<p>У функції <code>five</code> немає викликів інших функцій, макросів чи навіть інструкцій
<code>let</code> - тільки саме число <code>5</code>. Це коректна функція в мові Rust. Зверніть увагу,
що тут зазначено тип значення, яке функція повертає - <code>-&gt; i32</code>. Запустімо цей
код; вивід має виглядати так:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Значення x: 5
</code></pre>
<p><code>5</code> у <code>five</code> є значенням, яке повертає функція, і тому тип, який повертає
функція - <code>i32</code>. Розглянемо це детальніше. Є два важливі моменти: по-перше,
рядок <code>let x = five();</code> показує, що ми використовуємо значення, яке повернула
функція, для ініціалізації змінної. Оскільки функція <code>five</code> повертає <code>5</code>, цей
рядок робить те саме, що й такий:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>По-друге, функція <code>five</code> не має параматрів і визначає тип значення, яке вона
повертає, але тіло функції складається лише з <code>5</code> без крапи з комою, оскільки
значення цього виразу ми хочемо повернути. Подивимося інший приклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;Значення x: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Якщо виконати цей код, він виведе <code>Значення x: 6</code>. Що ж станеться, якщо ми
поставимо крапку з комою в кінець рядка <code>x + 1</code>, щоб він став інструкцією, а не
виразом?</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;Значення x: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Виконання цього коду призводить до такої помилки:</p>
<pre><code class="language-text">error[E0269]: not all control paths return a value
 --&gt; src/main.rs:7:1
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  | ^
  |
help: consider removing this semicolon:
 --&gt; src/main.rs:8:10
  |
8 |     x + 1;
  |          ^
</code></pre>
<p>Основне повідомлення про помилку “not all control paths return a value” (“не всі
шляхи виконання повертають значення”) розкриває основну проблему цього коду.
Визначення функції <code>plus_one</code> каже, що вона має повернути <code>i32</code>, але інструкції
не обчислюються в значення. Таким чином, нічого не повертається, що суперечить
визначенню функції й призводить до помилки. Далі, Rust повідомляє про можливість
виправити цю проблему: він радить прибрати крапку з комою, що дійсно виправить
помилку.</p>
<a class="header" href="print.html#Коментарі" id="Коментарі"><h2>Коментарі</h2></a>
<p>Всі програмісти прагнуть зробити свій код зрозумілішим, та деколи не завадить
додаткове пояснення. В таких випадках програмісти лишають в сирцевому коді
примітки, що звуться <em>коментарями</em>, які ігнорує компілятор, але можуть бути
корисними людям, що читатимуть цей код.</p>
<p>Ось простий коментар:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Hello, world.
#}</code></pre></pre>
<p>У Rust коментарі мають починатися з двох знаків дробу і продовжуються до кінця
рядка. Для коментарів, що займають більше одного рядка, вам доведеться ставити
<code>//</code> у кожному рядку, ось так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Тут ми робимо щось складне, досить довге, щоб нам знадобилося кілька рядків
// коментаря! Отакої! Сподіваюся, цей коментар достатньо детально пояснює, що 
// тут відбувається.
#}</code></pre></pre>
<p>Коментарі також можна розміщувати в кінці рядків, що містять код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // Мені пощастить!
}
</code></pre></pre>
<p>Та частіше ви бачитимете їх у форматі, де коментар знаходиться в окремому рядку
перед кодом, якого він стосується:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Мені пощастить!
    let lucky_number = 7;
}
</code></pre></pre>
<p>Оце й усе про коментарі. Вони не надто складні.</p>
<a class="header" href="print.html#Управління-потоком-виконання" id="Управління-потоком-виконання"><h2>Управління потоком виконання</h2></a>
<p>Рішення, виконувати чи ні певний код залежно від того, чи умова істинна, чи
рішення повторити певний код кілька разів, доки умова істинна - базові
будівельні елементи коду у більшості мов програмування. Найпоширеніші
конструкції, що дозволяють вам управляти потоком виконання коду на Rust є вирази
<code>if</code> та цикли.</p>
<a class="header" href="print.html#Вирази-if" id="Вирази-if"><h3>Вирази <code>if</code></h3></a>
<p>Вираз <code>if</code> дозволяє розгалужувати код у залежності від умов. Ми записуємо умову,
а потім вказуємо: “Якщо ця умова дотримана, запусти цей блок коду. Якщо ж умова
не дотримана, не запускай цей блок коду”.</p>
<p>Створіть новий проект з назвою <em>branches</em> у вашій теці <em>projects</em> для вправ із
виразом <code>if</code>. У файл <em>src/main.rs</em> введіть таке:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;умова істинна&quot;);
    } else {
        println!(&quot;умова хибна&quot;);
    }
}
</code></pre></pre>
<p>Всі вирази <code>if</code> починаються з ключового слова <code>if</code>, за яким іде умова. В цьому
випадку умовою є порівняння, чи має змінна <code>number</code> значення, менше за 5. Блок
коду, який ми хочемо виконати, якщо умова істинна, розміщується одразу після
умови в фігурних дужках. Блоки коду, прив'язані до умов у виразах <code>if</code>, іноді
звуть <em>рукавами</em>, так само, як рукави у виразах <code>match</code>, що ми обговорювали у
секції &quot;Порівняння здогадки з таємним числом&quot; Розділу 2. Також можна додати
необов'язковий вираз <code>else</code>, як тут, щоб надати програмі альтернативний блок
коду для виконання, якщо умова виявиться хибною. Якщо ви не надасьте виразу
<code>else</code>, а умова буде хибною, програма просто пропустить блок <code>if</code> і перейде до
наступного фрагменту коду.</p>
<p>Спробуйте запустити цей код; ви маєте побачити, що він виведе таке:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
умова істинна
</code></pre>
<p>Тепер спробуємо змінити значення <code>number</code> на таке, що зробить умову <code>хибною</code>, і
подивитися, що станеться:</p>
<pre><code class="language-rust ignore">let number = 7;
</code></pre>
<p>Запустіть програму і подивіться на вивід:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
умова хибна
</code></pre>
<p>Також варто зазначити, що умова в цьому коді <em>має</em> бути типу <code>bool</code>. Щоб
побачити, що станеться, якщо умова не <code>bool</code>, спробуйте запустити такий код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let number = 3;

    if number {
        println!(&quot;число є 3&quot;);
    }
}
</code></pre>
<p>Умова у виразі <code>if</code> обчислюється у значення <code>3</code>, і Rust повідомляє про помилку:</p>
<pre><code class="language-text">   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
  = note:    found type `{integer}`

error: aborting due to previous error
Could not compile `branches`.
</code></pre>
<p>Помилка показує, що Rust очікував <code>bool</code>, але виявив число. Rust не буде
автоматично намагатися перетворити не-булівські типи в булівський, на відміну
від таких мов, як Ruby чи JavaScript. Ви маєте завжди явно надавати виразу <code>if</code>
умову типу <code>bool</code>. Якщо ми хочемо, щоб блок із кодом <code>if</code> виконувався тільки,
скажімо, якщо число не дорівнює <code>0</code>, ми можемо змінити вираз <code>if</code> на такий:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;число не дорівнює нулю&quot;);
    }
}
</code></pre></pre>
<p>Виконання цього коду виведе <code>число не дорівнює нулю</code>.</p>
<a class="header" href="print.html#Множинні-умови-з-else-if" id="Множинні-умови-з-else-if"><h4>Множинні умови з <code>else if</code></h4></a>
<p>Можливо обирати з багатьох умов, комбінуючи <code>if</code> та <code>else</code> у ланцюжок виразів
<code>else if</code>. Нариклад:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;число ділиться на 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;число ділиться на 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;число ділиться на 2&quot;);
    } else {
        println!(&quot;число не ділиться на 4, 3, чи 2&quot;);
    }
}
</code></pre></pre>
<p>Ця програма має чотири можливі шляхи. Після запуску, ви маєте побачити таке:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
число ділиться на 3
</code></pre>
<p>Коли ця програма виконується, вона перевіряє по черзі кожен вираз <code>if</code> і виконує
перший блок, для якого умова справджується. Зверніть увагу, що, хоча 6 і
ділиться на 2, ми не бачимо повідомлення <code>число ділиться на 2</code>, так само як і
<code>число не ділиться на 4, 3, чи 2</code> з блоку <code>else</code> - бо Rust виконає тільки той
блок, в якого першого буде істинна умова, а знайшовши його, не виконує його
рукав <code>else</code> - а отже, навіть не перевіряє всю решту умов.</p>
<p>Забагато виразів <code>else if</code> можуть захарастити ваш код, тому, якщо вам треба
більш ніж одна така конструкція, цілком можливо, що знадобиться рефакторизувати
ваш код. У Розділі 6 описана потужна конструкція мови Rust для розгалуження, що
зветься <code>match</code>, для таких випадків.</p>
<a class="header" href="print.html#Використання-if-в-інструкції-let" id="Використання-if-в-інструкції-let"><h4>Використання <code>if</code> в інструкції <code>let</code></h4></a>
<p>Оскільки <code>if</code> є виразом, ми можемо використати його як праву частину інструкції
<code>let</code>, за прикладом роздруку 3-4:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;Значення числа: {}&quot;, number);
}
</code></pre></pre>
<figcaption>
<p>Роздрук 3-4: Присвоєння значення виразу <code>if</code> змінній</p>
</figcaption>
</figure>
<p>Змінна <code>number</code> буде прив'язана до значення, залежно від результату обчислення
виразу <code>if</code>. Запустіть цей код і подивіться, що відбудеться:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
Значення числа: 5
</code></pre>
<p>Нагадаємо, що значенням блоку коду є значення останнього виразу в них, а числа
як такі самі є виразами. В цьому випадку, значення всього виразу <code>if</code> залежить
від того, який блок коду буде виконано. Це означає, що значення, які можуть бути
результатами у кожному рукаві <code>if</code> мають бути одного типу; у Роздруку 3-4,
результати рукавів <code>if</code> та <code>else</code> є цілими числами типу <code>i32</code>. А що ж станеться,
якщо типи не будуть збігатися, як у наступному прикладі?</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;Значення числа: {}&quot;, number);
}
</code></pre>
<p>Якщо ми спробуємо запустити цей код, то отримаємо помилку. Рукави <code>if</code> та <code>else</code>
мають несумісні типи значень, і Rust точно вказує, де шукати проблему в
програмі:</p>
<pre><code class="language-text">   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |     let number = if condition {
  |                  ^ expected integral variable, found reference
  |
  = note: expected type `{integer}`
  = note:    found type `&amp;’static str`
</code></pre>
<p>Вираз у блоці <code>if</code> обчислюється у ціле число, а вираз у блоці <code>else</code>
обчислюється у стрічку. Це не працює, оскільки змінна мусить мати лише один тип.
Rust має точно знати під час компіляції тип змінної <code>number</code>, щоб перевірити, що
цей тип коректний усюди, де ця змінна використовується. Rust не зможе зробити
це, якщо тип <code>number</code> буде визначений після запуску програми; компілятор був би
складнішим і надавав би менше гарантій стосовно коду, якби мусив стежити за
численими можливими типами кожної змінної.</p>
<a class="header" href="print.html#Повторення-коду-за-допомогою-циклів" id="Повторення-коду-за-допомогою-циклів"><h3>Повторення коду за допомогою циклів</h3></a>
<p>Часто трапляється, що блок коду треба виконати більше одного разу. Для цього,
Rust надає декілька <em>циклів</em>. Цикл виконує весь код тіла цикли до кінця, після
чого починає спочатку. Для експериментів з циклами, зробімо новий проект під
назвою <em>loops</em>.</p>
<p>У Rust є три види циклів: <code>loop</code>, <code>while</code> та <code>for</code>. Спробуємо кожен з них.</p>
<a class="header" href="print.html#Повторення-коду-за-допомогою-loop" id="Повторення-коду-за-допомогою-loop"><h4>Повторення коду за допомогою <code>loop</code></h4></a>
<p>Ключове слово <code>loop</code> каже Rust виконувати блок коду знову і знову без кінця або
ж доки не буде прямо сказано зупнитися.</p>
<p>Наприклад, замінимо вміст файлу <em>src/main.rs</em> в теці <em>loops</em> на такий:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;знову!&quot;);
    }
}
</code></pre>
<p>Якщо запустити цю програму, ми побачимо, що <code>знову!</code> виводиться неперервно раз у
раз, доки ми не зупинимо програму вручну. Більшість терміналів підтримують
клавіатурне скорочення Ctrl+C, яке зупиняє програму, що застрягла у нескінченому
циклі. Давайте спробуємо:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
знову!
знову!
знову!
знову!
^Cзнову!
</code></pre>
<p>Символи <code>^C</code> позначають, де ви натиснули Ctrl+C. Слово <code>знову!</code> може вивестися
після <code>^C</code> чи ні, залежно від того, в який саме момент виконання коду був
надісланий сигнал зупинки.</p>
<p>На щастя, Rust надає також інший, більш надійний спосіб перервати цикл. Ключове
слово <code>break</code> може бути розміщене в циклі, щоб сказати програмі, коли припиняти
виконувати цикл. Згадайте, що ми вже його використовували у грі &quot;Відгадай число&quot;
в секції &quot;Вихід після вдалої здогадки&quot; Розділу 2, щоб вийти з програми, коли
користувач вигравав у грі, відгадавши правильне число.</p>
<a class="header" href="print.html#Умовні-цикли-за-допомогою-while" id="Умовні-цикли-за-допомогою-while"><h4>Умовні цикли за допомогою <code>while</code></h4></a>
<p>В програмах часто потрібно обчислювати умову в циклі. Доки умова істинна, цикл
виконується. Коли умова припиняє бути істинною, можна викликати <code>break</code>, щоб
зупинити цикл. Такий цикл можна реалізувати за допомогою комбінації <code>loop</code>,
<code>if</code>, <code>else</code> та <code>break</code>; якщо бажаєте, можете спробувати зробити це зараз.</p>
<p>Втім, цей шаблон настільки часто зустрічається, що Rust має вбудовану
конструкцію для цього, що зветься циклом <code>while</code>. Наступний приклад використовує
<code>while</code>: програма повторюється три рази, зменшуючи число кожного разу. Потім,
після циклу, вона виводить повідомлення і завершується:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0  {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    println!(&quot;ЗАПУСК!!!&quot;);
}
</code></pre></pre>
<p>Ця конструкція усуває багато вкладених конструкцій, які були б потрібні за
використання <code>loop</code>, <code>if</code>, <code>else</code> та <code>break</code>, і вона зрозуміліша. Поки умова
істинна, код виконується; в іншому разі, виходить з циклу.</p>
<a class="header" href="print.html#Перебір-колекції-за-допомогою-for" id="Перебір-колекції-за-допомогою-for"><h4>Перебір колекції за допомогою <code>for</code></h4></a>
<p>Можна використовувати конструкцію <code>while</code>, щоб перебирати елементи колекції,
такої, як масив. Наприклад:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;значення: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<figcaption>
<p>Роздрук 3-5: Перебір елементів колекції за допомогою циклу <code>while</code></p>
</figcaption>
</figure>
<p>Тут код перелічує елементи масиву, починаючи з індекса <code>0</code>, і вивиодить кожен з
них, доки не досягне останнього індекса в масиві (тобто коли <code>index &lt; 5</code> вже не
буде істинним). Виконання цього коду виведе всі елементи масиву:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
значення: 10
значення: 20
значення: 30
значення: 40
значення: 50
</code></pre>
<p>Всі п'ять значень з масиву з'являються на екрані, як і очікувано. Хоча <code>index</code>
досягне значення <code>5</code>, виконання циклу припиняється до спроби отримати шосте
значення з масиву.</p>
<p>Але такий підхід вразливий до помилок; ми можемо викликати паніку в програмі
некоректним індексом. Також він повільний, оскільки компілятор додає код для
перевірки коректності кожного елементу на кожній ітерації.</p>
<p>Більш ефективна альтернатива - цикл <code>for</code>, який виконує код для кожного елементу
колекції. Цикл <code>for</code> виглядає так:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;значення: {}&quot;, element);
    }
}
</code></pre></pre>
<figcaption>
<p>Роздрук 3-5: Перебір елементів колекції за допомогою циклу <code>for</code></p>
</figcaption>
</figure>
<p>Запустивши цей код ми побачимо такий самий вивід, як і в Роздруку 3-5. Що
важливіше, ми збільшили безпеку коду і усунули можливість помилок - тепер
неможливо, що код перейде за кінець масиву чи завершиться зарано, залишивши
кілька значень необробленими.</p>
<p>Наприклад, у коді з Роздруку 3-5, якщо прибрати елемент з масиву <code>a</code>, але забути
змінити умову на <code>while index &lt; 4</code>, код призведе до паніки. За допомогою циклу
<code>for</code> ви не забудете замінити інший код, якщо ви зміните кількість значень в
масиві.</p>
<p>Безпечність і лаконічність циклів <code>for</code> робить їх найпоширенішою конструкцією
циклів у Rust. Навіть у витуаціях, де треба виконати певний код визначену
кількість разів, як у відліку з Роздруку 3-5, більшість растацеанців
скористаються циклом <code>for</code>. Для цього треба буде скористатися типом <code>Range</code>
(&quot;діапазон&quot;), який надається стандартною бібліотекою і генерує послідовно всі
числа, починаючи з одного і закінчуючись перед іншим.</p>
<p>Ось як виглядає відлік, що використовує цикл <code>for</code> і ще один метод, про який ми
ще не говорили, <code>rev</code>, для обернення діапазону:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;ЗАПУСК!!!&quot;);
}
</code></pre></pre>
<p>Виглядає трохи краще, правда ж?</p>
<a class="header" href="print.html#Підсумок-1" id="Підсумок-1"><h2>Підсумок</h2></a>
<p>Нарешті закінчили! Це був величенький розділ: ви вивчили змінні, звичайні вирази
і вирази <code>if</code>, та ще цикли! Якщо ви хочете повправлятися з концепціями,
обговореними у цьому розділі, спробуйте наприсати програми, що роблять таке:</p>
<ul>
<li>конвертуює температуру між шкалами Фаренгейта та Цельсія;</li>
<li>обчислює n-е число Фібоначчі;</li>
<li>виводить слова англійської різдвяної пісні &quot;Дванадцять днів Різдва&quot; з
використанням повторень у пісні (якщо хочете - можете спробувати вивести казку
&quot;Ріпка&quot;).</li>
</ul>
<p>Коли будете готові продовжувати, ми поговоримо про концепцію мови Rust, якої
<em>немає</em> серед поширених серед інших мов програмування - володіння.</p>
<a class="header" href="print.html#Розуміння-володіння" id="Розуміння-володіння"><h1>Розуміння володіння</h1></a>
<p>Володіння - найвиразніша, унікальна для мови Rust особливість, яка дозволяє Rust
гарантувати безпечну роботу з пам'яттю без потреби у збирачі сміття. Тому
важливо розуміти, як володіння працює в Rust. У цьому розділі ми поговоримо про
володіння і декілька пов'язаних особливостей: займання, зрізи, і як Rust
розсташовує дані в пам'яті.</p>
<a class="header" href="print.html#Що-таке-володіння" id="Що-таке-володіння"><h2>Що таке володіння?</h2></a>
<p>Основна особливість Rust - це <em>володіння</em>. Хоча її досить легко пояснити, вона
має глибокі наслідки для усієї мови.</p>
<p>Усі програми мають управляти своїм використанням пам'яті комп'ютера під час
роботи. Деякі мови мають збирача сміття, який постійно шукає пам'ять, що її вже
не використовують, під час роботи програми; в інших мовах програміст має явно
виділяти і звільняти пам'ять. Rust використовує третій підхід: пам'ять
управляється системою володіння з набором правил, які компілятор перевіряє під
час компіляції. Під час виконання володіння не додає жодних додаткових витрат.</p>
<p>Оскільки володіння - нова концепція для багатьох програмістів, потрібен деякий
час, щоб звикнути до нього. Добра новина - що досвідченішим ви ставатимете в
Rust і правилах системи володіння, тим здатнішим до створення безпечного і
ефективного коду ви ставатимете. Так тримати!</p>
<p>Коли ви зрозумієте володіння, ви матимете стійку основу для розуміння
особливостей, що роблять Rust унікальною мовою. В цьому розділі, ви вивчите
володіння, працюючи з прикладами, що концентруються на добре відомих структурах
даних: рядках.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#Стек-і-купа" id="Стек-і-купа"><h3>Стек і купа</h3></a>
</blockquote>
<blockquote>
<p>У багатьох мовах програмування програміст нечасто має думати про стек і купу.
Але в системних мовах, таких, як Rust, розташування значення в стеку чи в купі
більше впливає на поведінку програми і вибір, який ми робимо. Ви пояснимо те,
як стек і купа впливають на володіння пізніше у цьому розділі, а тут даємо
коротке попедеднє пояснення.</p>
<p>Стек і купа - частини пам'яті, до яких ваш код має доступ під час виконання,
але вони мають різну структуру. Стек зберігає значення в порядку, в якому їх
отримує, і видаляє їх у зворотньому порядку. Це зветься <em>останнім надійшов,
першим пішов</em> (англ. &quot;<em>last in, first out</em>&quot;). Стек можна уявити, як стос
тарілок: коли ви додаєте тарілки, треба ставити їх зверху, а коли треба зняти
тарілку, то доводиться брати теж зверху. Додавання чи прибирання тарілок з
середини чи знизу стосу матимуть значно гірший наслідок. Додавання данних у
стек також зветься заштовхуванням, а видалення - відповідно, виштовхуванням.</p>
<p>Стек працює швидко завдяки його способу доступу до даних: йому ніколи не
доводиться шукати місце для нових даних чи для звільнення, бо це місце завжди
на верхівці стеку. Також сприяє швидкій роботі стеку те, що всі дані у ньому
мають заздалегідь відомий фіксований розмір.</p>
<p>Дані, розмір яких невідомий для нас під час компіляції або розмір яких може
змінюватися, можна розміщати в купі. Купа менш організована: коли ми
розміщуємо дані в купі, ми запитуємо певний обсяг місця. Операційна система
знаходить достатньо велику пусту ділянку в купі, позначає, що вона
використовується, і повертає вказівник на це місце. Цей процес зветься
<em>розміщенням у купі</em>, що іноді скорочується до простого &quot;розміщення&quot;.
Заштовхування значень у стек не вважається розміщенням. Оскільки вказівник має
відомий, фіксований розмір, ми можемо зберігати вказівник у стеку, але коли
нам потрібні власне дані в купі, ми маємо перейти за вказівником.</p>
<p>Уявіть собі столи в ресторані. Коли ви входите до ресторану, вам треба назвати
кількість людей, що прийшли з вами, тоді офіціант знайде вам пустий стіл, за
який всі зможуть сісти, і відведе вас до нього. Якщо хтось спізнився, він
зможе спитати, де вас розмістили, щоб приєднатися.</p>
<p>Доступ доданих у купі повільніший, ніж у стеку, бо треба переходити за
вказівником, щоб дістатися туди. Сучасні процесори швидше працюють, якщо
відбувається менше переходів у пам'яті. Розвинемо аналогію: уявімо офіціанта у
ресторані, який приймає замовлення з багатьох столів. Найефективніше буде
прийняти всі замовлення з одного столу перед тим, як переходити до наступного.
Приймати замовлення зі столу A, потім зі столу B, потім знову з A і знову з B
буде значно повільніше. З тієї ж причини процесор краще працює з даними,
розташованими поруч (як у стеку), ніж далеко (як може статися в купі).
Розміщення великого обсягу даних у купі також може займати багато часу.</p>
<p>Коли ваш код викликає функцію, значення, що передаються у функцію (включно із,
можливо, вказівниками на дані у купі) і локальні змінні функції заштовхуються
у стек. Коли функція завершується, ці значення виштовхуються зі стеку.</p>
<p>Відстеження, які частини коду використовують які дані в купі, мінімізація
дублювання даних у купі та очищення більше непотрібних даних у купі, щоб не
скінчилося місце - ось ті завдання, які покликане розв'язати володіння. Коли
ви зрозумієте цю концепцію, вам більше не треба буде постійно думати про стек
і купу, але знання, що причина існування володіння - управління данними у
купі, допоможе вам зрозуміти, чому воно працює саме так.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="print.html#Правила-володіння" id="Правила-володіння"><h3>Правила володіння</h3></a>
<p>По-перше, познайомимося із правилами володіння. Тримайте ці правила на увазі,
поки ми працюватимемо із прикладами, що їх ілюструють:</p>
<blockquote>
<ol>
<li>Кожне значення в Rust має змінну, що зветься її <em>власником</em>.</li>
<li>У кожен момент може бути лише один власник.</li>
<li>Коли власник виходить зі зони видимості, значення буде втрачено.</li>
</ol>
</blockquote>
<a class="header" href="print.html#Область-видимості-змінної" id="Область-видимості-змінної"><h3>Область видимості змінної</h3></a>
<p>Ми вже розбирали приклад програми на Rust у Розділі 2. Тепер, оскільки ми вже
знайомі з основами синтаксису, більше не будемо включати всі ці <code>fn main() {</code> у
приклади, тому, щоб випробувати їх, вам доведеться помістити ці приклади до
функції <code>main</code> самостійно. Завдяки цьому приклади стануть лаконічнішими і
дозволять зосередитися на важливих деталях, а не на шаблонному коді.</p>
<p>У першому приклад володіння, розглянемо область видимості деяких змінних.
Область видимості - це фрагмент програми, в якому з елементом можна працювати.
Нехай ми маємо змінну, що виглядає ось так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;привіт&quot;;
#}</code></pre></pre>
<p>Змінна <code>s</code> посилається на стрічковий літерал, значення якого жорстко закодовано
в тексті нашої програми. Зі змінною можна працювати з моменту її проголошення до
кінця поточної <em>області видимості</em>. Коментарі у Роздруку 4-1 підказують, де
змінна <code>s</code> доступна:</p>
<figure>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // тут s ще не доступна, її не проголошено
    let s = &quot;hello&quot;;   // s доступна з цього місця і надалі

    // щось робимо із s
}                      // область видимості скінчилася, s більше не доступна
#}</code></pre></pre>
<figcaption>
<p>Listing 4-1: Змінна і область видимості, де вона доступна</p>
</figcaption>
</figure>
<p>Іншими словами, є два важливих моменти часу:</p>
<ol>
<li>Коли <code>s</code> потрапляє у зону видимості, вона стає доступною.</li>
<li>Вона лишається такою доки не вийде зі зони видимості.</li>
</ol>
<p>Поки що, стосунки між областю видимості і доступністю змінних такі ж самі, як і
в інших мовах програмування. З цього почнемо розвиватися, додавши тип <code>String</code>.</p>
<a class="header" href="print.html#Тип-string" id="Тип-string"><h3>Тип <code>String</code></h3></a>
<p>Щоб проілюструвати правила володіння, нам знадобиться тип даних, складніший за
ті, що ми вже розглянули у Розділі 3. Всі типи даних, які ми розглядали раніше,
зберігаються в стеку і виштовхуються звідти, коли їхня область видимості
закінчується, але ми хочемо подивитися на дані, що зберігаються в купі і
подивитися, як Rust дізнається, коли вичищати ці дані.</p>
<p>Скористаємося типом <code>String</code> (стрічка) як прикладом і зосередимося на
особливостях <code>String</code>, що стосуються володіння. Ці аспекти також застосовуються
до інших складних типів даних, які надає стандартна бібліотека або ви створюєте
самі. В Розділі 8 ми обговоримо тип <code>String</code> детальніше.</p>
<p>Ми вже бачили стрічкові літерали, де значення стрічки жорстко вбито в програму.
Стрічкові літерали зручні, але не завжди підходять для різних ситуацій, де можна
скористатися текстом. Одна з причин полягає в тому, що вони є сталими. Інша - що
не кожне значення стрічки є відомим під час написання коду: наприклад, як взяти
те, що ввів користувач, і зберегти його? Для цих ситуацій, Rust має другий
стрічковий тип, <code>String</code>. Цей тип розміщується в купі і, відтак, може зберігати
текст, обсяг якого невідомий під час компіляції. Можна створити <code>String</code> зі
стрічкового літерали за допомогою функції <code>from</code>, ось так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;привіт&quot;);
#}</code></pre></pre>
<p>Подвійна двокрапка (<code>::</code>) - це оператор, що дозволяє доступ до простору імен, що
надає нам можливість використати, в цьому випадку, функцію <code>from</code> з типу
<code>String</code>, щоб не довелося використоувати назву на кшталт <code>string_from</code>. Цей
синтаксис детальніше обговорюється у секції “Синтакис методів” Розділу 5 і в
обговоренні простору імен в модулях у Розділі 7.</p>
<p>Цей тип стрічок <em>може</em> бути зміненим:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;привіт&quot;);

s.push_str(&quot;, світе!&quot;); // push_str() дописує літерал до стрічки String

println!(&quot;{}&quot;, s); // Це виведе `привіт, світе!`
#}</code></pre></pre>
<p>У чому ж різниця? Чому <code>String</code> може бути зміненим, але літерали - ні? Різниця
полягає в тому, як ці два типи працюють із пам'яттю.</p>
<a class="header" href="print.html#Память-і-розмішення" id="Память-і-розмішення"><h3>Пам'ять і розмішення</h3></a>
<p>У випадку стрічкового літералу, ми знаємо вміст під час компіляції, тому текст
жорстко заданий прямо у виконуваному файлі, що робить стрічкові літерали
швидкими і ефективними. Але ці властивості випливають з його незмінності. На
жаль, ми не можемо розмістити в двійковому файлі по шмату пам'яті для кожного
фрагменту тексту, розмір яких ми не знаємо під час компіляції і чий розмір може
змінитися під час виконання програми.</p>
<p>З типом <code>String</code>, для підтримки несталого шматка тексту, що може зростати, нам
потрібно виділити певну кількість пам'яті в купі, невідому під час компіляції,
для зберігання вмісту. Це означає:</p>
<ol>
<li>Пам'ять має бути запитана в операційної системи під час виконання.</li>
<li>Нам потрібен спосіб повернення цієї пам'яті операційній системі, коли ми
закінчимо роботу з нашою стрічкою.</li>
</ol>
<p>Першу частину робимо ми самі: коли ви викликаємо <code>String::from</code>, її реалізація
запитує потрібну пам'ять. Це дуже поширено серед мов програмування.</p>
<p>Але друга частина відбувається інакше. У мовах зі <em>збирачем сміття</em> (англ.
garbage collector, GC), саме GC стежить і очищує памя'ть, що більше не
використовується, і ми, як програмісти, більше можемо не думати про неї. Без GC
на програміста покладається відповідальність за визначення невикористаної
пам'яті і виклик коду для її повернення, так само, як ми її запитали. Правильно
це робити історично є складною задачею у програмуванні. Якщо ми забудемо, ми
змарнуємо пам'ять. Якщо ми це зробимо зарано, ми матимемо некоректну змінну.
Якщо ми це зробимо двічі, це теж буде помилкою. Потрібно забезпечити, щоб на
кожне <code>виділення</code> було рівно одне <code>звільнення</code> пам'яті.</p>
<p>Rust іде іншим шляхом: пам'ять автоматично повертається, щойно змінна, що нею
володіла, іде з області видимості. Ось версія нашого прикладу з Роздруку 4-1 із
використанням <code>String</code> замість стрічкового літерала:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // s доступна з цього місця і надалі

    // щось робимо із s
}                                  // область видимості скінчилася, і s тепер
                                   // більше не доступна
#}</code></pre></pre>
<p>Існує точка, де природньо можна повернути пам'ять, використану нашою стрічкою,
операційній системі: коли <code>s</code> іде з видимості. Коли змінна виходить з видимості,
Rust викликає для нас спеціальну функцію. Ця функція зветься <code>drop</code>, і саме там
автор <code>String</code> може розмістити код для повернення пам'яті. Rust викликає <code>drop</code>
автоматично на закриваючій дужці <code>}</code>.</p>
<blockquote>
<p>Примітка: в C++ цей шаблон звільнення ресурсів наприкінці життя об'єкта іноді
зветься <em>Отримання ресурсу є ініціалізація</em> (<em>Resource Acquisition Is
Initialization</em>, RAII). Функція Rust <code>drop</code> знайома вам, якщо ви користувалися
шаблонами RAII.</p>
</blockquote>
<p>Цей шаблон має глибокий вплив на спосіб написання коду Rust. Він наразі може
виглядати простим, але поведінка коду може бути неочікуваною у складніших
ситуаціях, коли ми працюватимемо із декількома змінними, що використовують дані,
виділені в купі. Тепер дослідимо деякі з цих ситуацій.</p>
<a class="header" href="print.html#Способи-взаємодії-змінних-і-даних-переміщення" id="Способи-взаємодії-змінних-і-даних-переміщення"><h4>Способи взаємодії змінних і даних: переміщення</h4></a>
<p>Числені змінні у Rust можуть взаємодіяти з одними і тими ж даними у різні
способи. Подивимося на приклад, що використовує ціле число, у Роздруку 4-2:</p>
<figure>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<figcaption>
<p>Роздрук 4-2: Присвоєння цілого значення змінної <code>x</code> змінній <code>y</code></p>
</figcaption>
</figure>
<p>Ми, мабуть, можемо здогадатися, що робить цей код, з нашого досвіду з іншими
мовами: &quot;прив'язати значення <code>5</code> до <code>x</code>; потім зробити копію значення з <code>x</code> і
прив'язати її до <code>y</code>&quot;. Тепер ми маємо дві змінні, <code>x</code> та <code>y</code>, і обидві
дорівнюють <code>5</code>. І дійсно це так і відбувається, бо цілі - прості значення із
відомим, фіксованим розміром, і ці два значення <code>5</code> внесені у стек.</p>
<p>Тепер подивимося на версію зі <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>Це виглядає дуже схожим на попередній код, тому ми можемо припустити, що воно
працює так само, тобто другий рядок створить копію значення з <code>s1</code> і прив'яже її
до <code>s2</code>. Але тут відбувається щось трохи інше.</p>
<p>Для розлогішого роз'яснення поглянемо на внутрішній устрій 'String' на Рисунку
4-3. <code>String</code> складається з трьох частин, показаних ліворуч: вказівника на
пам'ять, що збергіає вміст стрічки, довжини, і місткості. Цей набір даних
зберігається в стеку. Праворуч показана пам'ять у купі, що зберігає вміст.</p>
<figure>
<img alt="String in memory" src="img/trpl04-01.svg" class="center" 
style="width: 50%;" />
<figcaption>
<p>Рисунок 4-3: Представлення в пам'яті стрічки <code>String</code> зі значенням <code>&quot;hello&quot;</code>,
прив'язаної до <code>s1</code>.</p>
</figcaption>
</figure>
<p>Довжина - це кількість пам'яті, в байтах, що вміст <code>String</code> наразі використовує.
The length is how much memory, in bytes, the contents of the <code>String</code> is
currently using. The capacity is the total amount of memory, in bytes, that the
<code>String</code> has received from the operating system. The difference between length
and capacity matters, but not in this context, so for now, it’s fine to ignore
the capacity.</p>
<p>Коли ми присвоюємо значення <code>s1</code> до <code>s2</code>, дані <code>String</code> копіюються - тобто
копіюється вказівник, довжина і місткість, що знаходяться в стеку. Ми не
копіюємо даних у купі, на які посилається вказівник. Іншими словами,
представлення даних у пам'яті виглядає як на Рисунку 4-4.</p>
<figure>
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" 
class="center" style="width: 50%;" />
<figcaption>
<p>Рисунок 4-4: Представлення в пам'яті змінної <code>s2</code>, що має копію вказівника,
довжини і місткості з <code>s1</code>.</p>
</figcaption>
</figure>
<p>Представлення <em>не</em> виглядає, як показано на Рисунку 4-5, як було б якби Rust
дійсно копіювала також і дані в купі. Якби Rust так робила, операція <code>s2 = s1</code>
була б потенційно надто витратною з точки зору швидкості виконання, якщо в купі
було б багато даних.</p>
<figure>
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" 
style="width: 50%;" />
<figcaption>
<p>Рисуонк 4-5: Інша можливість того, що могло б робити <code>s2 = s1</code>, якби Rust
копіювала також дані в купі.</p>
</figcaption>
</figure>
<p>Раніше ми казали, що коли змінна виходить з області видимості, Rust автоматично
викликає функцію <code>drop</code> і очищає пам'ять цієї змінної в купі. Але Рисунок 4-4
показує, що обидва вказівники вказують на одне й те саме місце. Це створює
проблему: коли <code>s2</code> і <code>s1</code> вийдуть з видимості, вони удвох спробують звільнити
одну й ту саму пам'ять. Це зветься помилкою <em>подвійного звільнення</em>, і ми про
неї вже згадували. Звільнення пам'яті двічі може призвести до пошкодження
пам'яті, і, потенційно, до вразливостей у безпеці.</p>
<p>Для убезпечення пам'яті в цій ситуації в Rust відбувається ще одна дія. Замість
копіювання виділеної пам'яті, Rust вважає <code>s1</code> некоректним і, відтак, більше не
потрібно нічого звільняти, коли <code>s1</code> виходить з області видимості. Перевіримо,
що стається, якщо спробувати використати <code>s1</code> після створення <code>s2</code>:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}&quot;, s1);
</code></pre>
<p>Ви отримаєте помилку на кшталт цієї, бо Rust не допускає використання
некоректних посилань:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:4:27
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |     println!(&quot;{}, world!&quot;,s1);
  |                           ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
which does not implement the `Copy` trait
</code></pre>
<p>Якщо ви чули терміни &quot;пласка копія&quot; та &quot;глибока копія&quot; (“shallow copy” та “deep
copy” відповідно), коли працювали з іншими мовами, поняття копіювання
вказівника, довжини і місткості без копіювання даних виглядають для вас схожими
на пласку копію. Але оскільки Rust також унепридатнює першу змінну, це зветься
не пласкою копією, а <em>переміщенням</em>. Тут надалі вживатиметься вираз <code>s1</code> було
<em>переміщено</em> в <code>s2</code>. Що відбувається в дійсності, показано на Рисунку 4-6.</p>
<figure>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" 
style="width: 50%;" />
<figcaption>
<p>Рисунок 4-6: Представлення в пам'яті після унепридатнення <code>s1</code></p>
</figcaption>
</figure>
<p>Це вирішує нашу проблему! Якщо коректним зосталося лише <code>s2</code>, коли воно вийде з
видимості, то саме звільнить пам'ять, і готово.</p>
<p>На додачу, такий дизайн мови неявно гарантує, що Rust ніколи не буде автоматично
створювати &quot;глибокі&quot; копії ваших даних. Таким чином, будь-яке <em>автоматичне</em>
копіювання може вважатися недорогим з точки зору продуктивності під час
виконання.</p>
<a class="header" href="print.html#Як-взаємодіють-змінні-з-даними-клонування-clone" id="Як-взаємодіють-змінні-з-даними-клонування-clone"><h4>Як взаємодіють змінні з даними: клонування (clone)</h4></a>
<p>Якщо ми <em>хочемо</em> зробити глибоку копію даних <code>String</code> у купі, а не лише в стеку,
ми можемо використати загальний метод, що зветься <code>clone</code>. Синтаксис
використання методів буде обговорено в Розділі 5, але оскільки методи є
загальною особливістю багатьох мов програмування, ви, швидше за все, вже бачили
їх.</p>
<p>Ось приклад дії методу <code>clone</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>Це чудово працює і так слід робити, щоб отримати поведінку, показану на Рисунку
4-5, де дані в купі <em>дійсно</em> копіюються.</p>
<p>Коли ви бачите виклик <code>clone</code>, ви знаєте, що виконується певний визначений код і
цей код може коштувати продуктивності. Це візуальний індикатор, що відбувається
певна операція.</p>
<a class="header" href="print.html#Дані-в-стеку-копіювання-copy" id="Дані-в-стеку-копіювання-copy"><h4>Дані в стеку: копіювання (copy)</h4></a>
<p>Є ще одна дрібниця, про яку ми ще не говорили. Цей код, що використовує цілі,
частина якого вже була показана раніше в Роздруку 4-2, коректно працює:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Але цей код ніби-то суперечить тому, що ми щойно вивчили: ми не викликаємо
clone, то все ж <code>x</code> лишається коректним і не переміщується в <code>y</code>.</p>
<p>Причина у тому, що типи на кшталт цілих, що мають відомий розмір часу
компіляції, зберігаються повністю в стеку, тому копіювання їхніх значень
відбувається швидко. Це означає, що нема підстав запобігати коректності <code>x</code>
після створення змінної <code>y</code>. Іншими словами, тут немає різниці між глибокою та
пласкою копією, і виклик <code>clone</code> не зробить нічого відмінного від звичайного
плаского копіювання, тож можна його не викликати.</p>
<p>Rust має спеціальне позначення, що зветься рисою <code>Copy</code>, яку можна додати до
типів на кшталт цілих, що зберігаються в стеку (детальніше риси обговорюються в
Розділі 10). Якщо тип має рису <code>Copy</code>, старша змінна лишається придатною до
використання після присвоювання. Rust не дозволить позначити тип рисою <code>Copy</code>,
якщо тип, чи якась з його частин, має втілену рису <code>Drop</code>. Якщо тип потребує
чогось особливого, коли змінна іде з видимості, і ми додаємо позначення <code>Copy</code>
до цього типу, ми отримаємо помилку часу компіляції.</p>
<p>Тож які типи мають рису <code>Copy</code> (також кажуть &quot;є <code>Copy</code>&quot;)? Можна перевірити
документацію до певного типу, щоб бути певним, але загальне правило таке:
будь-яка група простих скалярних значень може бути <code>Copy</code>, і нічого з того, що
потребує окремого розміщення в пам'яті чи є ресурсом, не є <code>Copy</code>. Ось кілька
типів, що є <code>Copy</code>:</p>
<ul>
<li>Всі цілі типи, на кшталт <code>u32</code>.</li>
<li>Булевий тип, <code>bool</code>, значення якого <code>true</code> та <code>false</code>.</li>
<li>Всі типи з рухомою комою, на кшталт <code>f64</code>.</li>
<li>Кортежі, якщо вони містять лише типи, що є <code>Copy</code>. <code>(i32, i32)</code> є <code>Copy</code>, але
<code>(i32, String)</code> - ні.</li>
</ul>
<a class="header" href="print.html#Володіння-та-функції" id="Володіння-та-функції"><h3>Володіння та функції</h3></a>
<p>Семантика передачі значень функції подібна до присвоювання значення змінній.
Передача змінної функції є переміщенням чи копією, як і присвоювання. Роздрук
4-7 містит приклад з певними поясненнями, що розкривають, де змінні входять і
виходять з видимості:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s входить у видимість.

    takes_ownership(s);             // значення s переміщується у функцію...
                                    // ...тож s стає нечинним.
    let x = 5;                      // x входить у видимість.

    makes_copy(x);                  // x має бути переміщеним у функцію
                                    // але i32 є Copy, тож можна використовувати
                                    // x і надалі

} // Тут x виходить з видимості, а потім s. Але оскільки значення s було 
  // переміщене, нічого особливого не відбувається.

fn takes_ownership(some_string: String) { // some_string входить у видимість.
    println!(&quot;{}&quot;, some_string);
} // Тут some_string виходить з видимості і викликається `drop`. 
  // Пам'ять звільняється.

fn makes_copy(some_integer: i32) { // some_integer входить у видимість.
    println!(&quot;{}&quot;, some_integer);
} // some_integer виходить з видимості. Нічого особливого не відбувається.
</code></pre></pre>
<figcaption>
<p>Роздрук 4-7: Функції та володіння з поясненнями</p>
</figcaption>
</figure>
<p>Якби ми спробували використати <code>s</code> після виклику <code>takes_ownership</code>, Rust
повідомить про помилку часу компіляції. Ці статичні перевірки захищають нас від
помилок. Спробуйте додати в main код, що використовує <code>s</code> та <code>x</code>, щоб побачити,
де їх можна використовувати, а де правила володіння запобігають цьому.</p>
<a class="header" href="print.html#Повернення-значень-та-видимість" id="Повернення-значень-та-видимість"><h3>Повернення значень та видимість</h3></a>
<p>Повернення значень також може передавати володіння. Ось приклад зі схожими на
Роздрук 4-7 поясненнями:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership переміщує значення, 
                                        // що повертає, в s1.

    let s2 = String::from(&quot;hello&quot;);     // s2 входить у видимість

    let s3 = takes_and_gives_back(s2);  // s2 переміщується в
                                        // takes_and_gives_back, яка переміщує
                                        // значення, що повертає, в s3.
} // s3 виходить з видимості та робить drop. s2 виходить з видимості, але було
  // переміщене, тож нічого не відобувається. s1 виходить з видимості та робить
  // drop.

fn gives_ownership() -&gt; String {             // gives_ownership перемістить
                                             // значення, що повертає, у функцію
                                             // що його викликала.

    let some_string = String::from(&quot;hello&quot;); // some_string входить у видимість

    some_string                              // some_string повертається і
                                             // переміщується до функції, що 
                                             // викликала.
}

// takes_and_gives_back приймає String і повертає String.
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes входить
                                                      // у видимість.

    a_string  // a_string повертається і переміщується до функції, що викликала.
}
</code></pre></pre>
<p>Володіння змінними завше дотримується однакової схеми: присвоєння значення іншій
змінній переміщує його, і коли змінні зі значеннями в купі виходять з видимості,
якщо дані не були переміщені у володіння іншої змінної, значення буде очищене
викликом drop.</p>
<p>Взяття володіння і повернення володіння в кожній функції дещо втомлює. Що, як ми
хочемо довзолити функції використати значення, але не брати володіння? Потреба
повертати все, що ми передаємо в функції, щоб його можна було знову
використовувати, разом із даними, утвореними в результаті роботи функції,
дратує.</p>
<p>Можна повертати багато значень кортежем, на кшталт цього:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() повертає довжину String.

    (s, length)
}
</code></pre></pre>
<p>Але це б давало забагато ритуальних рухів і зайвої роботи для коцепції, що має
бути загальновживаною. На щастя для нас, Rust має засоби для такої концепції, що
зветься <em>посиланнями</em>.</p>
<a class="header" href="print.html#Посилання-і-позичання" id="Посилання-і-позичання"><h2>Посилання і позичання</h2></a>
<p>Проблема з кодом, що використовує кортежі, в кінці попереднього розділу полягає
в тому, що ми маємо повертати <code>String</code> у функцію, що викликає, щоб можна було
використовувати <code>String</code> після виклику <code>calculate_length</code>, бо <code>String</code>
переміщується до <code>calculate_length</code>.</p>
<p>Ось як визначити і використати функцію <code>calculate_length</code>, що приймає параметром
<em>посилання</em> на об'єкт замість перебирати володіння значенням:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>По-перше, зауважте, що весь код із кортежами при визначення змінної та
поверненні з функції зник. По-друге, зверніть увагу, що ми передаємо <code>&amp;s1</code> у
<code>calculate_length</code>, а у визначенні функції ми приймаємо <code>&amp;String</code> замість
<code>String</code>.</p>
<p>Ці амперсанди (символи &amp;) - це <em>посилання</em>, і вони дозволяють нам посилатися на
певне значення, не перебираючи володіння ним. Рисунок 4-5 показує це.</p>
<p><img alt="&String s вказує на String s1" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Рисунок 4-5: <code>&amp;String s</code> вказує на <code>String s1</code></span></p>
<blockquote>
<p>Примітка: операція, зворотня до помилання, зветься розкриттям посилань, і
виконується оператором розкриття <code>*</code>. Ми побачимо деякі застосування цього
оператора в Розділі 8 і обговоримо подробиці розкриття посилань у Розділі 15.</p>
</blockquote>
<p>Розглянемо детальніше виклик функції:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calculate_length(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
#}</code></pre></pre>
<p>Запис <code>&amp;s1</code> створює посилання, що <em>посилається</em> на значення <code>s1</code>, але не володіє
ним. Оскільки воно не володіє, значення, на яке воно вказує, не буде знищене,
коли посилання вийде з області видимості.</p>
<p>Так само, сигнатура функції використовує <code>&amp;</code>, щоб показати, що тип параметру <code>s</code></p>
<ul>
<li>посилання. Додамо трохи коментарів для пояснення:</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calculate_length(s: &amp;String) -&gt; usize { // s - це посилання на String
    s.len()
} // s виходить з видимості. Але оскільки вона не володіє тим, на що 
  // посилається, нічого не відбувається.
#}</code></pre></pre>
<p>Область видимості, де змінна <code>s</code> є дійсною, така сама, як і у будь-якого
параметра функції, але те, на що вказує посилання, не припиняє свого існування
при виході з видимості, бо функція ним не володіє. Параметри - посилання замість
значень означають, що їй не доведеться повертати значення, щоб повернути
володіння, бо вона не має володіння.</p>
<p>Використання посилань - параметрів функції зветься <em>позичанням</em>. Як і в
справжньому життя, якщо особа володіє чимось, ви можете це позичити у неї, а
коли річ вам стане не потрібна, треба її віддати.</p>
<p>Що ж станеться, якщо ми спробуємо змінити щось, що ми позичили? Спробуйте
запустити код з Роздруку 4-4. Попередження: він не працює!</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">Роздрук 4-4: спроба змінити позичене значення</span></p>
<p>Ось помилка:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
 --&gt; error.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- use `&amp;mut String` here to make mutable
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>Посилання, так само, як і змінні, устано є сталими. Ми не можемо змінити щось,
на що ми маємо посилання.</p>
<a class="header" href="print.html#Несталі-посилання" id="Несталі-посилання"><h3>Несталі посилання</h3></a>
<p>Посилку в коді з Роздруку 4-4 можна виправити маленьким виправленням:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>По-перше, треба змінити <code>s</code>, щоб він став <code>mut</code>. Потім, нам треба створити
нестале посилання за допомогою <code>&amp;mut s</code> і прийняти це нестале посилання за
допомогою <code>some_string: &amp;mut String</code>.</p>
<p>Але несталі посилання мають одне велике обмеження: ви может емати лише одне
нестале посилання на конкретний фрагмент даних у окремій області видимості. Цей
код не спрацює:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>Ось помилка:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; borrow_twice.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
</code></pre>
<p>Це обмеження дозволяє внесення змін лише під пильним контролем. Це те, із чим
борються новачки-растаціанці, бо більшість мов дозволяють вам змінювати коли
завгодно. Перевага цього обмеження в тому, що Rust запобігає гонитві за даними
під час компіляції.</p>
<p><em>Гонитва за даними</em> подібна до стану гонитви і стається, коли мають місце такі
умови:</p>
<ol>
<li>Два чи більше вказівників мають доступ до одних даних у один і той самий час.</li>
<li>Щонайменше один зі вказівників використовується для запису даних.</li>
<li>Не застосовується жодних механізмів синхронізації доступу до даних.</li>
</ol>
<p>Гонитва за даними викликає невизначену поведінку та її може бути складно виявити
та виправити при відстеженні під час виконання; Rust запобігає цій проблеми, бо
вона не дозволяє навіть скомпілювати код із гонитвою!</p>
<p>Як завжди, ми можемо скористатися фігурними дужками, щоб створити нову область
видимості, дозволивши багато несталих посилань, але не <em>одночасно</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1 виходить із видимості, так що можна без проблем створювати нові 
  // посилання.

let r2 = &amp;mut s;
#}</code></pre></pre>
<p>Схоже правило існує для змішування сталих і несталих посилань. Цей код
призводить до помилки:</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // без проблем
let r2 = &amp;s; // без проблем
let r3 = &amp;mut s; // ПРОБЛЕМА
</code></pre>
<p>Ось помилка:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --&gt; borrow_thrice.rs:6:19
  |
4 |     let r1 = &amp;s; // без проблем
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // без проблем
6 |     let r3 = &amp;mut s; // ПРОБЛЕМА
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Отакої! Не виходить <em>також</em> мати нестале посилання, коли в нас є стале.
Користувачі сталого посилання не очікують, що його значення несподівано
зміниться прямо під час використання. Втім, багато сталих посилань допустимі,
бо жоден з тих, хто прости читає дані, не може вплинути на те, що інші читають
ці дані.</p>
<p>Хоча ці помилки часами і дратують, пам'ятайте, що це компілятор Rust вказує на
потенційний баг завчасно (під час компіляції замість часу виконання) і точно
вказує, де полягає проблема, замість змушувати вас відстежувати, чому іноді ваші
дані не такі, як ви очікували.</p>
<a class="header" href="print.html#Завислі-посилання" id="Завислі-посилання"><h3>Завислі посилання</h3></a>
<p>У мовах із вказівниками легко можна помилково створити <em>завислий вказівник</em> -
вказівник, що посилається на місце в пам'яті, що було виділене комусь іще,
звільнивши пам'ять, але залишивши вказівник на цю пам'ять. У Rust, натомість,
компілятор гарантує, що посилання ніколи не стануть завислими: якщо маємо
посилання на певні дані, компілятор пересвідчиться, що дані не вийдуть із
області видимості до того, як вийде посилання на ці дані.</p>
<p>Спробуймо створтти зависле посилання, чому Rust запобігне помилкою компіляції:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>Ось помилка:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; dangle.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p>Це повідомлення про помилку посилається на особливість, про яку ми ще не
розповідали: <em>час життя</em> (<em>lifetime</em>). Ми обговоримо часи життя детальніше у
Розділі 10. Але, якщо опустити частини про час життя, повідомлення містить ключ
до того, чому цей код містить проблему:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<pre><code class="language-text">тип, що повертає ця функція, містить позичене значення, але немає значення, яке
воно може позичити.
</code></pre>
<p>Поглянемо ближче, що саме стається на кожному кроці коду <code>dangle</code>:</p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangle повертає посилання на String

    let s = String::from(&quot;hello&quot;); // s - це новий String

    &amp;s // ми повертаємо посилання на String, s
} // s виходить із видимості і звільняється. Його пам'ять втрачена. Небезпечно!
</code></pre>
<p>Оскільки <code>s</code> був створений всередині <code>dangle</code>, коли код <code>dangle</code> завершується,
<code>s</code> буде вивільнено. Але ми пробуємо повернути посилання на нього. Це означає,
що це посилання буде вказувати на некоректний <code>String</code>! Так не можна. І Rust
цього не допустить.</p>
<p>Рішення тут - повертати <code>String</code> безпосередньо:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
#}</code></pre></pre>
<p>Це працює без проблем. Володіння переміщується, і нічого не звільняється.</p>
<a class="header" href="print.html#Правила-посилань" id="Правила-посилань"><h3>Правила посилань</h3></a>
<p>Ще раз повторимо, що ми обговорили про посилання:</p>
<ol>
<li>У будь-який час можна мати <em>лише одне</em>, а не обидва:</li>
</ol>
<ul>
<li>Одне нестале посилання.</li>
<li>Будь-яку кількість сталих посилань.</li>
</ul>
<ol start="2">
<li>Посилання завжди мають бути коректними.</li>
</ol>
<p>Далі ми поглянемо на інших тип посилань: зрізи.</p>
<a class="header" href="print.html#Зрізи" id="Зрізи"><h2>Зрізи</h2></a>
<blockquote>
<p>Від перекладача: приклад у цьому розділі написаний лише для кращого розуміння
концепції зрізів. Зокрема, спроба замінити рядок на кириличний може призвести
до неочікуваних наслідків. Причина таких проблем роз'яснуюється у Розділі 8.2.
Можливо, це буде виправлено в останніх версіях оригіналу.</p>
</blockquote>
<p>Інший тип данних, що не тримає володіння - <em>зріз</em> (<em>slice</em>). Зрізи дозволяють
посилатися на неперервні послідовності елементів в колекції замість усієї
колекції.</p>
<p>Існує така проста програмістська задача: написати функцію, що приймає стрічку
і повертає перше слово, яке знаходиться в цій стрічці. Якщо функція не знайде
пробіл у стрічці, це означає що вся стрічка є одним словом і, відтак, функція
має повернути всю стрічку.</p>
<p>Спробуємо написати сигнатуру цієї функції?</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>Ця функція, <code>first_word</code>, приймає параметром <code>&amp;String</code>. Нам не потрібна
власність, тому це нормально. Але що ми маємо повернути? У нас немає способу,
що виразити <em>частину</em> стрічки. Тим не менш, ми можемо повернути індекс кінця
слова. Спробуємо зробити це у Роздруку 4-10:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<figcaption>
<p>Роздрук 4-10: Функція <code>first_word</code>, що повертає індекс символа пробіла
у параметрі типу <code>String</code>.</p>
</figcaption>
</figure>
<p>Давайте трохи розберемо цей код. Оскільки нам треба перебрати стрічку у
параметрі <code>s</code> елемент за елементом і перевірити, чи не пробіл це, ми
перетворюємо стрічку на масив байтів за допомогою методу <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Далі ми створюємо ітератор по масиву байтів за допомогою методі <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Ітератори будуть детальніше обговорені в Розділі 16. Поки що достатньо знати,
що <code>iter</code> - метод, що повертає кожен елемент в колекції, а метод <code>enumerate</code>
обгортає результат у кортеж, перший елемент якого - індекс, а другий - посилання
на елемент. Це трохи зручніше, ніж обчислювати індекс самостійно.</p>
<p>Оскільки метод <code>enumerate</code> повертає кортеж, ми використаємо шаблон для деструктуризації цього кортежу. В циклі <code>for</code> ми визначаємо шаблон, що
складається з індексу <code>i</code> і елементу <code>&amp;item</code> в кортежі. <code>&amp;</code> в шаблоні позначає,
що це посилання.</p>
<p>Ми шукаємо байт, який представляє символ пробілу, за допомогою байтового
літералу. Коли знаходимо його, повертаємо його індекс. Якщо цього не сталося,
повертаємо довжину стрічки за допомогою методу <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Тепер ми маємо спосіб знайти індекс кінця першого слова у стрічці, але є
проблема. Ми повертаємо одне значення <code>usize</code>, але це значення має сенс лише в
контексті нашої стрічки. Іншими словами, оскільки це значення не пов'язане із зі
стрічкою, немає гарантії, що воно буде коректним у подальшому. Розглянемо
програму у Роздруку 4-11, що використовує функцію <code>first_word</code> з Роздруку 4-10:</p>
<figure>
<span class="filename">Файл: src/main.rs</span>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;String) -&gt; usize {
#     let chars = s.chars();
#
#     for (i, item) in chars.enumerate() {
#         if item == ' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word матиме значення 5

    s.clear(); // Очищуємо s, так що його значення стає &quot;&quot;.

    // word все ще містить значення 5, але рядка, в якому можна використати
    // це значення, вже не існує. word має некоректне значення!
}
</code></pre></pre>
<figcaption>
<p>Роздрук 4-11: Збереження результату виклику функції <code>first_word</code> і наступна
зміна вмісту стрічки</p>
</figcaption>
</figure>
<p>Ця програма компілюється без помилок, і також скопмілювалася б, якби ви
використали <code>word</code> після виклику <code>s.clear()</code>. <code>word</code> ніяк не пов'язане зі станом
<code>s</code>, і тому <code>word</code> міститиме значення <code>5</code>. Ми можемо використати це значення <code>5</code> зі змінною <code>s</code>, щоб спробувати видобути з неї перше слово, але це буде помилкою,
бо вміст <code>s</code> змінився відколи ми зберегли <code>5</code> до <code>word</code>.</p>
<p>Необхідність дбати про актуальність індексу в <code>word</code> відносно даних в <code>s</code> нудно
і може спровокувати помилки! Керування такими індексами стає ще більш ламким,
якщо ми напишемо функцію <code>second_word</code>. Її сигнатура буде виглядати так:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Тепер ми відстежуємо початковий <em>і</em> кінцевий індекси, і ми маємо ще більше
значень, обчислених з даних у конкретному стані, але ніяк не прив'язаних до
цього стану. Тепер ми маємо три непов'язані змінні, підвішені в повітрі, які нам
треба тримати синхронізованими.</p>
<p>На щастя, у Rust є рішення цієї проблеми: зрізи стрічок.</p>
<a class="header" href="print.html#Зрізи-стрічок" id="Зрізи-стрічок"><h3>Зрізи стрічок</h3></a>
<p><em>Зріз стрічки</em> - це посилання на частину стрічки <code>String</code>, і виглядає воно так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
#}</code></pre></pre>
<p>Це схоже на посилання на всю стрічку <code>String</code>, але з додатковим шматком
<code>[0..5]</code>. Замість того, щоб посилатися на всю <code>String</code>, воно посилається на
внутрішню частину в <code>String</code> і число елементів, яких воно стосується.</p>
<p>Ми створюємо зрізи з межами <code>[початковий_індекс..кінцевий_індекс]</code>, але
структура даних зрізу насправді зберігає початкову позицію і довжину зрізу. Тому
у випадку <code>let world = &amp;s[6..11];</code>, <code>world</code> буде зрізом, що складається зі вказівника на 6-й байт <code>s</code> і довжини 5.</p>
<p>Рисунок 4-12 показує це як діаграму.</p>
<figure>
<img alt="world містить вказівник на 6-й байт стрічки s і довжину 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<figcaption>
<p>Рисунок 4-12: зріз стрічки, що посилається на частину <code>String</code>.</p>
</figcaption>
</figure>
<p>Синтаксис меж <code>..</code> у Rust дозволяє, якщо ви хочете почати зріз на початковому
індексі (нуль), пропустити значення перед крапками. Іншими словами, ці рядки
тотожні:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>Так само якщо ваш зріз включає останній байт стрічки, ви можете пропустити
останнє число. Таким чином, ці рядки також тотжні:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>Також можна пропустити обидва значення, щоб взяти зріз з усієї стрічки. Це також
тотожні рядки:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
#}</code></pre></pre>
<p>Озброєні цими знаннями, перепишемо <code>first_word</code>, щоб вона повертала зріз. Тип,
що позначає зріз стрічки, записується як <code>&amp;str</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>Ми отримуємо індекс кінця слова тим же чином, що й у Роздруку 4-10, пошуком
першого стрічного пробілу. Коли ми знаходимо пробіл, ми повертаємо зріз стрічки
за допомогою початку стрічки і індексу знайденого пробілу як початкового і кінцевого індексів.</p>
<p>Тепер при виклику <code>first_word</code> ми отримаємо одне значення, пов'язане з даними.
Значення складається з посилання на початкову точку зрізу і кількість елементів
у зрізі.</p>
<p>Повернення зрізу також спрацює для функції <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Тепер ми маємо нехитрий API, з яким значно складніше потрапити в халепу,
оскільки компілятор забезпечіть коректність посилань на стрічку. Пам'ятаєте помилку в програмі з Роздруку 4-11, коли ми мали індекс кінця першого слова, але
очистили стрічку, чим зробили наш індекс некоректним? Цей код мав логічну
помилку, але не призводив до жодних негайних помилок. Проблеми з'явилися б
надалі, якби ми спробували використовувати індекс першого слова з пустою стрічкою. Зрізи унеможливлюють цю помилку і дають знати про проблему в коді
значно раніше. Використання зрізової версії <code>first_word</code> призведе до помилки
під час компіляції:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // Помилка!
}
</code></pre>
<p>Ось текст помилки компілятора:</p>
<pre><code class="language-text">17:6 error: cannot borrow `s` as mutable because it is also borrowed as
            immutable [E0502]
    s.clear(); // Error!
    ^
15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents
            subsequent moves or mutable borrows of `s` until the borrow ends
    let word = first_word(&amp;s);
                           ^
18:2 note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Пригадаємо, що за правилами позичання, якщо ми маємо стале посилання на щось,
ми не можемо робити нестале посилання на це ж. Оскільки <code>clear</code> має скоротити
стрічку, він намагається взяти нестале посилання - невдало. Rust не тільки
робить наш API простішим у використанні, а ще й усуває під час компіляції цілий клас помилок!</p>
<a class="header" href="print.html#Стрічкові-літерали-є-зрізами" id="Стрічкові-літерали-є-зрізами"><h4>Стрічкові літерали є зрізами</h4></a>
<p>Згадайте, що ми говорили про стрічкові літерали, збережені у двійковому файлі.
Оскільки тепер ми вже знаємо про зрізи, ми можемо як слід зрозуміти стрічкові
літерали:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Hello, world!&quot;;
#}</code></pre></pre>
<p>Типом <code>s</code> є <code>&amp;str</code>: це зріз, що вказує на конкретне місце в двійковому файлі. Це
також є причиною, чому стрічкові літерали є сталими; <code>&amp;str</code> є сталим посиланням.</p>
<a class="header" href="print.html#Стрічкові-зрізи-як-параметри" id="Стрічкові-зрізи-як-параметри"><h4>Стрічкові зрізи як параметри</h4></a>
<p>Знання того, що можна брати зрізи літералів і <code>String</code> веде нас до ще одного
поліпшення <code>first_word</code>. Її сигнатура наразі така:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Більш досвідчений растацеанин напише замість цього такий рядок, бо він дозволяє
нам використовувати одну й ту саму функцію і для <code>String</code> і для <code>&amp;str</code>:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Якшр у нас є стрічковий зріз, ми можемо передати його прямо. Якщо у нас є
<code>String</code>, ми можемо передати зріз з усією стрічкою. Визначення функції, що
приймає стрічковий зріз замість посилання на стрічку робить наш API більш загальним і корисним без втрати функціональності:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word працює зі зрізами `String`а
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word працює зі зрізами стрічкових літералів
    let word = first_word(&amp;my_string_literal[..]);

    // оскільки стрічкові літерали *є* стрічковими зрізами
    // це також працює, без синтаксису зрізів!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<a class="header" href="print.html#Інші-зрізи" id="Інші-зрізи"><h3>Інші зрізи</h3></a>
<p>Стрічкові зрізи, як можна зрозуміти, пов'язані зі стрічками. Але є також і більш
загальний тип зрізів. Розглянемо такий масив:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Так само, як ми можемо захотіти звернутися до частини стрічки, ми можемо
захотіти звернутися до частини масиву і зробити так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>Цей зріз має тип <code>&amp;[i32]</code>. Він працює тим же чином, що й стрічкові зрізи,
зберігаючи посилання на перший елемент і довжину. Цей тип зрізів можна
використовувати для всіх інших видів колекцій. Ми поговоримо про ці колекції детальніше, коли будемо обговорювати вектори в Розділі 8.</p>
<a class="header" href="print.html#Висновки" id="Висновки"><h2>Висновки</h2></a>
<p>Концепції власності, позичання, і зрізів - це те, що гарантує безпеку роботи із
пам'яттю в програмах на Rust під час компіляції. Мова Rust надає вам контроль
над використанням пам'яті так само, як і інші системні мови програмування, але
те, що наявність власника даних автоматично призводить до очищення даних, коли
власник виходить з області видимості, означає, що вам не треба писати і відлагоджувати додатковий код, щоб отримати цей контроль.</p>
<p>Власність впливає на те, як працює велика кількість інших частин Rust, тому ми
говоритимемо про ці концепції і надалі у цій книзі. Перейдемо далі до наступного
розділу і поглянемо на групування частинок даних докупи в структури <code>struct</code>.</p>
<a class="header" href="print.html#using-structs-to-structure-related-data" id="using-structs-to-structure-related-data"><h1>Using Structs to Structure Related Data</h1></a>
<a class="header" href="print.html#Визначення-і-інстанціювання-структур-struct" id="Визначення-і-інстанціювання-структур-struct"><h2>Визначення і інстанціювання структур Struct</h2></a>
<p>Структури подібні до кортежів, про які ми говорили в Розділі 3. Як і кортежі,
частини структур можуть бути різних типів. На відміну від кортежів, ми даємо
ім'я кожному елементу даних, щоб було зрозуміло, що ці значення означають.
Завдяки цим іменам структури гнучкіші за кортежі: ми не мусимо покладатися на
порядок даних, щоб визначати чи отримувати доступ до значень екземляра.</p>
<p>Для визначення структури, ми вводимо ключове слово <code>struct</code> і називаємо всю
структуру. Ім'я структури має описувати сенс групування цих елементів даних.
Потім, у фігурних дужках, ми визначаємо імена і типи елементів даних, які
звуться <em>полями</em>. Наприклад, Роздрук 5-1 показує структуру, що зберігає
інформацію про обліковий запис користувача:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
#}</code></pre></pre>
<p><span class="caption">Роздрук 5-1: Визначення структури <code>User</code></span></p>
<p>Щоб скористатися структурою по визначенню, ми створюємо <em>екземляр</em> цієї
структури, визначаючи конкретні значення для кожного поля. Ми створюємо
екземляр, вказуючи ім'я структури, а потім в фігурних дужках додаємо пари <code>ключ: значення</code>, де ключі - це імена полів, а значення - дані, які ми хочемо зберігати
в цих полях. Поля не обов'язково вказувати у тому ж порядку, в якому вони були
проголошені в структурі. Іншими словами, визначення структури - це загальний
шаблон типу, а екземпляри заповнюють цей шаблон конкретними даними, щоб створити
значення цього типу. Наприклад, ми можемо проголосити конкретного користувача,
як показано в Роздруку 5-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
#}</code></pre></pre>
<p><span class="caption">Роздрук 5-2: Створення екземпляру структури <code>User</code></span></p>
<p>Щоб отримати конкретне значення зі стріктури, можна скористатися записом через
точку. Якщо ми хочемо отримати тільки адресу електронної пошти користувача, ми
можемо написати <code>user1.email</code> там, де нам потрібне це значення. Якщо екземпляр є
несталим, ми можемо змінити значення за допомогою запису через точку і
присвоюванням конкретному полю. Роздрук 5-3 показує, як змінити значення поля
<code>email</code> несталого екземпляру <code>User</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from(&quot;anotheremail@example.com&quot;);
#}</code></pre></pre>
<p><span class="caption">Роздрук 5-3: Зміна значення поля <code>email</code> екземпляру <code>User</code>
instance</span></p>
<p>Зверніть увагу, що несталим має бути весь екземпляр; Rust не дозволяє позначати
лише окремі поля як несталі. Також зверніть увагу, що, як і з будь-яким виразом,
ми можемо написати новий екземпляр останнім виразом у тілі функції, щоб неявно
повернути цей новий екземпляр.</p>
<p>Роздрук 5-4 демонструє функцію <code>build_user</code>, що повертає екземпляр <code>User</code> зі
встановленими адресою і ім'ям. Поле <code>active</code> отримує значення <code>true</code>, а
<code>sign_in_count</code> - значення <code>1</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">Роздрук 5-4: Функція <code>build_user</code>, що приймає адресу і
ім'я і повертає екземпляр <code>User</code></span></p>
<p>Має сенс називати аргументи такої функції тими ж іменами, що й імена відповідних
полів стурктури, але необхідність повторювати імена полів <code>email</code> та <code>username</code>
утомлює. Якщо у структури більше полів, повторення кожного імені дратує ще
більшу. На щастя, є зручне скорочення!</p>
<a class="header" href="print.html#Використання-скорочення-ініціалізації-полів-коли-змінні-і-поля-однаково" id="Використання-скорочення-ініціалізації-полів-коли-змінні-і-поля-однаково"><h3>Використання скорочення ініціалізації полів, коли змінні і поля однаково</h3></a>
<a class="header" href="print.html#звуться" id="звуться"><h3>звуться</h3></a>
<p>Оскільки імена параметрів і полів структури повністю збігаються в Родруку 5-4,
ми можемо скористатися синтаксисом <em>скорочення ініціалізації полів</em> і переписати
<code>build_user</code>, щоб вона робила абсолютно те саме, але без повторень <code>email</code> та
<code>username</code>, як показано в Роздруку 5-5.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">Роздрук 5-5: Функція <code>build_user</code>, що використовує
скорочення ініціалізації полів, оскільки параметри <code>email</code> та <code>username</code> мають
ті ж назви, що й поля структури</span></p>
<p>Ми створюємо новий екземпляр структури <code>User</code>, яка має поле з назовою <code>email</code>.
Ми хочемо встановити значення поля <code>email</code> у значення параметру <code>email</code> функції
<code>build_user</code>. Оскільки поле <code>email</code> і параметри <code>email</code> мають одну назву, можна
писати скорочено <code>email</code> замість <code>email: email</code>.</p>
<a class="header" href="print.html#Створення-екземплярів-з-інших-екземплярів-за-допомогою-синтасису-оновлення" id="Створення-екземплярів-з-інших-екземплярів-за-допомогою-синтасису-оновлення"><h3>Створення екземплярів з інших екземплярів за допомогою синтасису оновлення</h3></a>
<a class="header" href="print.html#структури" id="структури"><h3>структури</h3></a>
<p>Часто буває корисним створити новий екземпляр структури, що бере більшу частину
даних з екземпляру, що вже існує, проте деякі змінює. Це робить за допомогою
<em>синтаксису оновлення структури</em>.</p>
<p>Для початку, Роздрук 5-6 показує, як створити новий езкемпляр <code>User</code>, що зветься
<code>user2</code>, без синтаксису оновлення. Ми виставляємо нові значення полів <code>email</code> та
<code>username</code>, проте решта використовує значення зі структури <code>user</code>, створеної у
Роздруку 5-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
#}</code></pre></pre>
<p><span class="caption">Роздрук 5-6: Створення нового екземпляру <code>User</code> з деякими
значеннями з <code>user1</code></span></p>
<p>Синтаксис оновлення структури дає той самий результат із меншою кількістю коду,
як показано у Роздруку 5-7. Запис <code>..</code> позначає, що решта полів, що їх не було
явно виставлено, отримають ті значення, що були в заданому екземплярі.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
#}</code></pre></pre>
<p><span class="caption">Роздрук 5-7: Використання синтаксису оновлення структури
для задання нових значень <code>email</code> та <code>username</code> екземпляру структури <code>User</code>,
решту значень полів взято зі змінної <code>user1</code></span></p>
<p>Код у Роздруку 5-7 також створює екземпляр <code>user2</code>, що має відмінні значення
<code>email</code> та <code>username</code>, але має ті ж значення <code>active</code> та <code>sign_in_count</code>, що й
<code>user1</code>.</p>
<a class="header" href="print.html#Структури-кортежі-без-іменованих-полів-для-створення-різних-типів" id="Структури-кортежі-без-іменованих-полів-для-створення-різних-типів"><h3>Структури-кортежі без іменованих полів для створення різних типів</h3></a>
<p>Ми також можемо визначати структури, які виглядають схожими на кортежі, що
звуться <em>структури-кортежі</em> (<em>tuple struct</em>). Вони надають значення структурі,
бо мають назву, але не мають назв полів, тільки типи. Структури-кортежі корисні,
коли ви хочете дати кортежу ім'я і зробити кортеж окремим типом, але називати
кожне поле, як у звичайній структурі, буде надто багатослівним чи надмірним.</p>
<p>Щоб визначити структуру-кортеж, треба вказати ключове слово <code>struct</code> і ім'я
структури, а потім типи в кортежі. Наприклад, ось визначення і приклади
застосування двох структур-кортежів, що звуться <code>Color</code>(колір) і <code>Point</code>(точка):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
#}</code></pre></pre>
<p>Зауважте, що значення <code>black</code> та <code>origin</code> мають різні типи, бо вони є
екземплярами різних структур-кортежів. Кожна визначена нами структура має свій
власний тип, навіть якщо поля структур мають однакові типи. Наприклад, функція,
що приймає параметр типу <code>Color</code>, не може прийняти аргументом <code>Point</code>, хоча
обидва типи складаються з трьох значень <code>i32</code>. В іншому ж структури-кортежі
поводяться як кортежі, про які ми говорили в Розділі 3: ви можете
деструктуризувати їх на окремі шматки, ви можете використовувати <code>.</code> з індексом,
щоб отримати доступ до окремого значення і так далі.</p>
<a class="header" href="print.html#Одинично-подібні-структури-без-полів" id="Одинично-подібні-структури-без-полів"><h3>Одинично-подібні структури без полів</h3></a>
<p>Також можна визначати структури без жодних полів! Вони звуться <em>одинично-подібні
структури</em> (<em>unit-like struct</em>), бо поводяться аналогічно до <code>()</code>, одничного
типу. Одинично-подібні структури можуть бути корисними в ситуаціях, коли вам
потрібно втілити рису до якогось типу, але у вас немає потреби зберігати якісь
дані. Риси будуть обговорюватися в Розділі 10.</p>
<blockquote>
<a class="header" href="print.html#Володіння-даними-структури" id="Володіння-даними-структури"><h3>Володіння даними структури</h3></a>
<p>В структурі <code>User</code> з Роздруку 5-1 ми використовували тип <code>String</code>, що має
володіння, а не стрічковий зріз <code>&amp;str</code>. Це свідомий вибір, бо ми хочемо, щоб
екземпляри цієї структури володіли всіма даними і щоб ці дані були коректні
весь час існування структури в цілому.</p>
<p>Структура також може зберігати посилання на дані, якими володіє хтось інший,
але це потребує використання <em>часу життя</em>, особливості Rust, що обговорюється
у Розділі 10. Час життя гарантує, що дані, на які посилається структура,
будуть коректними весь час існування структури. Наприклад, якщо ви спробуєте
зберегти посилання у структурі без уточнення часу життя, ось так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>Компілятор повідомить, що йому потрібно вказати час життя:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>Ми обговоримо, як це виправити, щоб можна було зберігати посилання у
структурах, у Розділі 10, а поки що, будемо виправляти подібні помилки за
допомогою типів, що володіють своїми даними, на кшталт <code>String</code>, замість
посилань на кшталт <code>&amp;str</code>.</p>
</blockquote>
<a class="header" href="print.html#an-example-program-using-structs" id="an-example-program-using-structs"><h2>An Example Program Using Structs</h2></a>
<p>To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start with single variables, and then
refactor the program until we’re using structs instead.</p>
<p>Let’s make a new binary project with Cargo called <em>rectangles</em> that will take
the width and height of a rectangle specified in pixels and will calculate the
area of the rectangle. Listing 5-8 shows a short program with one way of doing
just that in our project’s <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Listing 5-8: Calculating the area of a rectangle
specified by its width and height in separate variables</span></p>
<p>Now, run this program using <code>cargo run</code>:</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
</code></pre>
<a class="header" href="print.html#refactoring-with-tuples" id="refactoring-with-tuples"><h3>Refactoring with Tuples</h3></a>
<p>Even though Listing 5-8 works and figures out the area of the rectangle by
calling the <code>area</code> function with each dimension, we can do better. The width
and the height are related to each other because together they describe one
rectangle.</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<pre><code class="language-rust ignore">fn area(width: u32, height: u32) -&gt; u32 {
</code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters. The parameters are related, but that’s
not expressed anywhere in our program. It would be more readable and more
manageable to group width and height together. We’ve already discussed one way
we might do that in the “Grouping Values into Tuples” section of Chapter 3: by
using tuples. Listing 5-9 shows another version of our program that uses tuples:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Listing 5-9: Specifying the width and height of the
rectangle with a tuple</span></p>
<p>In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way this version is less
clear: tuples don’t name their elements, so our calculation has become more
confusing because we have to index into the parts of the tuple.</p>
<p>It doesn’t matter if we mix up width and height for the area calculation, but
if we want to draw the rectangle on the screen, it would matter! We would have
to keep in mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple
index <code>1</code>. If someone else worked on this code, they would have to figure this
out and keep it in mind as well. It would be easy to forget or mix up these
values and cause errors, because we haven’t conveyed the meaning of our data in
our code.</p>
<a class="header" href="print.html#refactoring-with-structs-adding-more-meaning" id="refactoring-with-structs-adding-more-meaning"><h3>Refactoring with Structs: Adding More Meaning</h3></a>
<p>We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a data type with a name for the whole as well as names for the
parts, as shown in Listing 5-10:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Listing 5-10: Defining a <code>Rectangle</code> struct</span></p>
<p>Here we’ve defined a struct and named it <code>Rectangle</code>. Inside the <code>{}</code> we
defined the fields as <code>width</code> and <code>height</code>, both of which have type <code>u32</code>. Then
in <code>main</code> we create a particular instance of a <code>Rectangle</code> that has a width of
30 and a height of 50.</p>
<p>Our <code>area</code> function is now defined with one parameter, which we’ve named
<code>rectangle</code>, whose type is an immutable borrow of a struct <code>Rectangle</code>
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, <code>main</code> retains its ownership and can continue
using <code>rect1</code>, which is the reason we use the <code>&amp;</code> in the function signature and
where we call the function.</p>
<p>The <code>area</code> function accesses the <code>width</code> and <code>height</code> fields of the <code>Rectangle</code>
instance. Our function signature for <code>area</code> now says exactly what we mean:
calculate the area of a <code>Rectangle</code>, using its <code>width</code> and <code>height</code> fields.
This conveys that the width and height are related to each other, and gives
descriptive names to the values rather than using the tuple index values of <code>0</code>
and <code>1</code>. This is a win for clarity.</p>
<a class="header" href="print.html#adding-useful-functionality-with-derived-traits" id="adding-useful-functionality-with-derived-traits"><h3>Adding Useful Functionality with Derived Traits</h3></a>
<p>It’d be nice to be able to print out an instance of our <code>Rectangle</code> while we’re
debugging our program and see the values for all its fields. Listing 5-11 tries
the <code>println!</code> macro as we have used it in Chapters 2, 3, and 4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Listing 5-11: Attempting to print a <code>Rectangle</code>
instance</span></p>
<p>When we run this code, we get an error with this core message:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
</code></pre>
<p>The <code>println!</code> macro can do many kinds of formatting, and by default, <code>{}</code>
tells <code>println!</code> to use formatting known as <code>Display</code>: output intended for
direct end user consumption. The primitive types we’ve seen so far implement
<code>Display</code> by default, because there’s only one way you’d want to show a <code>1</code> or
any other primitive type to a user. But with structs, the way <code>println!</code> should
format the output is less clear because there are more display possibilities:
do you want commas or not? Do you want to print the curly brackets? Should all
the fields be shown? Due to this ambiguity, Rust doesn’t try to guess what we
want and structs don’t have a provided implementation of <code>Display</code>.</p>
<p>If we continue reading the errors, we’ll find this helpful note:</p>
<pre><code class="language-text">`Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
</code></pre>
<p>Let’s try it! The <code>println!</code> macro call will now look like <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>. Putting the specifier <code>:?</code> inside the <code>{}</code> tells <code>println!</code> we
want to use an output format called <code>Debug</code>. <code>Debug</code> is a trait that enables us
to print out our struct in a way that is useful for developers so we can see
its value while we’re debugging our code.</p>
<p>Run the code with this change. Drat! We still get an error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
</code></pre>
<p>But again, the compiler gives us a helpful note:</p>
<pre><code class="language-text">`Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
</code></pre>
<p>Rust <em>does</em> include functionality to print out debugging information, but we
have to explicitly opt-in to make that functionality available for our struct.
To do that, we add the annotation <code>#[derive(Debug)]</code> just before the struct
definition, as shown in Listing 5-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Listing 5-12: Adding the annotation to derive the <code>Debug</code>
trait and printing the <code>Rectangle</code> instance using debug formatting</span></p>
<p>Now when we run the program, we won’t get any errors and we’ll see the
following output:</p>
<pre><code class="language-text">rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use <code>{:#?}</code> instead of <code>{:?}</code> in the <code>println!</code> string.
When we use the <code>{:#?}</code> style in the example, the output will look like this:</p>
<pre><code class="language-text">rect1 is Rectangle {
    width: 30,
    height: 50
}
</code></pre>
<p>Rust has provided a number of traits for us to use with the <code>derive</code> annotation
that can add useful behavior to our custom types. Those traits and their
behaviors are listed in Appendix C. We’ll cover how to implement these traits
with custom behavior as well as how to create your own traits in Chapter 10.</p>
<p>Our <code>area</code> function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our <code>Rectangle</code>
struct, because it won’t work with any other type. Let’s look at how we can
continue to refactor this code by turning the <code>area</code> function into an <code>area</code>
<em>method</em> defined on our <code>Rectangle</code> type.</p>
<a class="header" href="print.html#method-syntax" id="method-syntax"><h2>Method Syntax</h2></a>
<p><em>Methods</em> are similar to functions: they’re declared with the <code>fn</code> keyword and
their name, they can have parameters and a return value, and they contain some
code that is run when they’re called from somewhere else. However, methods are
different from functions in that they’re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always <code>self</code>, which represents the
instance of the struct the method is being called on.</p>
<a class="header" href="print.html#defining-methods" id="defining-methods"><h3>Defining Methods</h3></a>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown
in Listing 5-13:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Listing 5-13: Defining an <code>area</code> method on the
<code>Rectangle</code> struct</span></p>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(<em>implementation</em>) block. Then we move the <code>area</code> function within the <code>impl</code>
curly brackets and change the first (and in this case, only) parameter to be
<code>self</code> in the signature and everywhere within the body. In <code>main</code> where we
called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead
use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code> instance.
The method syntax goes after an instance: we add a dot followed by the method
name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code>
because Rust knows the type of <code>self</code> is <code>Rectangle</code> due to this method being
inside the <code>impl Rectangle</code> context. Note that we still need to use the <code>&amp;</code>
before <code>self</code>, just like we did in <code>&amp;Rectangle</code>. Methods can take ownership of
<code>self</code>, borrow <code>self</code> immutably as we’ve done here, or borrow <code>self</code> mutably,
just like any other parameter.</p>
<p>We’ve chosen <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the
function version: we don’t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we’ve called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as the first parameter. Having a method that takes ownership of the
instance by using just <code>self</code> as the first parameter is rare; this technique is
usually used when the method transforms <code>self</code> into something else and we want
to prevent the caller from using the original instance after the transformation.</p>
<p>The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of <code>self</code> in every method’s
signature, is for organization. We’ve put all the things we can do with an
instance of a type in one <code>impl</code> block rather than making future users of our
code search for capabilities of <code>Rectangle</code> in various places in the library we
provide.</p>
<blockquote>
<a class="header" href="print.html#wheres-the---operator" id="wheres-the---operator"><h3>Where’s the <code>-&gt;</code> Operator?</h3></a>
<p>In languages like C++, two different operators are used for calling methods:
you use <code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if
you’re calling the method on a pointer to the object and need to dereference
the pointer first. In other words, if <code>object</code> is a pointer,
<code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>Rust doesn’t have an equivalent to the <code>-&gt;</code> operator; instead, Rust has a
feature called <em>automatic referencing and dereferencing</em>. Calling methods is
one of the few places in Rust that has this behavior.</p>
<p>Here’s how it works: when you call a method with <code>object.something()</code>, Rust
automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of
the method. In other words, the following are the same:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug,Copy,Clone)]
# struct Point {
#     x: f64,
#     y: f64,
# }
#
# impl Point {
#    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
#        let x_squared = f64::powi(other.x - self.x, 2);
#        let y_squared = f64::powi(other.y - self.y, 2);
#
#        f64::sqrt(x_squared + y_squared)
#    }
# }
# let p1 = Point { x: 0.0, y: 0.0 };
# let p2 = Point { x: 5.0, y: 6.5 };
p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
#}</code></pre></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of <code>self</code>. Given the receiver
and name of a method, Rust can figure out definitively whether the method is
reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact
that Rust makes borrowing implicit for method receivers is a big part of
making ownership ergonomic in practice.</p>
</blockquote>
<a class="header" href="print.html#methods-with-more-parameters" id="methods-with-more-parameters"><h3>Methods with More Parameters</h3></a>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time, we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code>; otherwise it should return <code>false</code>. That is, we want to be able
to write the program shown in Listing 5-14, once we’ve defined the <code>can_hold</code>
method:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Listing 5-14: Demonstration of using the as-yet-unwritten
<code>can_hold</code> method</span></p>
<p>And the expected output would look like the following, because both dimensions
of <code>rect2</code> are smaller than the dimensions of <code>rect1</code>, but <code>rect3</code> is wider
than <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code>
block. The method name will be <code>can_hold</code>, and it will take an immutable borrow
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable borrow to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
Boolean, and the implementation will check whether the width and height of
<code>self</code> are both greater than the width and height of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>impl</code> block from
Listing 5-13, shown in Listing 5-15:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 5-15: Implementing the <code>can_hold</code> method on
<code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></p>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<a class="header" href="print.html#associated-functions" id="associated-functions"><h3>Associated Functions</h3></a>
<p>Another useful feature of <code>impl</code> blocks is that we’re allowed to define
functions within <code>impl</code> blocks that <em>don’t</em> take <code>self</code> as a parameter. These
are called <em>associated functions</em> because they’re associated with the struct.
They’re still functions, not methods, because they don’t have an instance of
the struct to work with. You’ve already used the <code>String::from</code> associated
function.</p>
<p>Associated functions are often used for constructors that will return a new
instance of the struct. For example, we could provide an associated function
that would have one dimension parameter and use that as both width and height,
thus making it easier to create a square <code>Rectangle</code> rather than having to
specify the same value twice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
#}</code></pre></pre>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name,
like <code>let sq = Rectangle::square(3);</code>, for example. This function is
namespaced by the struct: the <code>::</code> syntax is used for both associated functions
and namespaces created by modules, which we’ll discuss in Chapter 7.</p>
<a class="header" href="print.html#multiple-impl-blocks" id="multiple-impl-blocks"><h3>Multiple <code>impl</code> Blocks</h3></a>
<p>Each struct is allowed to have multiple <code>impl</code> blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own <code>impl</code> block:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code>
blocks</span></p>
<p>There’s no reason to separate these methods into multiple <code>impl</code> blocks here,
but it’s valid syntax. We will see a case when multiple <code>impl</code> blocks are useful
in Chapter 10 when we discuss generic types and traits.</p>
<a class="header" href="print.html#summary" id="summary"><h2>Summary</h2></a>
<p>Structs let us create custom types that are meaningful for our domain. By using
structs, we can keep associated pieces of data connected to each other and name
each piece to make our code clear. Methods let us specify the behavior that
instances of our structs have, and associated functions let us namespace
functionality that is particular to our struct without having an instance
available.</p>
<p>But structs aren’t the only way we can create custom types: let’s turn to
Rust’s enum feature to add another tool to our toolbox.</p>
<a class="header" href="print.html#enums-and-pattern-matching" id="enums-and-pattern-matching"><h1>Enums and Pattern Matching</h1></a>
<p>In this chapter we’ll look at <em>enumerations</em>, also referred to as <em>enums</em>.
Enums allow you to define a type by enumerating its possible values. First,
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called <code>Option</code>, which
expresses that a value can be either something or nothing. Then we’ll look at
how pattern matching in the <code>match</code> expression makes it easy to run different
code for different values of an enum. Finally, we’ll cover how the <code>if let</code>
construct is another convenient and concise idiom available to you to handle
enums in your code.</p>
<p>Enums are a feature in many languages, but their capabilities differ in each
language. Rust’s enums are most similar to <em>algebraic data types</em> in functional
languages like F#, OCaml, and Haskell.</p>
<a class="header" href="print.html#defining-an-enum" id="defining-an-enum"><h2>Defining an Enum</h2></a>
<p>Let’s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. These are the only possibilities for an IP
address that our program will come across: we can <em>enumerate</em> all possible
values, which is where enumeration gets its name.</p>
<p>Any IP address can be either a version four or a version six address but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate for this case, because enum values can only be one of the
variants. Both version four and version six addresses are still fundamentally
IP addresses, so they should be treated as the same type when the code is
handling situations that apply to any kind of IP address.</p>
<p>We can express this concept in code by defining an <code>IpAddrKind</code> enumeration and
listing the possible kinds an IP address can be, <code>V4</code> and <code>V6</code>. These are known
as the <em>variants</em> of the enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</p>
<a class="header" href="print.html#enum-values" id="enum-values"><h3>Enum Values</h3></a>
<p>We can create instances of each of the two variants of <code>IpAddrKind</code> like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#}</code></pre></pre>
<p>Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. The reason this is useful is that now
both values <code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> are of the same type:
<code>IpAddrKind</code>. We can then, for instance, define a function that takes any
<code>IpAddrKind</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
fn route(ip_type: IpAddrKind) { }
#}</code></pre></pre>
<p>And we can call this function with either variant:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_type: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
#}</code></pre></pre>
<p>Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don’t have a way to store the actual IP address <em>data</em>; we
only know what <em>kind</em> it is. Given that you just learned about structs in
Chapter 5, you might tackle this problem as shown in Listing 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listing 6-1: Storing the data and <code>IpAddrKind</code> variant of
an IP address using a <code>struct</code></span></p>
<p>Here, we’ve defined a struct <code>IpAddr</code> that has two fields: a <code>kind</code> field that
is of type <code>IpAddrKind</code> (the enum we defined previously) and an <code>address</code> field
of type <code>String</code>. We have two instances of this struct. The first, <code>home</code>, has
the value <code>IpAddrKind::V4</code> as its <code>kind</code> with associated address data of
<code>127.0.0.1</code>. The second instance, <code>loopback</code>, has the other variant of
<code>IpAddrKind</code> as its <code>kind</code> value, <code>V6</code>, and has address <code>::1</code> associated with
it. We’ve used a struct to bundle the <code>kind</code> and <code>address</code> values together, so
now the variant is associated with the value.</p>
<p>We can represent the same concept in a more concise way using just an enum,
rather than an enum inside a struct, by putting data directly into each enum
variant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code>
variants will have associated <code>String</code> values:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>We attach data to each variant of the enum directly, so there is no need for an
extra struct.</p>
<p>There’s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but
still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with
a struct. Enums handle this case with ease:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>We’ve shown several different possibilities that we could define in our code
for storing IP addresses of the two different varieties using an enum. However,
as it turns out, wanting to store IP addresses and encode which kind they are
is so common that <a href="../../std/net/enum.IpAddr.html">the standard library has a definition we can
use!</a><!-- ignore --> Let’s look at how the standard library defines
<code>IpAddr</code>: it has the exact enum and variants that we’ve defined and used, but
it embeds the address data inside the variants in the form of two different
structs, which are defined differently for each variant:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // details elided
}

struct Ipv6Addr {
    // details elided
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.</p>
<p>Note that even though the standard library contains a definition for <code>IpAddr</code>,
we can still create and use our own definition without conflict because we
haven’t brought the standard library’s definition into our scope. We’ll talk
more about bringing types into scope in Chapter 7.</p>
<p>Let’s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-2: A <code>Message</code> enum whose variants each store
different amounts and types of values</span></p>
<p>This enum has four variants with different types:</p>
<ul>
<li><code>Quit</code> has no data associated with it at all.</li>
<li><code>Move</code> includes an anonymous struct inside it.</li>
<li><code>Write</code> includes a single <code>String</code>.</li>
<li><code>ChangeColor</code> includes three <code>i32</code> values.</li>
</ul>
<p>Defining an enum with variants like the ones in Listing 6-2 is similar to
defining different kinds of struct definitions except the enum doesn’t use the
<code>struct</code> keyword and all the variants are grouped together under the <code>Message</code>
type. The following structs could hold the same data that the preceding enum
variants hold:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>But if we used the different structs, which each have their own type, we
wouldn’t be able to as easily define a function that could take any of these
kinds of messages as we could with the <code>Message</code> enum defined in Listing 6-2,
which is a single type.</p>
<p>There is one more similarity between enums and structs: just as we’re able to
define methods on structs using <code>impl</code>, we’re also able to define methods on
enums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Quit,
#     Move { x: i32, y: i32 },
#     Write(String),
#     ChangeColor(i32, i32, i32),
# }
#
impl Message {
    fn call(&amp;self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
#}</code></pre></pre>
<p>The body of the method would use <code>self</code> to get the value that we called the
method on. In this example, we’ve created a variable <code>m</code> that has the value
<code>Message::Write(String::from(&quot;hello&quot;))</code>, and that is what <code>self</code> will be in the body of the
<code>call</code> method when <code>m.call()</code> runs.</p>
<p>Let’s look at another enum in the standard library that is very common and
useful: <code>Option</code>.</p>
<a class="header" href="print.html#the-option-enum-and-its-advantages-over-null-values" id="the-option-enum-and-its-advantages-over-null-values"><h3>The <code>Option</code> Enum and Its Advantages Over Null Values</h3></a>
<p>In the previous section, we looked at how the <code>IpAddr</code> enum let us use Rust’s
type system to encode more information than just the data into our program.
This section explores a case study of <code>Option</code>, which is another enum defined
by the standard library. The <code>Option</code> type is used in many places because it
encodes the very common scenario in which a value could be something or it
could be nothing. Expressing this concept in terms of the type system means the
compiler can check that you’ve handled all the cases you should be handling,
which can prevent bugs that are extremely common in other programming languages.</p>
<p>Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn’t have the
null feature that many other languages have. <em>Null</em> is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.</p>
<p>In “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of
null, has this to say:</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My
goal was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in
the last forty years.</p>
</blockquote>
<p>The problem with null values is that if you try to actually use a value that’s
null as if it is a not-null value, you’ll get an error of some kind. Because
this null or not-null property is pervasive, it’s extremely easy to make this
kind of error.</p>
<p>However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.</p>
<p>The problem isn’t with the actual concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
<code>Option&lt;T&gt;</code>, and it is <a href="../../std/option/enum.Option.html">defined by the standard library</a><!-- ignore -->
as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you
don’t need to bring it into scope explicitly. In addition, so are its variants:
you can use <code>Some</code> and <code>None</code> directly without prefixing them with <code>Option::</code>.
<code>Option&lt;T&gt;</code> is still just a regular enum, and <code>Some(T)</code> and <code>None</code> are still
variants of type <code>Option&lt;T&gt;</code>.</p>
<p>The <code>&lt;T&gt;</code> syntax is a feature of Rust we haven’t talked about yet. It’s a
generic type parameter, and we’ll cover generics in more detail in Chapter 10.
For now, all you need to know is that <code>&lt;T&gt;</code> means the <code>Some</code> variant of the
<code>Option</code> enum can hold one piece of data of any type. Here are some examples of
using <code>Option</code> values to hold number types and string types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>If we use <code>None</code> rather than <code>Some</code>, we need to tell Rust what type of
<code>Option&lt;T&gt;</code> we have, because the compiler can’t infer the type that the <code>Some</code>
variant will hold by looking only at a <code>None</code> value.</p>
<p>When we have a <code>Some</code> value, we know that a value is present, and the value is
held within the <code>Some</code>. When we have a <code>None</code> value, in some sense, it means
the same thing as null: we don’t have a valid value. So why is having
<code>Option&lt;T&gt;</code> any better than having null?</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different
types, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it was
definitely a valid value. For example, this code won’t compile because it’s
trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>If we run this code, we get an error message like this:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intense! In effect, this error message means that Rust doesn’t understand how
to add an <code>i8</code> and an <code>Option&lt;i8&gt;</code>, because they’re different types. When we
have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an <code>Option&lt;i8&gt;</code> (or
whatever type of value we’re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.</p>
<p>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can
perform <code>T</code> operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn’t null when it actually
is.</p>
<p>Not having to worry about missing an assumption of having a not-null value
helps you to be more confident in your code. In order to have a value that can
possibly be null, you must explicitly opt in by making the type of that value
<code>Option&lt;T&gt;</code>. Then, when you use that value, you are required to explicitly
handle the case when the value is null. Everywhere that a value has a type that
isn’t an <code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This
was a deliberate design decision for Rust to limit null’s pervasiveness and
increase the safety of Rust code.</p>
<p>So, how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value
of type <code>Option&lt;T&gt;</code> so you can use that value? The <code>Option&lt;T&gt;</code> enum has a large
number of methods that are useful in a variety of situations; you can check
them out in <a href="../../std/option/enum.Option.html">its documentation</a><!-- ignore -->. Becoming familiar with
the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with Rust.</p>
<p>In general, in order to use an <code>Option&lt;T&gt;</code> value, we want to have code that
will handle each variant. We want some code that will run only when we have a
<code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. We want some
other code to run if we have a <code>None</code> value, and that code doesn’t have a <code>T</code>
value available. The <code>match</code> expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.</p>
<a class="header" href="print.html#the-match-control-flow-operator" id="the-match-control-flow-operator"><h2>The <code>match</code> Control Flow Operator</h2></a>
<p>Rust has an extremely powerful control-flow operator called <code>match</code> that allows
us to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of <code>match</code> comes from the
expressiveness of the patterns and the compiler checks that all
possible cases are handled.</p>
<p>Think of a <code>match</code> expression kind of like a coin sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a <code>match</code>, and at the first pattern the value “fits,”
the value will fall into the associated code block to be used during execution.</p>
<p>Because we just mentioned coins, let’s use them as an example using <code>match</code>! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-3: An enum and a <code>match</code> expression that has
the variants of the enum as its patterns.</span></p>
<p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First, we list
the <code>match</code> keyword followed by an expression, which in this case is the value
<code>coin</code>. This seems very similar to an expression used with <code>if</code>, but there’s a
big difference: with <code>if</code>, the expression needs to return a Boolean value.
Here, it can be any type. The type of <code>coin</code> in this example is the <code>Coin</code> enum
that we defined in Listing 6-3.</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code>
operator that separates the pattern and the code to run. The code in this case
is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p>When the <code>match</code> expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much like a coin sorting machine.
We can have as many arms as we need: in Listing 6-3, our <code>match</code> has four arms.</p>
<p>The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire <code>match</code> expression.</p>
<p>Curly brackets typically aren’t used if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly brackets. For example, the
following code would print out “Lucky penny!” every time the method was called
with a <code>Coin::Penny</code> but would still return the last value of the block, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#patterns-that-bind-to-values" id="patterns-that-bind-to-values"><h3>Patterns that Bind to Values</h3></a>
<p>Another useful feature of match arms is that they can bind to parts of the
values that match the pattern. This is how we can extract values out of enum
variants.</p>
<p>As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our <code>enum</code> by changing the <code>Quarter</code> variant to include a <code>UsState</code> value stored
inside it, which we’ve done here in Listing 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-4: A <code>Coin</code> enum where the <code>Quarter</code> variant
also holds a <code>UsState</code> value</span></p>
<p>Let’s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we’ll also call out the name of
the state associated with each quarter so if it’s one our friend doesn’t have,
they can add it to their collection.</p>
<p>In the match expression for this code, we add a variable called <code>state</code> to the
pattern that matches values of the variant <code>Coin::Quarter</code>. When a
<code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that
quarter’s state. Then we can use <code>state</code> in the code for that arm, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
#}</code></pre></pre>
<p>If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code>
would be <code>Coin::Quarter(UsState::Alaska)</code>. When we compare that value with each
of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code>. At
that point, the binding for <code>state</code> will be the value <code>UsState::Alaska</code>. We can
then use that binding in the <code>println!</code> expression, thus getting the inner
state value out of the <code>Coin</code> enum variant for <code>Quarter</code>.</p>
<a class="header" href="print.html#matching-with-optiont" id="matching-with-optiont"><h3>Matching with <code>Option&lt;T&gt;</code></h3></a>
<p>In the previous section we wanted to get the inner <code>T</code> value out of the <code>Some</code>
case when using <code>Option&lt;T&gt;</code>; we can also handle <code>Option&lt;T&gt;</code> using <code>match</code> as we
did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the
variants of <code>Option&lt;T&gt;</code>, but the way that the <code>match</code> expression works remains
the same.</p>
<p>Let’s say we want to write a function that takes an <code>Option&lt;i32&gt;</code>, and if
there’s a value inside, adds one to that value. If there isn’t a value inside,
the function should return the <code>None</code> value and not attempt to perform any
operations.</p>
<p>This function is very easy to write, thanks to <code>match</code>, and will look like
Listing 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#}</code></pre></pre>
<p><span class="caption">Listing 6-5: A function that uses a <code>match</code> expression on
an <code>Option&lt;i32&gt;</code></span></p>
<a class="header" href="print.html#matching-somet" id="matching-somet"><h4>Matching <code>Some(T)</code></h4></a>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call
<code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the
value <code>Some(5)</code>. We then compare that against each match arm.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>The <code>Some(5)</code> value doesn’t match the pattern <code>None</code>, so we continue to the
next arm.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>Does <code>Some(5)</code> match <code>Some(i)</code>? Well yes it does! We have the same variant.
The <code>i</code> binds to the value contained in <code>Some</code>, so <code>i</code> takes the value <code>5</code>. The
code in the match arm is then executed, so we add one to the value of <code>i</code> and
create a new <code>Some</code> value with our total <code>6</code> inside.</p>
<a class="header" href="print.html#matching-none" id="matching-none"><h4>Matching <code>None</code></h4></a>
<p>Now let’s consider the second call of <code>plus_one</code> in Listing 6-5 where <code>x</code> is
<code>None</code>. We enter the <code>match</code> and compare to the first arm.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>It matches! There’s no value to add to, so the program stops and returns the
<code>None</code> value on the right side of <code>=&gt;</code>. Because the first arm matched, no other
arms are compared.</p>
<p>Combining <code>match</code> and enums is useful in many situations. You’ll see this
pattern a lot in Rust code: <code>match</code> against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.</p>
<a class="header" href="print.html#matches-are-exhaustive" id="matches-are-exhaustive"><h3>Matches Are Exhaustive</h3></a>
<p>There’s one other aspect of <code>match</code> we need to discuss. Consider this version
of our <code>plus_one</code> function:</p>
<pre><code class="language-rust ignore">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>We didn’t handle the <code>None</code> case, so this code will cause a bug. Luckily, it’s
a bug Rust knows how to catch. If we try to compile this code, we’ll get this
error:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>Rust knows that we didn’t cover every possible case and even knows which
pattern we forgot! Matches in Rust are <em>exhaustive</em>: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
<code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the
<code>None</code> case, it protects us from assuming that we have a value when we might
have null, thus making the billion dollar mistake discussed earlier.</p>
<a class="header" href="print.html#the-_-placeholder" id="the-_-placeholder"><h3>The <code>_</code> Placeholder</h3></a>
<p>Rust also has a pattern we can use in situations when we don’t want to list all
possible values. For example, a <code>u8</code> can have valid values of 0 through 255. If
we only care about the values 1, 3, 5, and 7, we don’t want to have to list out
0, 2, 4, 6, 8, 9 all the way up to 255. Fortunately, we don’t have to: we can
use the special pattern <code>_</code> instead:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>The <code>_</code> pattern will match any value. By putting it after our other arms, the
<code>_</code> will match all the possible cases that aren’t specified before it. The <code>()</code>
is just the unit value, so nothing will happen in the <code>_</code> case. As a result, we
can say that we want to do nothing for all the possible values that we don’t
list before the <code>_</code> placeholder.</p>
<p>However, the <code>match</code> expression can be a bit wordy in a situation in which we
only care about <em>one</em> of the cases. For this situation, Rust provides <code>if let</code>.</p>
<a class="header" href="print.html#concise-control-flow-with-if-let" id="concise-control-flow-with-if-let"><h2>Concise Control Flow with <code>if let</code></h2></a>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to
handle values that match one pattern and ignore the rest. Consider the program
in Listing 6-6 that matches on an <code>Option&lt;u8&gt;</code> value but only wants to execute
code if the value is three:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-6: A <code>match</code> that only cares about executing
code when the value is <code>Some(3)</code></span></p>
<p>We want to do something with the <code>Some(3)</code> match but do nothing with any other
<code>Some&lt;u8&gt;</code> value or the <code>None</code> value. To satisfy the <code>match</code> expression, we
have to add <code>_ =&gt; ()</code> after processing just one variant, which is a lot of
boilerplate code to add.</p>
<p>Instead, we could write this in a shorter way using <code>if let</code>. The following
code behaves the same as the <code>match</code> in Listing 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> takes a pattern and an expression separated by an <code>=</code>. It works the
same way as a <code>match</code>, where the expression is given to the <code>match</code> and the
pattern is its first arm.</p>
<p>Using <code>if let</code> means you have less to type, less indentation, and less
boilerplate code. However, we’ve lost the exhaustive checking that <code>match</code>
enforces. Choosing between <code>match</code> and <code>if let</code> depends on what you’re doing in
your particular situation and if gaining conciseness is an appropriate
trade-off for losing exhaustive checking.</p>
<p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that
runs code when the value matches one pattern and then ignores all other values.</p>
<p>We can include an <code>else</code> with an <code>if let</code>. The block of code that goes with the
<code>else</code> is the same as the block of code that would go with the <code>_</code> case in the
<code>match</code> expression that is equivalent to the <code>if let</code> and <code>else</code>. Recall the
<code>Coin</code> enum definition in Listing 6-4, where the <code>Quarter</code> variant also held a
<code>UsState</code> value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a <code>match</code>
expression like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
#}</code></pre></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
#}</code></pre></pre>
<p>If you have a situation in which your program has logic that is too verbose to
express using a <code>match</code>, remember that <code>if let</code> is in your Rust toolbox as well.</p>
<a class="header" href="print.html#summary-1" id="summary-1"><h2>Summary</h2></a>
<p>We’ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We’ve shown how the standard library’s <code>Option&lt;T&gt;</code>
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use <code>match</code> or <code>if let</code> to extract and use those
values, depending on how many cases you need to handle.</p>
<p>Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions only get values of the type each
function expects.</p>
<p>In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let’s now turn to
Rust’s modules.</p>
<a class="header" href="print.html#using-modules-to-reuse-and-organize-code" id="using-modules-to-reuse-and-organize-code"><h1>Using Modules to Reuse and Organize Code</h1></a>
<p>When you start writing programs in Rust, your code might live solely in the
<code>main</code> function. As your code grows, you’ll eventually move functionality into
other functions for reuse and better organization. By splitting your code into
smaller chunks, each chunk is easier to understand on its own. But what happens
if you have too many functions? Rust has a module system that enables the reuse
of code in an organized fashion.</p>
<p>In the same way that you extract lines of code into a function, you can extract
functions (and other code, like structs and enums) into different modules. A
<em>module</em> is a namespace that contains definitions of functions or types, and
you can choose whether those definitions are visible outside their module
(public) or not (private). Here’s an overview of how modules work:</p>
<ul>
<li>The <code>mod</code> keyword declares a new module. Code within the module appears
either immediately following this declaration within curly brackets or in
another file.</li>
<li>By default, functions, types, constants, and modules are private. The <code>pub</code>
keyword makes an item public and therefore visible outside its namespace.</li>
<li>The <code>use</code> keyword brings modules, or the definitions inside modules, into
scope so it’s easier to refer to them.</li>
</ul>
<p>We’ll look at each of these parts to see how they fit into the whole.</p>
<a class="header" href="print.html#mod-and-the-filesystem" id="mod-and-the-filesystem"><h2><code>mod</code> and the Filesystem</h2></a>
<p>We’ll start our module example by making a new project with Cargo, but instead
of creating a binary crate, we’ll make a library crate: a project that other
people can pull into their projects as a dependency. For example, the <code>rand</code>
crate discussed in Chapter 2 is a library crate that we used as a dependency in
the guessing game project.</p>
<p>We’ll create a skeleton of a library that provides some general networking
functionality; we’ll concentrate on the organization of the modules and
functions but we won’t worry about what code goes in the function bodies. We’ll
call our library <code>communicator</code>. By default, Cargo will create a library unless
another type of project is specified: if we omit the <code>--bin</code> option that we’ve
been using in all of the chapters preceding this one, our project will be a
library:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Notice that Cargo generated <em>src/lib.rs</em> instead of <em>src/main.rs</em>. Inside
<em>src/lib.rs</em> we’ll find the following:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo creates an example test to help us get our library started, rather than
the “Hello, world!” binary that we get when we use the <code>--bin</code> option. We’ll
look at the <code>#[]</code> and <code>mod tests</code> syntax in the “Using <code>super</code> to Access a
Parent Module” section later in this chapter, but for now, leave this code at
the bottom of <em>src/lib.rs</em>.</p>
<p>Because we don’t have a <em>src/main.rs</em> file, there’s nothing for Cargo to
execute with the <code>cargo run</code> command. Therefore, we’ll use the <code>cargo build</code>
command to compile our library crate’s code.</p>
<p>We’ll look at different options for organizing your library’s code that will be
suitable in a variety of situations, depending on the intent of the code.</p>
<a class="header" href="print.html#module-definitions" id="module-definitions"><h3>Module Definitions</h3></a>
<p>For our <code>communicator</code> networking library, we’ll first define a module named
<code>network</code> that contains the definition of a function called <code>connect</code>. Every
module definition in Rust starts with the <code>mod</code> keyword. Add this code to the
beginning of the <em>src/lib.rs</em> file, above the test code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>After the <code>mod</code> keyword, we put the name of the module, <code>network</code>, and then a
block of code in curly brackets. Everything inside this block is inside the
namespace <code>network</code>. In this case, we have a single function, <code>connect</code>. If we
wanted to call this function from code outside the <code>network</code> module, we
would need to specify the module and use the namespace syntax <code>::</code>, like so:
<code>network::connect()</code> rather than just <code>connect()</code>.</p>
<p>We can also have multiple modules, side by side, in the same <em>src/lib.rs</em> file.
For example, to also have a <code>client</code> module that has a function named <code>connect</code>
as well, we can add it as shown in Listing 7-1:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-1: The <code>network</code> module and the <code>client</code> module
defined side by side in <em>src/lib.rs</em></span></p>
<p>Now we have a <code>network::connect</code> function and a <code>client::connect</code> function.
These can have completely different functionality, and the function names do
not conflict with each other because they’re in different modules.</p>
<p>In this case, because we’re building a library, the file that serves as the
entry point for building our library is <em>src/lib.rs</em>. However, in respect to
creating modules, there’s nothing special about <em>src/lib.rs</em>. We could also
create modules in <em>src/main.rs</em> for a binary crate in the same way as we’re
creating modules in <em>src/lib.rs</em> for the library crate. In fact, we can put
modules inside of modules, which can be useful as your modules grow to keep
related functionality organized together and separate functionality apart. The
choice of how you organize your code depends on how you think about the
relationship between the parts of your code. For instance, the <code>client</code> code
and its <code>connect</code> function might make more sense to users of our library if
they were inside the <code>network</code> namespace instead, as in Listing 7-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-2: Moving the <code>client</code> module inside the
<code>network</code> module</span></p>
<p>In your <em>src/lib.rs</em> file, replace the existing <code>mod network</code> and <code>mod client</code>
definitions with the ones in Listing 7-2, which have the <code>client</code> module as an
inner module of <code>network</code>. Now we have the functions <code>network::connect</code> and
<code>network::client::connect</code>: again, the two functions named <code>connect</code> don’t
conflict with each other because they’re in different namespaces.</p>
<p>In this way, modules form a hierarchy. The contents of <em>src/lib.rs</em> are at the
topmost level, and the submodules are at lower levels. Here’s what the
organization of our example in Listing 7-1 looks like when thought of as a
hierarchy:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>And here’s the hierarchy corresponding to the example in Listing 7-2:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>The hierarchy shows that in Listing 7-2, <code>client</code> is a child of the <code>network</code>
module rather than a sibling. More complicated projects can have many modules,
and they’ll need to be organized logically in order to keep track of them. What
“logically” means in your project is up to you and depends on how you and your
library’s users think about your project’s domain. Use the techniques shown
here to create side-by-side modules and nested modules in whatever structure
you would like.</p>
<a class="header" href="print.html#moving-modules-to-other-files" id="moving-modules-to-other-files"><h3>Moving Modules to Other Files</h3></a>
<p>Modules form a hierarchical structure, much like another structure in computing
that you’re used to: filesystems! We can use Rust’s module system along with
multiple files to split up Rust projects so not everything lives in
<em>src/lib.rs</em> or <em>src/main.rs</em>. For this example, let’s start with the code in
Listing 7-3:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-3: Three modules, <code>client</code>, <code>network</code>, and
<code>network::server</code>, all defined in <em>src/lib.rs</em></span></p>
<p>The file <em>src/lib.rs</em> has this module hierarchy:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>If these modules had many functions, and those functions were becoming lengthy,
it would be difficult to scroll through this file to find the code we wanted to
work with. Because the functions are nested inside one or more <code>mod</code> blocks,
the lines of code inside the functions will start getting lengthy as well.
These would be good reasons to separate the <code>client</code>, <code>network</code>, and <code>server</code>
modules from <em>src/lib.rs</em> and place them into their own files.</p>
<p>First, replace the <code>client</code> module code with only the declaration of the
<code>client</code> module, so that your <em>src/lib.rs</em> looks like code shown in Listing 7-4:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption">Listing 7-4: Extracting the contents of the <code>client</code> module but leaving the declaration in <em>src/lib.rs</em></span></p>
<p>We’re still <em>declaring</em> the <code>client</code> module here, but by replacing the block
with a semicolon, we’re telling Rust to look in another location for the code
defined within the scope of the <code>client</code> module. In other words, the line <code>mod client;</code> means:</p>
<pre><code class="language-rust ignore">mod client {
    // contents of client.rs
}
</code></pre>
<p>Now we need to create the external file with that module name. Create a
<em>client.rs</em> file in your <em>src/</em> directory and open it. Then enter the
following, which is the <code>connect</code> function in the <code>client</code> module that we
removed in the previous step:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Note that we don’t need a <code>mod</code> declaration in this file because we already
declared the <code>client</code> module with <code>mod</code> in <em>src/lib.rs</em>. This file just
provides the <em>contents</em> of the <code>client</code> module. If we put a <code>mod client</code> here,
we’d be giving the <code>client</code> module its own submodule named <code>client</code>!</p>
<p>Rust only knows to look in <em>src/lib.rs</em> by default. If we want to add more
files to our project, we need to tell Rust in <em>src/lib.rs</em> to look in other
files; this is why <code>mod client</code> needs to be defined in <em>src/lib.rs</em> and can’t
be defined in <em>src/client.rs</em>.</p>
<p>Now the project should compile successfully, although you’ll get a few
warnings. Remember to use <code>cargo build</code> instead of <code>cargo run</code> because we have
a library crate rather than a binary crate:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>These warnings tell us that we have functions that are never used. Don’t worry
about these warnings for now; we’ll address them later in this chapter in the
“Controlling Visibility with <code>pub</code>” section. The good news is that they’re just
warnings; our project built successfully!</p>
<p>Next, let’s extract the <code>network</code> module into its own file using the same
pattern. In <em>src/lib.rs</em>, delete the body of the <code>network</code> module and add a
semicolon to the declaration, like so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Then create a new <em>src/network.rs</em> file and enter the following:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Notice that we still have a <code>mod</code> declaration within this module file; this is
because we still want <code>server</code> to be a submodule of <code>network</code>.</p>
<p>Run <code>cargo build</code> again. Success! We have one more module to extract: <code>server</code>.
Because it’s a submodule—that is, a module within a module—our current tactic
of extracting a module into a file named after that module won’t work. We’ll
try anyway so you can see the error. First, change <em>src/network.rs</em> to have
<code>mod server;</code> instead of the <code>server</code> module’s contents:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Then create a <em>src/server.rs</em> file and enter the contents of the <code>server</code>
module that we extracted:</p>
<p><span class="filename">Filename: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>When we try to <code>cargo build</code>, we’ll get the error shown in Listing 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listing 7-5: Error when trying to extract the <code>server</code>
submodule into <em>src/server.rs</em></span></p>
<p>The error says we <code>cannot declare a new module at this location</code> and is
pointing to the <code>mod server;</code> line in <em>src/network.rs</em>. So <em>src/network.rs</em> is
different than <em>src/lib.rs</em> somehow: keep reading to understand why.</p>
<p>The note in the middle of Listing 7-5 is actually very helpful because it
points out something we haven’t yet talked about doing:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>Instead of continuing to follow the same file naming pattern we used
previously, we can do what the note suggests:</p>
<ol>
<li>Make a new <em>directory</em> named <em>network</em>, the parent module’s name.</li>
<li>Move the <em>src/network.rs</em> file into the new <em>network</em> directory, and
rename it to <em>src/network/mod.rs</em>.</li>
<li>Move the submodule file <em>src/server.rs</em> into the <em>network</em> directory.</li>
</ol>
<p>Here are commands to carry out these steps:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Now when we try to run <code>cargo build</code>, compilation will work (we’ll still have
warnings though). Our module layout still looks like this, which is exactly the
same as it did when we had all the code in <em>src/lib.rs</em> in Listing 7-3:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>The corresponding file layout now looks like this:</p>
<pre><code class="language-text">├── src
│   ├── client.rs
│   ├── lib.rs
│   └── network
│       ├── mod.rs
│       └── server.rs
</code></pre>
<p>So when we wanted to extract the <code>network::server</code> module, why did we have to
also change the <em>src/network.rs</em> file to the <em>src/network/mod.rs</em> file and put
the code for <code>network::server</code> in the <em>network</em> directory in
<em>src/network/server.rs</em> instead of just being able to extract the
<code>network::server</code> module into <em>src/server.rs</em>? The reason is that Rust wouldn’t
be able to recognize that <code>server</code> was supposed to be a submodule of <code>network</code>
if the <em>server.rs</em> file was in the <em>src</em> directory. To clarify Rust’s behavior
here, let’s consider a different example with the following module hierarchy,
where all the definitions are in <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>In this example, we have three modules again: <code>client</code>, <code>network</code>, and
<code>network::client</code>. Following the same steps we did earlier for extracting
modules into files, we would create <em>src/client.rs</em> for the <code>client</code> module.
For the <code>network</code> module, we would create <em>src/network.rs</em>. But we wouldn’t be
able to extract the <code>network::client</code> module into a <em>src/client.rs</em> file
because that already exists for the top-level <code>client</code> module! If we could put
the code for <em>both</em> the <code>client</code> and <code>network::client</code> modules in the
<em>src/client.rs</em> file, Rust wouldn’t have any way to know whether the code was
for <code>client</code> or for <code>network::client</code>.</p>
<p>Therefore, in order to extract a file for the <code>network::client</code> submodule of
the <code>network</code> module, we needed to create a directory for the <code>network</code> module
instead of a <em>src/network.rs</em> file. The code that is in the <code>network</code> module
then goes into the <em>src/network/mod.rs</em> file, and the submodule
<code>network::client</code> can have its own <em>src/network/client.rs</em> file. Now the
top-level <em>src/client.rs</em> is unambiguously the code that belongs to the
<code>client</code> module.</p>
<a class="header" href="print.html#rules-of-module-filesystems" id="rules-of-module-filesystems"><h3>Rules of Module Filesystems</h3></a>
<p>Let’s summarize the rules of modules with regard to files:</p>
<ul>
<li>If a module named <code>foo</code> has no submodules, you should put the declarations
for <code>foo</code> in a file named <em>foo.rs</em>.</li>
<li>If a module named <code>foo</code> does have submodules, you should put the declarations
for <code>foo</code> in a file named <em>foo/mod.rs</em>.</li>
</ul>
<p>These rules apply recursively, so if a module named <code>foo</code> has a submodule named
<code>bar</code> and <code>bar</code> does not have submodules, you should have the following files
in your <em>src</em> directory:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contains the declarations in `foo::bar`)
│   └── mod.rs (contains the declarations in `foo`, including `mod bar`)
</code></pre>
<p>The modules should be declared in their parent module’s file using the <code>mod</code>
keyword.</p>
<p>Next, we’ll talk about the <code>pub</code> keyword and get rid of those warnings!</p>
<a class="header" href="print.html#controlling-visibility-with-pub" id="controlling-visibility-with-pub"><h2>Controlling Visibility with <code>pub</code></h2></a>
<p>We resolved the error messages shown in Listing 7-5 by moving the <code>network</code> and
<code>network::server</code> code into the <em>src/network/mod.rs</em> and
<em>src/network/server.rs</em> files, respectively. At that point, <code>cargo build</code> was
able to build our project, but we still get warning messages about the
<code>client::connect</code>, <code>network::connect</code>, and <code>network::server::connect</code> functions
not being used:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>So why are we receiving these warnings? After all, we’re building a library
with functions that are intended to be used by our <em>users</em>, not necessarily by
us within our own project, so it shouldn’t matter that these <code>connect</code>
functions go unused. The point of creating them is that they will be used by
another project, not our own.</p>
<p>To understand why this program invokes these warnings, let’s try using the
<code>connect</code> library from another project, calling it externally. To do that,
we’ll create a binary crate in the same directory as our library crate by
making a <em>src/main.rs</em> file containing this code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>We use the <code>extern crate</code> command to bring the <code>communicator</code> library crate
into scope. Our package now contains <em>two</em> crates. Cargo treats <em>src/main.rs</em>
as the root file of a binary crate, which is separate from the existing library
crate whose root file is <em>src/lib.rs</em>. This pattern is quite common for
executable projects: most functionality is in a library crate, and the binary
crate uses that library crate. As a result, other programs can also use the
library crate, and it’s a nice separation of concerns.</p>
<p>From the point of view of a crate outside the <code>communicator</code> library looking
in, all the modules we’ve been creating are within a module that has the same
name as the crate, <code>communicator</code>. We call the top-level module of a crate the
<em>root module</em>.</p>
<p>Also note that even if we’re using an external crate within a submodule of our
project, the <code>extern crate</code> should go in our root module (so in <em>src/main.rs</em>
or <em>src/lib.rs</em>). Then, in our submodules, we can refer to items from external
crates as if the items are top-level modules.</p>
<p>Right now, our binary crate just calls our library’s <code>connect</code> function from
the <code>client</code> module. However, invoking <code>cargo build</code> will now give us an error
after the warnings:</p>
<pre><code class="language-text">error[E0603]: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Ah ha! This error tells us that the <code>client</code> module is private, which is the
crux of the warnings. It’s also the first time we’ve run into the concepts of
<em>public</em> and <em>private</em> in the context of Rust. The default state of all code in
Rust is private: no one else is allowed to use the code. If you don’t use a
private function within your program, because your program is the only code
allowed to use that function, Rust will warn you that the function has gone
unused.</p>
<p>After we specify that a function like <code>client::connect</code> is public, not only
will our call to that function from our binary crate be allowed, but the
warning that the function is unused will go away. Marking a function as public
lets Rust know that the function will be used by code outside of our program.
Rust considers the theoretical external usage that’s now possible as the
function “being used.” Thus, when a function is marked public, Rust will not
require that it be used in our program and will stop warning that the function
is unused.</p>
<a class="header" href="print.html#making-a-function-public" id="making-a-function-public"><h3>Making a Function Public</h3></a>
<p>To tell Rust to make a function public, we add the <code>pub</code> keyword to the start
of the declaration. We’ll focus on fixing the warning that indicates
<code>client::connect</code> has gone unused for now, as well as the <code>module `client` is private</code> error from our binary crate. Modify <em>src/lib.rs</em> to make the
<code>client</code> module public, like so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p>The <code>pub</code> keyword is placed right before <code>mod</code>. Let’s try building again:</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Hooray! We have a different error! Yes, different error messages are a cause
for celebration. The new error shows <code>function `connect` is private</code>, so
let’s edit <em>src/client.rs</em> to make <code>client::connect</code> public too:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>Now run <code>cargo build</code> again:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>The code compiled, and the warning about <code>client::connect</code> not being used is
gone!</p>
<p>Unused code warnings don’t always indicate that an item in your code needs to
be made public: if you <em>didn’t</em> want these functions to be part of your public
API, unused code warnings could be alerting you to code you no longer need that
you can safely delete. They could also be alerting you to a bug if you had just
accidentally removed all places within your library where this function is
called.</p>
<p>But in this case, we <em>do</em> want the other two functions to be part of our
crate’s public API, so let’s mark them as <code>pub</code> as well to get rid of the
remaining warnings. Modify <em>src/network/mod.rs</em> to look like the following:</p>
<p><span class="filename">Filename: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>Then compile the code:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Hmmm, we’re still getting an unused function warning, even though
<code>network::connect</code> is set to <code>pub</code>. The reason is that the function is public
within the module, but the <code>network</code> module that the function resides in is not
public. We’re working from the interior of the library out this time, whereas
with <code>client::connect</code> we worked from the outside in. We need to change
<em>src/lib.rs</em> to make <code>network</code> public too, like so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>Now when we compile, that warning is gone:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>Only one warning is left! Try to fix this one on your own!</p>
<a class="header" href="print.html#privacy-rules" id="privacy-rules"><h3>Privacy Rules</h3></a>
<p>Overall, these are the rules for item visibility:</p>
<ol>
<li>If an item is public, it can be accessed through any of its parent modules.</li>
<li>If an item is private, it can be accessed only by its immediate parent
module and any of the parent’s child modules.</li>
</ol>
<a class="header" href="print.html#privacy-examples" id="privacy-examples"><h3>Privacy Examples</h3></a>
<p>Let’s look at a few more privacy examples to get some practice. Create a new
library project and enter the code in Listing 7-6 into your new project’s
<em>src/lib.rs</em>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Listing 7-6: Examples of private and public functions,
some of which are incorrect</span></p>
<p>Before you try to compile this code, make a guess about which lines in the
<code>try_me</code> function will have errors. Then, try compiling the code to see whether
you were right, and read on for the discussion of the errors!</p>
<a class="header" href="print.html#looking-at-the-errors" id="looking-at-the-errors"><h4>Looking at the Errors</h4></a>
<p>The <code>try_me</code> function is in the root module of our project. The module named
<code>outermost</code> is private, but the second privacy rule states that the <code>try_me</code>
function is allowed to access the <code>outermost</code> module because <code>outermost</code> is in
the current (root) module, as is <code>try_me</code>.</p>
<p>The call to <code>outermost::middle_function</code> will work because <code>middle_function</code> is
public, and <code>try_me</code> is accessing <code>middle_function</code> through its parent module
<code>outermost</code>. We determined in the previous paragraph that this module is
accessible.</p>
<p>The call to <code>outermost::middle_secret_function</code> will cause a compilation error.
<code>middle_secret_function</code> is private, so the second rule applies. The root
module is neither the current module of <code>middle_secret_function</code> (<code>outermost</code>
is), nor is it a child module of the current module of <code>middle_secret_function</code>.</p>
<p>The module named <code>inside</code> is private and has no child modules, so it can only
be accessed by its current module <code>outermost</code>. That means the <code>try_me</code> function
is not allowed to call <code>outermost::inside::inner_function</code> or
<code>outermost::inside::secret_function</code>.</p>
<a class="header" href="print.html#fixing-the-errors" id="fixing-the-errors"><h4>Fixing the Errors</h4></a>
<p>Here are some suggestions for changing the code in an attempt to fix the
errors. Before you try each one, make a guess as to whether it will fix the
errors, and then compile the code to see whether or not you’re right, using the
privacy rules to understand why.</p>
<ul>
<li>What if the <code>inside</code> module was public?</li>
<li>What if <code>outermost</code> was public and <code>inside</code> was private?</li>
<li>What if, in the body of <code>inner_function</code>, you called
<code>::outermost::middle_secret_function()</code>? (The two colons at the beginning mean
that we want to refer to the modules starting from the root module.)</li>
</ul>
<p>Feel free to design more experiments and try them out!</p>
<p>Next, let’s talk about bringing items into scope with the <code>use</code> keyword.</p>
<a class="header" href="print.html#referring-to-names-in-different-modules" id="referring-to-names-in-different-modules"><h2>Referring to Names in Different Modules</h2></a>
<p>We’ve covered how to call functions defined within a module using the module
name as part of the call, as in the call to the <code>nested_modules</code> function shown
here in Listing 7-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Listing 7-7: Calling a function by fully specifying its
enclosing module’s path</span></p>
<p>As you can see, referring to the fully qualified name can get quite lengthy.
Fortunately, Rust has a keyword to make these calls more concise.</p>
<a class="header" href="print.html#bringing-names-into-scope-with-the-use-keyword" id="bringing-names-into-scope-with-the-use-keyword"><h3>Bringing Names into Scope with the <code>use</code> Keyword</h3></a>
<p>Rust’s <code>use</code> keyword shortens lengthy function calls by bringing the modules of
the function you want to call into scope. Here’s an example of bringing the
<code>a::series::of</code> module into a binary crate’s root scope:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p>The line <code>use a::series::of;</code> means that rather than using the full
<code>a::series::of</code> path wherever we want to refer to the <code>of</code> module, we can use
<code>of</code>.</p>
<p>The <code>use</code> keyword brings only what we’ve specified into scope: it does not
bring children of modules into scope. That’s why we still have to use
<code>of::nested_modules</code> when we want to call the <code>nested_modules</code> function.</p>
<p>We could have chosen to bring the function into scope by instead specifying the
function in the <code>use</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Doing so allows us to exclude all the modules and reference the function
directly.</p>
<p>Because enums also form a sort of namespace like modules, we can bring an
enum’s variants into scope with <code>use</code> as well. For any kind of <code>use</code> statement,
if you’re bringing multiple items from one namespace into scope, you can list
them using curly brackets and commas in the last position, like so:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p>We’re still specifying the <code>TrafficLight</code> namespace for the <code>Green</code> variant
because we didn’t include <code>Green</code> in the <code>use</code> statement.</p>
<a class="header" href="print.html#bringing-all-names-into-scope-with-a-glob" id="bringing-all-names-into-scope-with-a-glob"><h3>Bringing All Names into Scope with a Glob</h3></a>
<p>To bring all the items in a namespace into scope at once, we can use the <code>*</code>  syntax, which is called the <em>glob operator</em>. This example brings all the variants of an enum into scope without having to list each specifically:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p>The <code>*</code> will bring into scope all the visible items in the <code>TrafficLight</code>
namespace. You should use globs sparingly: they are convenient, but this might
also pull in more items than you expected and cause naming conflicts.</p>
<a class="header" href="print.html#using-super-to-access-a-parent-module" id="using-super-to-access-a-parent-module"><h3>Using <code>super</code> to Access a Parent Module</h3></a>
<p>As we saw at the beginning of this chapter, when you create a library crate,
Cargo makes a <code>tests</code> module for you. Let’s go into more detail about that now.
In your <code>communicator</code> project, open <em>src/lib.rs</em>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>Chapter 11 explains more about testing, but parts of this example should make
sense now: we have a module named <code>tests</code> that lives next to our other modules
and contains one function named <code>it_works</code>. Even though there are special
annotations, the <code>tests</code> module is just another module! So our module hierarchy
looks like this:</p>
<pre><code class="language-text">communicator
 ├── client
 ├── network
 |   └── client
 └── tests
</code></pre>
<p>Tests are for exercising the code within our library, so let’s try to call our
<code>client::connect</code> function from this <code>it_works</code> function, even though we won’t
be checking any functionality right now. This won’t work yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Run the tests by invoking the <code>cargo test</code> command:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>The compilation failed, but why? We don’t need to place <code>communicator::</code> in
front of the function like we did in <em>src/main.rs</em> because we are definitely
within the <code>communicator</code> library crate here. The reason is that paths are
always relative to the current module, which here is <code>tests</code>. The only
exception is in a <code>use</code> statement, where paths are relative to the crate root
by default. Our <code>tests</code> module needs the <code>client</code> module in its scope!</p>
<p>So how do we get back up one module in the module hierarchy to call the
<code>client::connect</code> function in the <code>tests</code> module? In the <code>tests</code> module, we can
either use leading colons to let Rust know that we want to start from the root
and list the whole path, like this:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>Or, we can use <code>super</code> to move up one module in the hierarchy from our current
module, like this:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>These two options don’t look that different in this example, but if you’re
deeper in a module hierarchy, starting from the root every time would make your
code lengthy. In those cases, using <code>super</code> to get from the current module to
sibling modules is a good shortcut. Plus, if you’ve specified the path from the
root in many places in your code and then you rearrange your modules by moving
a subtree to another place, you’d end up needing to update the path in several
places, which would be tedious.</p>
<p>It would also be annoying to have to type <code>super::</code> in each test, but you’ve
already seen the tool for that solution: <code>use</code>! The <code>super::</code> functionality
changes the path you give to <code>use</code> so it is relative to the parent module
instead of to the root module.</p>
<p>For these reasons, in the <code>tests</code> module especially, <code>use super::something</code> is
usually the best solution. So now our test looks like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>When we run <code>cargo test</code> again, the test will pass and the first part of the
test result output will be the following:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#summary-2" id="summary-2"><h2>Summary</h2></a>
<p>Now you know some new techniques for organizing your code! Use these techniques
to group related functionality together, keep files from becoming too long, and
present a tidy public API to your library users.</p>
<p>Next, we’ll look at some collection data structures in the standard library
that you can use in your nice, neat code!</p>
<a class="header" href="print.html#common-collections" id="common-collections"><h1>Common Collections</h1></a>
<p>Rust’s standard library includes a number of very useful data structures called
<em>collections</em>. Most other data types represent one specific value, but
collections can contain multiple values. Unlike the built-in array and tuple
types, the data these collections point to is stored on the heap, which means
the amount of data does not need to be known at compile time and can grow or
shrink as the program runs. Each kind of collection has different capabilities
and costs, and choosing an appropriate one for your current situation is a
skill you’ll develop over time. In this chapter, we’ll discuss three
collections that are used very often in Rust programs:</p>
<ul>
<li>A <em>vector</em> allows us to store a variable number of values next to each other.</li>
<li>A <em>string</em> is a collection of characters. We’ve discussed the <code>String</code> type
previously, but in this chapter we’ll talk about it in depth.</li>
<li>A <em>hash map</em> allows us to associate a value with a particular key. It’s a
particular implementation of the more general data structure called a <em>map</em>.</li>
</ul>
<p>To learn about the other kinds of collections provided by the standard library,
see <a href="../../std/collections/index.html">the documentation</a>.</p>
<p>We’ll discuss how to create and update vectors, strings, and hash maps, as well
as what makes each special.</p>
<a class="header" href="print.html#vectors-store-lists-of-values" id="vectors-store-lists-of-values"><h2>Vectors Store Lists of Values</h2></a>
<p>The first collection type we’ll look at is <code>Vec&lt;T&gt;</code>, also known as a <em>vector</em>.
Vectors allow us to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful in situations in which you have a list of
items, such as the lines of text in a file or the prices of items in a shopping
cart.</p>
<a class="header" href="print.html#creating-a-new-vector" id="creating-a-new-vector"><h3>Creating a New Vector</h3></a>
<p>To create a new, empty vector, we can call the <code>Vec::new</code> function as shown in
Listing 8-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p><span class="caption">Listing 8-1: Creating a new, empty vector to hold values
of type <code>i32</code></span></p>
<p>Note that we added a type annotation here. Because we aren’t inserting any
values into this vector, Rust doesn’t know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
we’ll cover how to use generics with your own types in Chapter 10. For now,
know that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type,
and when a specific vector holds a specific type, the type is specified within
angle brackets. In Listing 8-1, we’ve told Rust that the <code>Vec&lt;T&gt;</code> in <code>v</code> will
hold elements of the <code>i32</code> type.</p>
<p>In more realistic code, Rust can often infer the type of value we want to store
once we insert values, so you rarely need to do this type annotation. It’s more
common to create a <code>Vec&lt;T&gt;</code> that has initial values, and Rust provides the
<code>vec!</code> macro for convenience. The macro will create a new vector that holds the
values we give it. Listing 8-2 creates a new <code>Vec&lt;i32&gt;</code> that holds the values
<code>1</code>, <code>2</code>, and <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p><span class="caption">Listing 8-2: Creating a new vector containing
values</span></p>
<p>Because we’ve given initial <code>i32</code> values, Rust can infer that the type of <code>v</code>
is <code>Vec&lt;i32&gt;</code>, and the type annotation isn’t necessary. Next, we’ll look at how
to modify a vector.</p>
<a class="header" href="print.html#updating-a-vector" id="updating-a-vector"><h3>Updating a Vector</h3></a>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method as
shown in Listing 8-3:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p><span class="caption">Listing 8-3: Using the <code>push</code> method to add values to a
vector</span></p>
<p>As with any variable, as discussed in Chapter 3, if we want to be able to
change its value, we need to make it mutable using the <code>mut</code> keyword. The
numbers we place inside are all of type <code>i32</code>, and Rust infers this from the
data, so we don’t need the <code>Vec&lt;i32&gt;</code> annotation.</p>
<a class="header" href="print.html#dropping-a-vector-drops-its-elements" id="dropping-a-vector-drops-its-elements"><h3>Dropping a Vector Drops Its Elements</h3></a>
<p>Like any other <code>struct</code>, a vector will be freed when it goes out of scope, as
annotated in Listing 8-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // &lt;- v goes out of scope and is freed here
#}</code></pre></pre>
<p><span class="caption">Listing 8-4: Showing where the vector and its elements
are dropped</span></p>
<p>When the vector gets dropped, all of its contents will also be dropped, meaning
those integers it holds will be cleaned up. This may seem like a
straightforward point but can get a bit more complicated when we start to
introduce references to the elements of the vector. Let’s tackle that next!</p>
<a class="header" href="print.html#reading-elements-of-vectors" id="reading-elements-of-vectors"><h3>Reading Elements of Vectors</h3></a>
<p>Now that you know how to create, update, and destroy vectors, knowing how to
read their contents is a good next step. There are two ways to reference a
value stored in a vector. In the examples, we’ve annotated the types of the
values that are returned from these functions for extra clarity.</p>
<p>Listing 8-5 shows both methods of accessing a value in a vector either with
indexing syntax or the <code>get</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p><span class="caption">Listing 8-5: Using indexing syntax or the <code>get</code> method to
access an item in a vector</span></p>
<p>Note two details here. First, we use the index value of <code>2</code> to get the third
element: vectors are indexed by number, starting at zero. Second, the two
different ways to get the third element are by using <code>&amp;</code> and <code>[]</code>, which gives
us a reference, or by using the <code>get</code> method with the index passed as an
argument, which gives us an <code>Option&lt;&amp;T&gt;</code>.</p>
<p>The reason Rust has two ways to reference an element is so you can choose how
the program behaves when you try to use an index value that the vector doesn’t
have an element for. As an example, let’s see what a program will do if it has
a vector that holds five elements and then tries to access an element at index
100, as shown in Listing 8-6:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p><span class="caption">Listing 8-6: Attempting to access the element at index
100 in a vector containing 5 elements</span></p>
<p>When you run this code, the first <code>[]</code> method will cause a <code>panic!</code> because it
references a nonexistent element. This method is best used when you want your
program to consider an attempt to access an element past the end of the vector
to be a fatal error that crashes the program.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns
<code>None</code> without panicking. You would use this method if accessing an element
beyond the range of the vector happens occasionally under normal circumstances.
Your code will then have logic to handle having either <code>Some(&amp;element)</code> or
<code>None</code>, as discussed in Chapter 6. For example, the index could be coming from
a person entering a number. If they accidentally enter a number that’s too
large and the program gets a <code>None</code> value, you could tell the user how many
items are in the current vector and give them another chance to enter a valid
value. That would be more user-friendly than crashing the program due to a typo!</p>
<a class="header" href="print.html#invalid-references" id="invalid-references"><h4>Invalid References</h4></a>
<p>When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states we can’t have mutable and immutable references in the same
scope. That rule applies in Listing 8-7 where we hold an immutable reference to
the first element in a vector and try to add an element to the end, which won’t
work:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p><span class="caption">Listing 8-7: Attempting to add an element to a vector
while holding a reference to an item</span></p>
<p>Compiling this code will result in this error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt;
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^ mutable borrow occurs here
7 |
8 | }
  | - immutable borrow ends here
</code></pre>
<p>The code in Listing 8-7 might look like it should work: why should a reference
to the first element care about what changes at the end of the vector? The
reason behind this error is due to the way vectors work: adding a new element
onto the end of the vector might require allocating new memory and copying the
old elements to the new space if there isn’t enough room to put all the
elements next to each other where the vector was. In that case, the reference
to the first element would be pointing to deallocated memory. The borrowing
rules prevent programs from ending up in that situation.</p>
<blockquote>
<p>Note: For more on the implementation details of the <code>Vec&lt;T&gt;</code> type, see “The
Rustonomicon” at https://doc.rust-lang.org/stable/nomicon/vec.html.</p>
</blockquote>
<a class="header" href="print.html#iterating-over-the-values-in-a-vector" id="iterating-over-the-values-in-a-vector"><h3>Iterating Over the Values in a Vector</h3></a>
<p>If we want to access each element in a vector in turn, we can iterate through
all of the elements rather than use indexes to access one at a time. Listing
8-8 shows how to use a <code>for</code> loop to get immutable references to each element
in a vector of <code>i32</code> values and print them out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<p><span class="caption">Listing 8-8: Printing each element in a vector by
iterating over the elements using a <code>for</code> loop</span></p>
<p>We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The <code>for</code> loop in Listing 8-9
will add <code>50</code> to each element:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
#}</code></pre></pre>
<p><span class="caption">Listing 8-9: Iterating over mutable references to
elements in a vector</span></p>
<p>To change the value that the mutable reference refers to, we have to use the
dereference operator (<code>*</code>) to get to the value in <code>i</code> before we can use the
<code>+=</code> operator .</p>
<a class="header" href="print.html#using-an-enum-to-store-multiple-types" id="using-an-enum-to-store-multiple-types"><h3>Using an Enum to Store Multiple Types</h3></a>
<p>At the beginning of this chapter, we said that vectors can only store values
that are the same type. This can be inconvenient; there are definitely use
cases for needing to store a list of items of different types. Fortunately, the
variants of an enum are defined under the same enum type, so when we need to
store elements of a different type in a vector, we can define and use an enum!</p>
<p>For example, let’s say we want to get values from a row in a spreadsheet where
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and then all the enum variants will be considered the same type:
that of the enum. Then we can create a vector that holds that enum and so,
ultimately, holds different types. We’ve demonstrated this in Listing 8-10:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">Listing 8-10: Defining an <code>enum</code> to store values of
different types in one vector</span></p>
<p>The reason Rust needs to know what types will be in the vector at compile time
is so it knows exactly how much memory on the heap will be needed to store each
element. A secondary advantage is that we can be explicit about what types are
allowed in this vector. If Rust allowed a vector to hold any type, there would
be a chance that one or more of the types would cause errors with the
operations performed on the elements of the vector. Using an enum plus a
<code>match</code> expression means that Rust will ensure at compile time that we always
handle every possible case, as discussed in Chapter 6.</p>
<p>If you don’t know the exhaustive set of types the program will get at runtime
to store in a vector when you’re writing a program, the enum technique won’t
work. Instead, you can use a trait object, which we’ll cover in Chapter 17.</p>
<p>Now that we’ve discussed some of the most common ways to use vectors, be sure
to review the API documentation for all the many useful methods defined on
<code>Vec&lt;T&gt;</code> by the standard library. For example, in addition to <code>push</code>, a <code>pop</code>
method removes and returns the last element. Let’s move on to the next
collection type: <code>String</code>!</p>
<a class="header" href="print.html#strings-store-utf-8-encoded-text" id="strings-store-utf-8-encoded-text"><h2>Strings Store UTF-8 Encoded Text</h2></a>
<p>We talked about strings in Chapter 4, but we’ll look at them in more depth now.
New Rustaceans commonly get stuck on strings due to a combination of three
concepts: Rust’s propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These concepts combine in a way that can seem difficult when you’re
coming from other programming languages.</p>
<p>This discussion of strings is in the collections chapter because strings are
implemented as a collection of bytes plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, we’ll
talk about the operations on <code>String</code> that every collection type has, such as
creating, updating, and reading. We’ll also discuss the ways in which <code>String</code>
is different than the other collections, namely how indexing into a <code>String</code> is
complicated by the differences between how people and computers interpret
<code>String</code> data.</p>
<a class="header" href="print.html#what-is-a-string" id="what-is-a-string"><h3>What Is a String?</h3></a>
<p>We’ll first define what we mean by the term <em>string</em>. Rust has only one string
type in the core language, which is the string slice <code>str</code> that is usually seen
in its borrowed form <code>&amp;str</code>. In Chapter 4, we talked about <em>string slices</em>,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the binary output of the program and are
therefore string slices.</p>
<p>The <code>String</code> type is provided in Rust’s standard library rather than coded into
the core language and is a growable, mutable, owned, UTF-8 encoded string type.
When Rustaceans refer to “strings” in Rust, they usually mean the <code>String</code> and
the string slice <code>&amp;str</code> types, not just one of those types. Although this
section is largely about <code>String</code>, both types are used heavily in Rust’s
standard library and both <code>String</code> and string slices are UTF-8 encoded.</p>
<p>Rust’s standard library also includes a number of other string types, such as
<code>OsString</code>, <code>OsStr</code>, <code>CString</code>, and <code>CStr</code>. Library crates can provide even
more options for storing string data. Similar to the <code>*String</code>/<code>*Str</code> naming,
they often provide an owned and borrowed variant, just like <code>String</code>/<code>&amp;str</code>.
These string types can store text in different encodings or be represented in
memory in a different way, for example. We won’t discuss these other string
types in this chapter; see their API documentation for more about how to use
them and when each is appropriate.</p>
<a class="header" href="print.html#creating-a-new-string" id="creating-a-new-string"><h3>Creating a New String</h3></a>
<p>Many of the same operations available with <code>Vec&lt;T&gt;</code> are available with <code>String</code>
as well, starting with the <code>new</code> function to create a string, shown in Listing
8-11:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p><span class="caption">Listing 8-11: Creating a new, empty <code>String</code></span></p>
<p>This line creates a new empty string called <code>s</code> that we can then load data
into. Often, we’ll have some initial data that we want to start the string
with. For that, we use the <code>to_string</code> method, which is available on any type
that implements the <code>Display</code> trait, which string literals do. Listing 8-12
shows two examples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p><span class="caption">Listing 8-12: Using the <code>to_string</code> method to create a
<code>String</code> from a string literal</span></p>
<p>This code creates a string containing <code>initial contents</code>.</p>
<p>We can also use the function <code>String::from</code> to create a <code>String</code> from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p><span class="caption">Listing 8-13: Using the <code>String::from</code> function to create
a <code>String</code> from a string literal</span></p>
<p>Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, <code>String::from</code> and
<code>to_string</code> do the same thing, so which you choose is a matter of style.</p>
<p>Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
#}</code></pre></pre>
<p><span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span></p>
<p>All of these are valid <code>String</code> values.</p>
<a class="header" href="print.html#updating-a-string" id="updating-a-string"><h3>Updating a String</h3></a>
<p>A <code>String</code> can grow in size and its contents can change, just like the contents
of a <code>Vec&lt;T&gt;</code>, by pushing more data into it. In addition, we can conveniently
use the <code>+</code> operator or the <code>format!</code> macro to concatenate <code>String</code> values
together.</p>
<a class="header" href="print.html#appending-to-a-string-with-push_str-and-push" id="appending-to-a-string-with-push_str-and-push"><h4>Appending to a String with <code>push_str</code> and <code>push</code></h4></a>
<p>We can grow a <code>String</code> by using the <code>push_str</code> method to append a string slice,
as shown in Listing 8-15:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><span class="caption">Listing 8-15: Appending a string slice to a <code>String</code>
using the <code>push_str</code> method</span></p>
<p>After these two lines, <code>s</code> will contain <code>foobar</code>. The <code>push_str</code> method takes a
string slice because we don’t necessarily want to take ownership of the
parameter. For example, the code in Listing 8-16 shows that it would be
unfortunate if we weren’t able to use <code>s2</code> after appending its contents to <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(&amp;s2);
println!(&quot;s2 is {}&quot;, s2);
#}</code></pre></pre>
<p><span class="caption">Listing 8-16: Using a string slice after appending its
contents to a <code>String</code></span></p>
<p>If the <code>push_str</code> method took ownership of <code>s2</code>, we wouldn’t be able to print
out its value on the last line. However, this code works as we’d expect!</p>
<p>The <code>push</code> method takes a single character as a parameter and adds it to the
<code>String</code>. Listing 8-17 shows code that adds the letter l character to a
<code>String</code> using the <code>push</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p><span class="caption">Listing 8-17: Adding one character to a <code>String</code> value
using <code>push</code></span></p>
<p>As a result of this code, <code>s</code> will contain <code>lol</code>.</p>
<a class="header" href="print.html#concatenation-with-the--operator-or-the-format-macro" id="concatenation-with-the--operator-or-the-format-macro"><h4>Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro</h4></a>
<p>Often, we’ll want to combine two existing strings. One way is to use the <code>+</code>
operator, as shown in Listing 8-18:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note that s1 has been moved here and can no longer be used
#}</code></pre></pre>
<p><span class="caption">Listing 8-18: Using the <code>+</code> operator to combine two
<code>String</code> values into a new <code>String</code> value</span></p>
<p>The string <code>s3</code> will contain <code>Hello, world!</code> as a result of this code. The
reason <code>s1</code> is no longer valid after the addition and the reason we used a
reference to <code>s2</code> has to do with the signature of the method that gets called
when we use the <code>+</code> operator. The <code>+</code> operator uses the <code>add</code> method, whose
signature looks something like this:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>This isn’t the exact signature that’s in the standard library: in the standard
library, <code>add</code> is defined using generics. Here, we’re looking at the signature
of <code>add</code> with concrete types substituted for the generic ones, which is what
happens when we call this method with <code>String</code> values. We’ll discuss generics
in Chapter 10. This signature gives us the clues we need to understand the
tricky bits of the <code>+</code> operator.</p>
<p>First, <code>s2</code> has an <code>&amp;</code>, meaning that we’re adding a <em>reference</em> of the second
string to the first string because of the <code>s</code> parameter in the <code>add</code> function:
we can only add a <code>&amp;str</code> to a <code>String</code>; we can’t add two <code>String</code> values
together. But wait - the type of <code>&amp;s2</code> is <code>&amp;String</code>, not <code>&amp;str</code>, as specified
in the second parameter to <code>add</code>. So why does Listing 8-18 compile?</p>
<p>The reason we’re able to use <code>&amp;s2</code> in the call to <code>add</code> is that the compiler
can <em>coerce</em> the <code>&amp;String</code> argument into a <code>&amp;str</code>. When we call the <code>add</code>
method, Rust uses a <em>deref coercion</em>, which here turns <code>&amp;s2</code> into <code>&amp;s2[..]</code>.
We’ll discuss deref coercion in more depth in Chapter 15. Because <code>add</code> does
not take ownership of the <code>s</code> parameter, <code>s2</code> will still be a valid <code>String</code>
after this operation.</p>
<p>Second, we can see in the signature that <code>add</code> takes ownership of <code>self</code>,
because <code>self</code> does <em>not</em> have an <code>&amp;</code>. This means <code>s1</code> in Listing 8-18 will be
moved into the <code>add</code> call and no longer be valid after that. So although <code>let s3 = s1 + &amp;s2;</code> looks like it will copy both strings and create a new one, this
statement actually takes ownership of <code>s1</code>, appends a copy of the contents of
<code>s2</code>, and then returns ownership of the result. In other words, it looks like
it’s making a lot of copies but isn’t: the implementation is more efficient
than copying.</p>
<p>If we need to concatenate multiple strings, the behavior of <code>+</code> gets unwieldy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p>At this point, <code>s</code> will be <code>tic-tac-toe</code>. With all of the <code>+</code> and <code>&quot;</code>
characters, it’s difficult to see what’s going on. For more complicated string
combining, we can use the <code>format!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>This code also sets <code>s</code> to <code>tic-tac-toe</code>. The <code>format!</code> macro works in the same
way as <code>println!</code>, but instead of printing the output to the screen, it returns
a <code>String</code> with the contents. The version of the code using <code>format!</code> is much
easier to read and also doesn’t take ownership of any of its parameters.</p>
<a class="header" href="print.html#indexing-into-strings" id="indexing-into-strings"><h3>Indexing into Strings</h3></a>
<p>In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if we try to access parts of a <code>String</code> using indexing syntax in Rust, we’ll
get an error. Consider the invalid code in Listing 8-19:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p><span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span></p>
<p>This code will result in the following error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied
 --&gt;
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`
</code></pre>
<p>The error and the note tell the story: Rust strings don’t support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.</p>
<a class="header" href="print.html#internal-representation" id="internal-representation"><h4>Internal Representation</h4></a>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>. Let’s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>In this case, <code>len</code> will be four, which means the <code>Vec</code> storing the string
“Hola” is four bytes long. Each of these letters takes one byte when encoded in
UTF-8. But what about the following line?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();
#}</code></pre></pre>
<p>Note that this string begins with the capital Cyrillic letter Ze, not the
Arabic number 3. Asked how long the string is, you might say 12. However,
Rust’s answer is 24: that’s the number of bytes it takes to encode
“Здравствуйте” in UTF-8, because each Unicode scalar value takes two bytes of
storage. Therefore, an index into the string’s bytes will not always correlate
to a valid Unicode scalar value. To demonstrate, consider this invalid Rust
code:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>What should the value of <code>answer</code> be? Should it be <code>З</code>, the first letter? When
encoded in UTF-8, the first byte of <code>З</code> is <code>208</code>, and the second is <code>151</code>, so
<code>answer</code> should in fact be <code>208</code>, but <code>208</code> is not a valid character on its
own. Returning <code>208</code> is likely not what a user would want if they asked for the
first letter of this string; however, that’s the only data that Rust has at
byte index 0. Returning the byte value is probably not what users want, even if
the string contains only Latin letters: if <code>&amp;&quot;hello&quot;[0]</code> was valid code that
returned the byte value, it would return <code>104</code>, not <code>h</code>. To avoid returning an
unexpected value and causing bugs that might not be discovered immediately,
Rust doesn’t compile this code at all and prevents misunderstandings earlier in
the development process.</p>
<a class="header" href="print.html#bytes-and-scalar-values-and-grapheme-clusters-oh-my" id="bytes-and-scalar-values-and-grapheme-clusters-oh-my"><h4>Bytes and Scalar Values and Grapheme Clusters! Oh My!</h4></a>
<p>Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust’s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call <em>letters</em>).</p>
<p>If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is
ultimately stored as a <code>Vec</code> of <code>u8</code> values that looks like this:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>That’s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust’s <code>char</code> type is, those
bytes look like this:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>There are six <code>char</code> values here, but the fourth and sixth are not letters:
they’re diacritics that don’t make sense on their own. Finally, if we look at
them as grapheme clusters, we’d get what a person would call the four letters
that make up the Hindi word:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.</p>
<p>A final reason Rust doesn’t allow us to index into a <code>String</code> to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn’t possible to guarantee that performance with a <code>String</code>,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.</p>
<a class="header" href="print.html#slicing-strings" id="slicing-strings"><h3>Slicing Strings</h3></a>
<p>Indexing into a string is often a bad idea because it’s not clear what the
return type of the string indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. Therefore, Rust asks you to
be more specific if you really need to use indices to create string slices. To
be more specific in your indexing and indicate that you want a string slice,
rather than indexing using <code>[]</code> with a single number, you can use <code>[]</code> with a
range to create a string slice containing particular bytes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Here, <code>s</code> will be a <code>&amp;str</code> that contains the first four bytes of the string.
Earlier, we mentioned that each of these characters was two bytes, which means
<code>s</code> will be <code>Зд</code>.</p>
<p>What would happen if we used <code>&amp;hello[0..1]</code>? The answer: Rust will panic at
runtime in the same way that accessing an invalid index in a vector does:</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
</code></pre>
<p>You should use ranges to create string slices with caution, because it can
crash your program.</p>
<a class="header" href="print.html#methods-for-iterating-over-strings" id="methods-for-iterating-over-strings"><h3>Methods for Iterating Over Strings</h3></a>
<p>Fortunately, we can access elements in a string in other ways.</p>
<p>If we need to perform operations on individual Unicode scalar values, the best
way to do so is to use the <code>chars</code> method. Calling <code>chars</code> on “नमस्ते” separates
out and returns six values of type <code>char</code>, and we can iterate over the result
in order to access each element:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>This code will print the following:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>The <code>bytes</code> method returns each raw byte, which might be appropriate for your
domain:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>This code will print the 18 bytes that make up this <code>String</code>, starting with:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>But be sure to remember that valid Unicode scalar values may be made up of more
than one byte.</p>
<p>Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
<a href="https://crates.io">crates.io</a> if this is the functionality you need.</p>
<a class="header" href="print.html#strings-are-not-so-simple" id="strings-are-not-so-simple"><h3>Strings Are Not So Simple</h3></a>
<p>To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of <code>String</code> data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than other programming languages do but prevents you from having to
handle errors involving non-ASCII characters later in your development life
cycle.</p>
<p>Let’s switch to something a bit less complex: hash maps!</p>
<a class="header" href="print.html#hash-maps-store-keys-associated-with-values" id="hash-maps-store-keys-associated-with-values"><h2>Hash Maps Store Keys Associated with Values</h2></a>
<p>The last of our common collections is the <em>hash map</em>. The type <code>HashMap&lt;K, V&gt;</code>
stores a mapping of keys of type <code>K</code> to values of type <code>V</code>. It does this via a
<em>hashing function</em>, which determines how it places these keys and values into
memory. Many different programming languages support this kind of data
structure, but often use a different name, such as hash, map, object, hash
table, or associative array, just to name a few.</p>
<p>Hash maps are useful for when you want to look up data not by an index, as you
can with vectors, but by using a key that can be of any type. For example, in a
game, you could keep track of each team’s score in a hash map where each key is
a team’s name and the values are each team’s score. Given a team name, you can
retrieve its score.</p>
<p>We’ll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on <code>HashMap&lt;K, V&gt;</code> by the standard library.
As always, check the standard library documentation for more information.</p>
<a class="header" href="print.html#creating-a-new-hash-map" id="creating-a-new-hash-map"><h3>Creating a New Hash Map</h3></a>
<p>We can create an empty hash map with <code>new</code> and add elements with <code>insert</code>. In
Listing 8-20, we’re keeping track of the scores of two teams whose names are
Blue and Yellow. The Blue team will start with 10 points, and the Yellow team
starts with 50:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p><span class="caption">Listing 8-20: Creating a new hash map and inserting some
keys and values</span></p>
<p>Note that we need to first <code>use</code> the <code>HashMap</code> from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so it’s not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; there’s no built-in macro to construct them, for example.</p>
<p>Just like vectors, hash maps store their data on the heap. This <code>HashMap</code> has
keys of type <code>String</code> and values of type <code>i32</code>. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.</p>
<p>Another way of constructing a hash map is by using the <code>collect</code> method on a
vector of tuples, where each tuple consists of a key and its value. The
<code>collect</code> method gathers data into a number of collection types, including
<code>HashMap</code>. For example, if we had the team names and initial scores in two
separate vectors, we can use the <code>zip</code> method to create a vector of tuples
where “Blue” is paired with 10, and so forth. Then we can use the <code>collect</code>
method to turn that vector of tuples into a <code>HashMap</code> as shown in Listing 8-21:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p><span class="caption">Listing 8-21: Creating a hash map from a list of teams
and a list of scores</span></p>
<p>The type annotation <code>HashMap&lt;_, _&gt;</code> is needed here because it’s possible to
<code>collect</code> into many different data structures, and Rust doesn’t know which you
want unless you specify. For the type parameters for the key and value types,
however, we use underscores, and Rust can infer the types that the hash map
contains based on the types of the data in the vectors.</p>
<a class="header" href="print.html#hash-maps-and-ownership" id="hash-maps-and-ownership"><h3>Hash Maps and Ownership</h3></a>
<p>For types that implement the <code>Copy</code> trait, like <code>i32</code>, the values are copied
into the hash map. For owned values like <code>String</code>, the values will be moved and
the hash map will be the owner of those values as demonstrated in Listing 8-22:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
#}</code></pre></pre>
<p><span class="caption">Listing 8-22: Showing that keys and values are owned by
the hash map once they’re inserted</span></p>
<p>We aren’t able to use the variables <code>field_name</code> and <code>field_value</code> after
they’ve been moved into the hash map with the call to <code>insert</code>.</p>
<p>If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. We’ll talk more about these issues in
the “Validating References with Lifetimes” section in Chapter 10.</p>
<a class="header" href="print.html#accessing-values-in-a-hash-map" id="accessing-values-in-a-hash-map"><h3>Accessing Values in a Hash Map</h3></a>
<p>We can get a value out of the hash map by providing its key to the <code>get</code> method
as shown in Listing 8-23:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p><span class="caption">Listing 8-23: Accessing the score for the Blue team
stored in the hash map</span></p>
<p>Here, <code>score</code> will have the value that’s associated with the Blue team, and the
result will be <code>Some(&amp;10)</code>. The result is wrapped in <code>Some</code> because <code>get</code>
returns an <code>Option&lt;&amp;V&gt;</code>; if there’s no value for that key in the hash map,
<code>get</code> will return <code>None</code>. The program will need to handle the <code>Option</code> in one
of the ways that we covered in Chapter 6.</p>
<p>We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a <code>for</code> loop:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>This code will print each pair in an arbitrary order:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#updating-a-hash-map" id="updating-a-hash-map"><h3>Updating a Hash Map</h3></a>
<p>Although the number of keys and values is growable, each key can only have one
value associated with it at a time. When we want to change the data in a hash
map, we have to decide how to handle the case when a key already has a value
assigned. We could replace the old value with the new value, completely
disregarding the old value. We could keep the old value and ignore the new
value, and only add the new value if the key <em>doesn’t</em> already have a value. Or
we could combine the old value and the new value. Let’s look at how to do each
of these!</p>
<a class="header" href="print.html#overwriting-a-value" id="overwriting-a-value"><h4>Overwriting a Value</h4></a>
<p>If we insert a key and a value into a hash map, and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-24 calls <code>insert</code> twice, the hash map will
only contain one key/value pair because we’re inserting the value for the Blue
team’s key both times:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p><span class="caption">Listing 8-24: Replacing a value stored with a particular
key</span></p>
<p>This code will print <code>{&quot;Blue&quot;: 25}</code>. The original value of <code>10</code> has been
overwritten.</p>
<a class="header" href="print.html#only-insert-if-the-key-has-no-value" id="only-insert-if-the-key-has-no-value"><h4>Only Insert If the Key Has No Value</h4></a>
<p>It’s common to check whether a particular key has a value, and if it doesn’t,
insert a value for it. Hash maps have a special API for this called <code>entry</code>
that takes the key we want to check as a parameter. The return value of the
<code>entry</code> function is an enum called <code>Entry</code> that represents a value that might
or might not exist. Let’s say we want to check whether the key for the Yellow
team has a value associated with it. If it doesn’t, we want to insert the value
50, and the same for the Blue team. Using the <code>entry</code> API, the code looks like
Listing 8-25:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p><span class="caption">Listing 8-25: Using the <code>entry</code> method to only insert if
the key does not already have a value</span></p>
<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return the value for the
corresponding <code>Entry</code> key if that key exists, and if not, inserts the parameter
as the new value for this key and returns the modified <code>Entry</code>. This technique
is much cleaner than writing the logic ourselves, and in addition, plays more
nicely with the borrow checker.</p>
<p>Running the code in Listing 8-25 will print <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. The
first call to <code>entry</code> will insert the key for the Yellow team with the value
<code>50</code> because the Yellow team doesn’t have a value already. The second call to
<code>entry</code> will not change the hash map because the Blue team already has the
value <code>10</code>.</p>
<a class="header" href="print.html#updating-a-value-based-on-the-old-value" id="updating-a-value-based-on-the-old-value"><h4>Updating a Value Based on the Old Value</h4></a>
<p>Another common use case for hash maps is to look up a key’s value and then
update it based on the old value. For instance, Listing 8-26 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times we’ve
seen that word. If it’s the first time we’ve seen a word, we’ll first insert
the value <code>0</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p><span class="caption">Listing 8-26: Counting occurrences of words using a hash
map that stores words and counts</span></p>
<p>This code will print <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. The
<code>or_insert</code> method actually returns a mutable reference (<code>&amp;mut V</code>) to the value
for this key. Here we store that mutable reference in the <code>count</code> variable, so
in order to assign to that value we must first dereference <code>count</code> using the
asterisk (<code>*</code>). The mutable reference goes out of scope at the end of the <code>for</code>
loop, so all of these changes are safe and allowed by the borrowing rules.</p>
<a class="header" href="print.html#hashing-function" id="hashing-function"><h3>Hashing Function</h3></a>
<p>By default, <code>HashMap</code> uses a cryptographically secure hashing function that can
provide resistance to Denial of Service (DoS) attacks. This is not the fastest
hashing algorithm available, but the trade-off for better security that comes
with the drop in performance is worth it. If you profile your code and find
that the default hash function is too slow for your purposes, you can switch to
another function by specifying a different <em>hasher</em>. A hasher is a type that
implements the <code>BuildHasher</code> trait. We’ll talk about traits and how to
implement them in Chapter 10. You don’t necessarily have to implement your own
hasher from scratch; <a href="https://crates.io">crates.io</a> has libraries shared by
other Rust users that provide hashers implementing many common hashing
algorithms.</p>
<a class="header" href="print.html#summary-3" id="summary-3"><h2>Summary</h2></a>
<p>Vectors, strings, and hash maps will provide a large amount of functionality
that you need in programs where you need to store, access, and modify data.
Here are some exercises you should now be equipped to solve:</p>
<ul>
<li>Given a list of integers, use a vector and return the mean (average), median
(when sorted, the value in the middle position), and mode (the value that
occurs most often; a hash map will be helpful here) of the list.</li>
<li>Convert strings to pig latin. The first consonant of each word is moved to
the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words
that start with a vowel have “hay” added to the end instead (“apple” becomes
“apple-hay”). Keep in mind the details about UTF-8 encoding!</li>
<li>Using a hash map and vectors, create a text interface to allow a user to add
employee names to a department in a company. For example, “Add Sally to
Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all
people in a department or all people in the company by department, sorted
alphabetically.</li>
</ul>
<p>The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!</p>
<p>We’re getting into more complex programs in which operations can fail; so, it’s
a perfect time to discuss error handling next!</p>
<a class="header" href="print.html#error-handling" id="error-handling"><h1>Error Handling</h1></a>
<p>Rust’s commitment to reliability extends to error handling. Errors are a fact
of life in software, so Rust has a number of features for handling situations
in which something goes wrong. In many cases, Rust requires you to acknowledge
the possibility of an error occurring and take some action before your code
will compile. This requirement makes your program more robust by ensuring that
you’ll discover errors and handle them appropriately before you’ve deployed
your code to production!</p>
<p>Rust groups errors into two major categories: <em>recoverable</em> and <em>unrecoverable</em>
errors. Recoverable errors are situations in which it’s reasonable to report
the problem to the user and retry the operation, like a file not found error.
Unrecoverable errors are always symptoms of bugs, like trying to access a
location beyond the end of an array.</p>
<p>Most languages don’t distinguish between these two kinds of errors and handle
both in the same way using mechanisms like exceptions. Rust doesn’t have
exceptions. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and
the <code>panic!</code> macro that stops execution when it encounters unrecoverable
errors. This chapter covers calling <code>panic!</code> first and then talks about
returning <code>Result&lt;T, E&gt;</code> values. Additionally, we’ll explore considerations to
take into account when deciding whether to try to recover from an error or to
stop execution.</p>
<a class="header" href="print.html#unrecoverable-errors-with-panic" id="unrecoverable-errors-with-panic"><h2>Unrecoverable Errors with <code>panic!</code></h2></a>
<p>Sometimes, bad things happen in your code, and there’s nothing you can do about
it. In these cases, Rust has the <code>panic!</code> macro. When the <code>panic!</code> macro
executes, your program will print a failure message, unwind and clean up the
stack, and then quit. The most common situation this occurs in is when a bug of
some kind has been detected, and it’s not clear to the programmer how to handle
the error.</p>
<blockquote>
<a class="header" href="print.html#unwinding-the-stack-or-aborting-in-response-to-a-panic" id="unwinding-the-stack-or-aborting-in-response-to-a-panic"><h3>Unwinding the Stack or Aborting in Response to a <code>panic!</code></h3></a>
<p>By default, when a <code>panic!</code> occurs, the program starts <em>unwinding</em>, which
means Rust walks back up the stack and cleans up the data from each function
it encounters. But this walking back and cleanup is a lot of work. The
alternative is to immediately <em>abort</em>, which ends the program without
cleaning up. Memory that the program was using will then need to be cleaned
up by the operating system. If in your project you need to make the resulting
binary as small as possible, you can switch from unwinding to aborting on
panic by adding <code>panic = 'abort'</code> to the appropriate <code>[profile]</code> sections in
your <em>Cargo.toml</em> file. For example, if you want to abort on panic in release
mode, add this:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Let’s try calling <code>panic!</code> in a simple program:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>When you run the program, you’ll see something like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>The call to <code>panic!</code> causes the error message contained in the last three
lines. The first line shows our panic message and the place in our source code
where the panic occurred: <em>src/main.rs:2:4</em> indicates that it’s the second
line, fourth character of our <em>src/main.rs</em> file.</p>
<p>In this case, the line indicated is part of our code, and if we go to that
line, we see the <code>panic!</code> macro call. In other cases, the <code>panic!</code> call might
be in code that our code calls. The filename and line number reported by the
error message will be someone else’s code where the <code>panic!</code> macro is called,
not the line of our code that eventually led to the <code>panic!</code> call. We can use
the backtrace of the functions the <code>panic!</code> call came from to figure out the
part of our code that is causing the problem. We’ll discuss what a backtrace is
in more detail next.</p>
<a class="header" href="print.html#using-a-panic-backtrace" id="using-a-panic-backtrace"><h3>Using a <code>panic!</code> Backtrace</h3></a>
<p>Let’s look at another example to see what it’s like when a <code>panic!</code> call comes
from a library because of a bug in our code instead of from our code calling
the macro directly. Listing 9-1 has some code that attempts to access an
element by index in a vector:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Listing 9-1: Attempting to access an element beyond the
end of a vector, which will cause a <code>panic!</code></span></p>
<p>Here, we’re attempting to access the hundredth element of our vector (which is
at index 99 because indexing starts at zero), but it has only three elements.
In this situation, Rust will panic. Using <code>[]</code> is supposed to return an
element, but if you pass an invalid index, there’s no element that Rust could
return here that would be correct.</p>
<p>Other languages, like C, will attempt to give you exactly what you asked for in
this situation, even though it isn’t what you want: you’ll get whatever is at
the location in memory that would correspond to that element in the vector,
even though the memory doesn’t belong to the vector. This is called a <em>buffer
overread</em> and can lead to security vulnerabilities if an attacker is able to
manipulate the index in such a way as to read data they shouldn’t be allowed to
that is stored after the array.</p>
<p>To protect your program from this sort of vulnerability, if you try to read an
element at an index that doesn’t exist, Rust will stop execution and refuse to
continue. Let’s try it and see:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
99', /checkout/src/liballoc/vec.rs:1555:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>This error points at a file we didn’t write, <em>vec.rs</em>. That’s the
implementation of <code>Vec&lt;T&gt;</code> in the standard library. The code that gets run when
we use <code>[]</code> on our vector <code>v</code> is in <em>vec.rs</em>, and that is where the <code>panic!</code> is
actually happening.</p>
<p>The next note line tells us that we can set the <code>RUST_BACKTRACE</code> environment
variable to get a backtrace of exactly what happened to cause the error. A
<em>backtrace</em> is a list of all the functions that have been called to get to this
point. Backtraces in Rust work like they do in other languages: the key to
reading the backtrace is to start from the top and read until you see files you
wrote. That’s the spot where the problem originated. The lines above the lines
mentioning your files are code that your code called; the lines below are code
that called your code. These lines might include core Rust code, standard
library code, or crates that you’re using. Let’s try getting a backtrace:
Listing 9-2 shows output similar to what you’ll see:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /checkout/src/liballoc/vec.rs:1555:10
stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::_print
             at /checkout/src/libstd/sys_common/backtrace.rs:71
   2: std::panicking::default_hook::{{closure}}
             at /checkout/src/libstd/sys_common/backtrace.rs:60
             at /checkout/src/libstd/panicking.rs:381
   3: std::panicking::default_hook
             at /checkout/src/libstd/panicking.rs:397
   4: std::panicking::rust_panic_with_hook
             at /checkout/src/libstd/panicking.rs:611
   5: std::panicking::begin_panic
             at /checkout/src/libstd/panicking.rs:572
   6: std::panicking::begin_panic_fmt
             at /checkout/src/libstd/panicking.rs:522
   7: rust_begin_unwind
             at /checkout/src/libstd/panicking.rs:498
   8: core::panicking::panic_fmt
             at /checkout/src/libcore/panicking.rs:71
   9: core::panicking::panic_bounds_check
             at /checkout/src/libcore/panicking.rs:58
  10: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;usize&gt;&gt;::index
             at /checkout/src/liballoc/vec.rs:1555
  11: panic::main
             at src/main.rs:4
  12: __rust_maybe_catch_panic
             at /checkout/src/libpanic_unwind/lib.rs:99
  13: std::rt::lang_start
             at /checkout/src/libstd/panicking.rs:459
             at /checkout/src/libstd/panic.rs:361
             at /checkout/src/libstd/rt.rs:61
  14: main
  15: __libc_start_main
  16: &lt;unknown&gt;
</code></pre>
<p><span class="caption">Listing 9-2: The backtrace generated by a call to
<code>panic!</code> displayed when the environment variable <code>RUST_BACKTRACE</code> is set</span></p>
<p>That’s a lot of output! The exact output you see might be different depending
on your operating system and Rust version. In order to get backtraces with this
information, debug symbols must be enabled. Debug symbols are enabled by
default when using cargo build or cargo run without the --release flag, as we
have here.</p>
<p>In the output in Listing 9-2, line 11 of the backtrace points to the line in
our project that’s causing the problem: <em>src/main.rs</em> in line 4. If we don’t
want our program to panic, the location pointed to by the first line mentioning
a file we wrote is where we should start investigating to figure out how we got
to this location with values that caused the panic. In Listing 9-1 where we
deliberately wrote code that would panic in order to demonstrate how to use
backtraces, the way to fix the panic is to not request an element at index 99
from a vector that only contains three items. When your code panics in the
future, you’ll need to figure out what action the code is taking with what
values that causes the panic and what the code should do instead.</p>
<p>We’ll come back to <code>panic!</code> and when we should and should not use <code>panic!</code> to
handle error conditions later in the chapter. Next, we’ll look at how to
recover from an error using <code>Result</code>.</p>
<a class="header" href="print.html#recoverable-errors-with-result" id="recoverable-errors-with-result"><h2>Recoverable Errors with <code>Result</code></h2></a>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes, when a function fails, it’s for a reason that we can easily
interpret and respond to. For example, if we try to open a file and that
operation fails because the file doesn’t exist, we might want to create the
file instead of terminating the process.</p>
<p>Recall from “<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">Handling Potential Failure with the <code>Result</code>
Type</a><!-- ignore -->” in Chapter 2 that the <code>Result</code> enum is
defined as having two variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>The <code>T</code> and <code>E</code> are generic type parameters: we’ll discuss generics in more
detail in Chapter 10. What you need to know right now is that <code>T</code> represents
the type of the value that will be returned in a success case within the <code>Ok</code>
variant, and <code>E</code> represents the type of the error that will be returned in a
failure case within the <code>Err</code> variant. Because <code>Result</code> has these generic type
parameters, we can use the <code>Result</code> type and the functions that the standard
library has defined on it in many different situations where the successful
value and error value we want to return may differ.</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could
fail: in Listing 9-3 we try to open a file:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 9-3: Opening a file</span></p>
<p>How do we know <code>File::open</code> returns a <code>Result</code>? We could look at the standard
library API documentation, or we could ask the compiler! If we give <code>f</code> a type
annotation of a type that we know the return type of the function is <em>not</em> and
then we try to compile the code, the compiler will tell us that the types don’t
match. The error message will then tell us what the type of <code>f</code> <em>is</em>. Let’s try
it: we know that the return type of <code>File::open</code> isn’t of type <code>u32</code>, so let’s
change the <code>let f</code> statement to this:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Attempting to compile now gives us the following output:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>This tells us the return type of the <code>File::open</code> function is a <code>Result&lt;T, E&gt;</code>.
The generic parameter <code>T</code> has been filled in here with the type of the success
value, <code>std::fs::File</code>, which is a file handle. The type of <code>E</code> used in the
error value is <code>std::io::Error</code>.</p>
<p>This return type means the call to <code>File::open</code> might succeed and return to us
a file handle that we can read from or write to. The function call also might
fail: for example, the file might not exist or we might not have permission to
access the file. The <code>File::open</code> function needs to have a way to tell us
whether it succeeded or failed and at the same time give us either the file
handle or error information. This information is exactly what the <code>Result</code> enum
conveys.</p>
<p>In the case where <code>File::open</code> succeeds, the value we will have in the variable
<code>f</code> will be an instance of <code>Ok</code> that contains a file handle. In the case where
it fails, the value in <code>f</code> will be an instance of <code>Err</code> that contains more
information about the kind of error that happened.</p>
<p>We need to add to the code in Listing 9-3 to take different actions depending
on the value <code>File::open</code> returned. Listing 9-4 shows one way to handle the
<code>Result</code> using a basic tool: the <code>match</code> expression that we discussed in
Chapter 6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listing 9-4: Using a <code>match</code> expression to handle the
<code>Result</code> variants we might have</span></p>
<p>Note that, like the <code>Option</code> enum, the <code>Result</code> enum and its variants have been
imported in the prelude, so we don’t need to specify <code>Result::</code> before the <code>Ok</code>
and <code>Err</code> variants in the <code>match</code> arms.</p>
<p>Here we tell Rust that when the result is <code>Ok</code>, return the inner <code>file</code> value
out of the <code>Ok</code> variant, and we then assign that file handle value to the
variable <code>f</code>. After the <code>match</code>, we can then use the file handle for reading or
writing.</p>
<p>The other arm of the <code>match</code> handles the case where we get an <code>Err</code> value from
<code>File::open</code>. In this example, we’ve chosen to call the <code>panic!</code> macro. If
there’s no file named <em>hello.txt</em> in our current directory and we run this
code, we’ll see the following output from the <code>panic!</code> macro:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
</code></pre>
<p>As usual, this output tells us exactly what has gone wrong.</p>
<a class="header" href="print.html#matching-on-different-errors" id="matching-on-different-errors"><h3>Matching on Different Errors</h3></a>
<p>The code in Listing 9-4 will <code>panic!</code> no matter the reason that <code>File::open</code>
failed. What we want to do instead is take different actions for different
failure reasons: if <code>File::open</code> failed because the file doesn’t exist, we want
to create the file and return the handle to the new file. If <code>File::open</code>
failed for any other reason, for example because we didn’t have permission to
open the file, we still want the code to <code>panic!</code> in the same way as it did in
Listing 9-4. Look at Listing 9-5, which adds another arm to the <code>match</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listing 9-5: Handling different kinds of errors in
different ways</span></p>
<p>The type of the value that <code>File::open</code> returns inside the <code>Err</code> variant is
<code>io::Error</code>, which is a struct provided by the standard library. This struct
has a method <code>kind</code> that we can call to get an <code>io::ErrorKind</code> value.
<code>io::ErrorKind</code> is an enum provided by the standard library that has variants
representing the different kinds of errors that might result from an <code>io</code>
operation. The variant we want to use is <code>ErrorKind::NotFound</code>, which indicates
the file we’re trying to open doesn’t exist yet.</p>
<p>The condition <code>if error.kind() == ErrorKind::NotFound</code> is called a <em>match
guard</em>: it’s an extra condition on a <code>match</code> arm that further refines the arm’s
pattern. This condition must be true for that arm’s code to be run; otherwise,
the pattern matching will move on to consider the next arm in the <code>match</code>. The
<code>ref</code> in the pattern is needed so <code>error</code> is not moved into the guard condition
but is merely referenced by it. The reason <code>ref</code> is used to take a reference in
a pattern instead of <code>&amp;</code> will be covered in detail in Chapter 18. In short, in
the context of a pattern, <code>&amp;</code> matches a reference and gives us its value, but
<code>ref</code> matches a value and gives us a reference to it.</p>
<p>The condition we want to check in the match guard is whether the value returned
by <code>error.kind()</code> is the <code>NotFound</code> variant of the <code>ErrorKind</code> enum. If it is,
we try to create the file with <code>File::create</code>. However, because <code>File::create</code>
could also fail, we need to add an inner <code>match</code> statement as well. When the
file can’t be opened, a different error message will be printed. The last arm
of the outer <code>match</code> stays the same so the program panics on any error besides
the missing file error.</p>
<a class="header" href="print.html#shortcuts-for-panic-on-error-unwrap-and-expect" id="shortcuts-for-panic-on-error-unwrap-and-expect"><h3>Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code></h3></a>
<p>Using <code>match</code> works well enough, but it can be a bit verbose and doesn’t always
communicate intent well. The <code>Result&lt;T, E&gt;</code> type has many helper methods
defined on it to do various tasks. One of those methods, called <code>unwrap</code>, is a
shortcut method that is implemented just like the <code>match</code> statement we wrote in
Listing 9-4. If the <code>Result</code> value is the <code>Ok</code> variant, <code>unwrap</code> will return
the value inside the <code>Ok</code>. If the <code>Result</code> is the <code>Err</code> variant, <code>unwrap</code> will
call the <code>panic!</code> macro for us. Here is an example of <code>unwrap</code> in action:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>If we run this code without a <em>hello.txt</em> file, we’ll see an error message from
the <code>panic!</code> call that the <code>unwrap</code> method makes:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Another method, <code>expect</code>, which is similar to <code>unwrap</code>, lets us also choose the
<code>panic!</code> error message. Using <code>expect</code> instead of <code>unwrap</code> and providing good
error messages can convey your intent and make tracking down the source of a
panic easier. The syntax of <code>expect</code> looks like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p>We use <code>expect</code> in the same way as <code>unwrap</code>: to return the file handle or call
the <code>panic!</code> macro. The error message used by <code>expect</code> in its call to <code>panic!</code>
will be the parameter that we pass to <code>expect</code>, rather than the default
<code>panic!</code> message that <code>unwrap</code> uses. Here’s what it looks like:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<p>Because this error message starts with the text we specified, <code>Failed to open hello.txt</code>, it will be easier to find where in the code this error message is
coming from. If we use <code>unwrap</code> in multiple places, it can take more time to
figure out exactly which <code>unwrap</code> is causing the panic because all <code>unwrap</code>
calls that panic print the same message.</p>
<a class="header" href="print.html#propagating-errors" id="propagating-errors"><h3>Propagating Errors</h3></a>
<p>When you’re writing a function whose implementation calls something that might
fail, instead of handling the error within this function, you can return the
error to the calling code so that it can decide what to do. This is known as
<em>propagating</em> the error and gives more control to the calling code where there
might be more information or logic that dictates how the error should be
handled than what you have available in the context of your code.</p>
<p>For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn’t exist or can’t be read, this function will return those errors
to the code that called this function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-6: A function that returns errors to the
calling code using <code>match</code></span></p>
<p>Let’s look at the return type of the function first: <code>Result&lt;String, io::Error&gt;</code>. This means the function is returning a value of the type
<code>Result&lt;T, E&gt;</code> where the generic parameter <code>T</code> has been filled in with the
concrete type <code>String</code>, and the generic type <code>E</code> has been filled in with the
concrete type <code>io::Error</code>. If this function succeeds without any problems, the
code that calls this function will receive an <code>Ok</code> value that holds a
<code>String</code>—the username that this function read from the file. If this function
encounters any problems, the code that calls this function will receive an
<code>Err</code> value that holds an instance of <code>io::Error</code> that contains more
information about what the problems were. We chose <code>io::Error</code> as the return
type of this function because that happens to be the type of the error value
returned from both of the operations we’re calling in this function’s body that
might fail: the <code>File::open</code> function and the <code>read_to_string</code> method.</p>
<p>The body of the function starts by calling the <code>File::open</code> function. Then we
handle the <code>Result</code> value returned with a <code>match</code> similar to the <code>match</code> in
Listing 9-4, only instead of calling <code>panic!</code> in the <code>Err</code> case, we return
early from this function and pass the error value from <code>File::open</code> back to the
calling code as this function’s error value. If <code>File::open</code> succeeds, we store
the file handle in the variable <code>f</code> and continue.</p>
<p>Then we create a new <code>String</code> in variable <code>s</code> and call the <code>read_to_string</code>
method on the file handle in <code>f</code> to read the contents of the file into <code>s</code>. The
<code>read_to_string</code> method also returns a <code>Result</code> because it might fail, even
though <code>File::open</code> succeeded. So we need another <code>match</code> to handle that
<code>Result</code>: if <code>read_to_string</code> succeeds, then our function has succeeded, and we
return the username from the file that’s now in <code>s</code> wrapped in an <code>Ok</code>. If
<code>read_to_string</code> fails, we return the error value in the same way that we
returned the error value in the <code>match</code> that handled the return value of
<code>File::open</code>. However, we don’t need to explicitly say <code>return</code>, because this
is the last expression in the function.</p>
<p>The code that calls this code will then handle getting either an <code>Ok</code> value
that contains a username or an <code>Err</code> value that contains an <code>io::Error</code>. We
don’t know what the calling code will do with those values. If the calling code
gets an <code>Err</code> value, it could call <code>panic!</code> and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don’t have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upwards for
it to handle appropriately.</p>
<p>This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator <code>?</code> to make this easier.</p>
<a class="header" href="print.html#a-shortcut-for-propagating-errors-" id="a-shortcut-for-propagating-errors-"><h4>A Shortcut for Propagating Errors: <code>?</code></h4></a>
<p>Listing 9-7 shows an implementation of <code>read_username_from_file</code> that has the
same functionality as it had in Listing 9-6, but this implementation uses the
question mark operator:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-7: A function that returns errors to the
calling code using <code>?</code></span></p>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way
as the <code>match</code> expressions we defined to handle the <code>Result</code> values in Listing
9-6. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code> will
get returned from this expression and the program will continue. If the value
is an <code>Err</code>, the value inside the <code>Err</code> will be returned from the whole
function as if we had used the <code>return</code> keyword so the error value gets
propagated to the calling code.</p>
<p>There is a difference between what the <code>match</code> expression from Listing 9-6 and
the question mark operator do: error values used with <code>?</code> go through the <code>from</code>
function, defined in the <code>From</code> trait in the standard library, which is used to
convert errors from one type into another. When the question mark calls the
<code>from</code> function, the error type received is converted into the error type
defined in the return type of the current function. This is useful when a
function returns one error type to represent all the ways a function might
fail, even if parts might fail for many different reasons. As long as each
error type implements the <code>from</code> function to define how to convert itself to
the returned error type, the question mark operator takes care of the
conversion automatically.</p>
<p>In the context of Listing 9-7, the <code>?</code> at the end of the <code>File::open</code> call will
return the value inside an <code>Ok</code> to the variable <code>f</code>. If an error occurs, <code>?</code>
will return early out of the whole function and give any <code>Err</code> value to the
calling code. The same thing applies to the <code>?</code> at the end of the
<code>read_to_string</code> call.</p>
<p>The <code>?</code> eliminates a lot of boilerplate and makes this function’s
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the <code>?</code> as shown in Listing 9-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-8: Chaining method calls after the question
mark operator</span></p>
<p>We’ve moved the creation of the new <code>String</code> in <code>s</code> to the beginning of the
function; that part hasn’t changed. Instead of creating a variable <code>f</code>, we’ve
chained the call to <code>read_to_string</code> directly onto the result of
<code>File::open(&quot;hello.txt&quot;)?</code>. We still have a <code>?</code> at the end of the
<code>read_to_string</code> call, and we still return an <code>Ok</code> value containing the
username in <code>s</code> when both <code>File::open</code> and <code>read_to_string</code> succeed rather than
returning errors. The functionality is again the same as in Listing 9-6 and
Listing 9-7; this is just a different, more ergonomic way to write it.</p>
<a class="header" href="print.html#-can-only-be-used-in-functions-that-return-result" id="-can-only-be-used-in-functions-that-return-result"><h4><code>?</code> Can Only Be Used in Functions That Return Result</h4></a>
<p>The <code>?</code> can only be used in functions that have a return type of <code>Result</code>,
because it is defined to work in the same way as the <code>match</code> expression we
defined in Listing 9-6. The part of the <code>match</code> that requires a return type of
<code>Result</code> is <code>return Err(e)</code>, so the return type of the function must be a
<code>Result</code> to be compatible with this <code>return</code>.</p>
<p>Let’s look at what happens if we use <code>?</code> in the <code>main</code> function, which you’ll
recall has a return type of <code>()</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>When we compile this code, we get the following error message:</p>
<pre><code class="language-text">error[E0277]: the trait bound `(): std::ops::Try` is not satisfied
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             the `?` operator can only be used in a function that returns
  `Result` (or another type that implements `std::ops::Try`)
  |             in this macro invocation
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>This error points out that we’re only allowed to use the question mark operator
in a function that returns <code>Result</code>. In functions that don’t return <code>Result</code>,
when you call other functions that return <code>Result</code>, you’ll need to use a
<code>match</code> or one of the <code>Result</code> methods to handle it instead of using <code>?</code> to
potentially propagate the error to the calling code.</p>
<p>Now that we’ve discussed the details of calling <code>panic!</code> or returning <code>Result</code>,
let’s return to the topic of how to decide which is appropriate to use in which
cases.</p>
<a class="header" href="print.html#to-panic-or-not-to-panic" id="to-panic-or-not-to-panic"><h2>To <code>panic!</code> or Not to <code>panic!</code></h2></a>
<p>So how do you decide when you should <code>panic!</code> and when you should return
<code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code>
for any error situation, whether there’s a possible way to recover or not, but
then you’re making the decision on behalf of the code calling your code that a
situation is unrecoverable. When you choose to return a <code>Result</code> value, you
give the calling code options rather than making the decision for it. The
calling code could choose to attempt to recover in a way that’s appropriate for
its situation, or it could decide that an <code>Err</code> value in this case is
unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an
unrecoverable one. Therefore, returning <code>Result</code> is a good default choice when
you’re defining a function that might fail.</p>
<p>In a few situations it’s more appropriate to write code that panics instead of
returning a <code>Result</code>, but they are less common. Let’s explore why it’s
appropriate to panic in examples, prototype code, and tests; then in situations
where you as a human can know a method won’t fail that the compiler can’t
reason about; and conclude with some general guidelines on how to decide
whether to panic in library code.</p>
<a class="header" href="print.html#examples-prototype-code-and-tests-are-all-places-its-perfectly-fine-to-panic" id="examples-prototype-code-and-tests-are-all-places-its-perfectly-fine-to-panic"><h3>Examples, Prototype Code, and Tests Are All Places it’s Perfectly Fine to Panic</h3></a>
<p>When you’re writing an example to illustrate some concept, having robust error
handling code in the example as well can make the example less clear. In
examples, it’s understood that a call to a method like <code>unwrap</code> that could
<code>panic!</code> is meant as a placeholder for the way that you’d want your application
to handle errors, which can differ based on what the rest of your code is doing.</p>
<p>Similarly, the <code>unwrap</code> and <code>expect</code> methods are very handy when prototyping,
before you’re ready to decide how to handle errors. They leave clear markers in
your code for when you’re ready to make your program more robust.</p>
<p>If a method call fails in a test, we’d want the whole test to fail, even if
that method isn’t the functionality under test. Because <code>panic!</code> is how a test
is marked as a failure, calling <code>unwrap</code> or <code>expect</code> is exactly what should
happen.</p>
<a class="header" href="print.html#cases-when-you-have-more-information-than-the-compiler" id="cases-when-you-have-more-information-than-the-compiler"><h3>Cases When You Have More Information Than the Compiler</h3></a>
<p>It would also be appropriate to call <code>unwrap</code> when you have some other logic
that ensures the <code>Result</code> will have an <code>Ok</code> value, but the logic isn’t
something the compiler understands. You’ll still have a <code>Result</code> value that you
need to handle: whatever operation you’re calling still has the possibility of
failing in general, even though it’s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you’ll never
have an <code>Err</code> variant, it’s perfectly acceptable to call <code>unwrap</code>. Here’s an
example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
#}</code></pre></pre>
<p>We’re creating an <code>IpAddr</code> instance by parsing a hardcoded string. We can see
that <code>127.0.0.1</code> is a valid IP address, so it’s acceptable to use <code>unwrap</code>
here. However, having a hardcoded, valid string doesn’t change the return type
of the <code>parse</code> method: we still get a <code>Result</code> value, and the compiler will
still make us handle the <code>Result</code> as if the <code>Err</code> variant is still a
possibility because the compiler isn’t smart enough to see that this string is
always a valid IP address. If the IP address string came from a user rather
than being hardcoded into the program, and therefore <em>did</em> have a possibility
of failure, we’d definitely want to handle the <code>Result</code> in a more robust way
instead.</p>
<a class="header" href="print.html#guidelines-for-error-handling" id="guidelines-for-error-handling"><h3>Guidelines for Error Handling</h3></a>
<p>It’s advisable to have your code <code>panic!</code> when it’s possible that your code
could end up in a bad state. In this context, bad state is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
code—plus one or more of the following:</p>
<ul>
<li>The bad state is not something that’s <em>expected</em> to happen occasionally.</li>
<li>Your code after this point needs to rely on not being in this bad state.</li>
<li>There’s not a good way to encode this information in the types you use.</li>
</ul>
<p>If someone calls your code and passes in values that don’t make sense, the best
choice might be to <code>panic!</code> and alert the person using your library to the bug
in their code so they can fix it during development. Similarly, <code>panic!</code> is
often appropriate if you’re calling external code that is out of your control,
and it returns an invalid state that you have no way of fixing.</p>
<p>When a bad state is reached, but it’s expected to happen no matter how well you
write your code, it’s still more appropriate to return a <code>Result</code> rather than
making a <code>panic!</code> call. Examples of this include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, you should indicate that failure is an expected
possibility by returning a <code>Result</code> to propagate these bad states upwards so
the calling code can decide how to handle the problem. To <code>panic!</code> wouldn’t be
the best way to handle these cases.</p>
<p>When your code performs operations on values, your code should verify the
values are valid first, and <code>panic!</code> if the values aren’t valid. This is mostly
for safety reasons: attempting to operate on invalid data can expose your code
to vulnerabilities. This is the main reason the standard library will <code>panic!</code>
if you attempt an out-of-bounds memory access: trying to access memory that
doesn’t belong to the current data structure is a common security problem.
Functions often have <em>contracts</em>: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug,
and it’s not a kind of error you want the calling code to have to explicitly
handle. In fact, there’s no reasonable way for calling code to recover: the
calling <em>programmers</em> need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.</p>
<p>However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust’s type system (and thus the type
checking the compiler does) to do many of the checks for you. If your function
has a particular type as a parameter, you can proceed with your code’s logic
knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an <code>Option</code>, your program expects to
have <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have to handle
two cases for the <code>Some</code> and <code>None</code> variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won’t
even compile, so your function doesn’t have to check for that case at runtime.
Another example is using an unsigned integer type like <code>u32</code>, which ensures the
parameter is never negative.</p>
<a class="header" href="print.html#creating-custom-types-for-validation" id="creating-custom-types-for-validation"><h3>Creating Custom Types for Validation</h3></a>
<p>Let’s take the idea of using Rust’s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 where our code asked the user to guess a number
between 1 and 100. We never validated that the user’s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of “Too high” or “Too low” would still be correct. It would be a useful
enhancement to guide the user toward valid guesses and have different behavior
when a user guesses a number that’s out of range versus when a user types, for
example, letters instead.</p>
<p>One way to do this would be to parse the guess as an <code>i32</code> instead of only a
<code>u32</code> to allow potentially negative numbers, and then add a check for the
number being in range, like so:</p>
<pre><code class="language-rust ignore">loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // --snip--
}
</code></pre>
<p>The <code>if</code> expression checks whether our value is out of range, tells the user
about the problem, and calls <code>continue</code> to start the next iteration of the loop
and ask for another guess. After the <code>if</code> expression, we can proceed with the
comparisons between <code>guess</code> and the secret number knowing that <code>guess</code> is
between 1 and 100.</p>
<p>However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, it would be tedious (and potentially impact performance)
to have a check like this in every function.</p>
<p>Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, it’s safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-9 shows one way to define a
<code>Guess</code> type that will only create an instance of <code>Guess</code> if the <code>new</code> function
receives a value between 1 and 100:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-9: A <code>Guess</code> type that will only continue with
values between 1 and 100</span></p>
<p>First, we define a struct named <code>Guess</code> that has a field named <code>value</code> that
holds a <code>u32</code>. This is where the number will be stored.</p>
<p>Then we implement an associated function named <code>new</code> on <code>Guess</code> that creates
instances of <code>Guess</code> values. The <code>new</code> function is defined to have one
parameter named <code>value</code> of type <code>u32</code> and to return a <code>Guess</code>. The code in the
body of the <code>new</code> function tests <code>value</code> to make sure it’s between 1 and 100.
If <code>value</code> doesn’t pass this test, we make a <code>panic!</code> call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would
violate the contract that <code>Guess::new</code> is relying on. The conditions in which
<code>Guess::new</code> might panic should be discussed in its public-facing API
documentation; we’ll cover documentation conventions indicating the possibility
of a <code>panic!</code> in the API documentation that you create in Chapter 14. If
<code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set
to the <code>value</code> parameter and return the <code>Guess</code>.</p>
<p>Next, we implement a method named <code>value</code> that borrows <code>self</code>, doesn’t have any
other parameters, and returns a <code>u32</code>. This is a kind of method sometimes
called a <em>getter</em>, because its purpose is to get some data from its fields and
return it. This public method is necessary because the <code>value</code> field of the
<code>Guess</code> struct is private. It’s important that the <code>value</code> field is private so
code using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: code
outside the module <em>must</em> use the <code>Guess::new</code> function to create an instance
of <code>Guess</code>, which ensures there’s no way for a <code>Guess</code> to have a <code>value</code> that
hasn’t been checked by the conditions in the <code>Guess::new</code> function.</p>
<p>A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a <code>Guess</code> rather than a
<code>u32</code> and wouldn’t need to do any additional checks in its body.</p>
<a class="header" href="print.html#summary-4" id="summary-4"><h2>Summary</h2></a>
<p>Rust’s error handling features are designed to help you write more robust code.
The <code>panic!</code> macro signals that your program is in a state it can’t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The <code>Result</code> enum uses Rust’s type system to indicate that
operations might fail in a way that your code could recover from. You can use
<code>Result</code> to tell code that calls your code that it needs to handle potential
success or failure as well. Using <code>panic!</code> and <code>Result</code> in the appropriate
situations will make your code more reliable in the face of inevitable problems.</p>
<p>Now that you’ve seen useful ways that the standard library uses generics with
the <code>Option</code> and <code>Result</code> enums, we’ll talk about how generics work and how you
can use them in your code in the next chapter.</p>
<a class="header" href="print.html#generic-types-traits-and-lifetimes" id="generic-types-traits-and-lifetimes"><h1>Generic Types, Traits, and Lifetimes</h1></a>
<p>Every programming language has tools for dealing effectively with duplication
of concepts. In Rust, one such tool is <em>generics</em>. Generics are abstract
stand-ins for concrete types or other properties. When we’re writing code, we
can express generics’ behavior or how they relate to other generics without
knowing what will actually be in their place when compiling and running the
code.</p>
<p>Similar to the way a function takes parameters with unknown values to run the
same code on multiple concrete values, functions can take parameters of some
generic type instead of a concrete type like <code>i32</code> or <code>String</code>. In fact, we’ve
already used generics in Chapter 6 with <code>Option&lt;T&gt;</code>, Chapter 8 with <code>Vec&lt;T&gt;</code>
and <code>HashMap&lt;K, V&gt;</code>, and Chapter 9 with <code>Result&lt;T, E&gt;</code>. In this chapter, you’ll
explore how to define your own types, functions, and methods with generics!</p>
<p>First, we’ll review how to extract a function to reduce code duplication. Then
we’ll use the same technique to make a generic function out of two functions
that only differ in the types of their parameters. We’ll go over how to use
generic types in struct and enum definitions too.</p>
<p>After that, you’ll learn how to use <em>traits</em> to define behavior in a generic
way. You can then combine traits with generic types to constrain a generic type
to only those types that have a particular behavior, as opposed to just any
type.</p>
<p>Finally, we’ll discuss <em>lifetimes</em>, a variety of generics that give the
compiler information about how references are related to each other. Lifetimes
allow us to borrow values in many situations while still enabling the compiler
to check that the references are valid.</p>
<a class="header" href="print.html#removing-duplication-by-extracting-a-function" id="removing-duplication-by-extracting-a-function"><h2>Removing Duplication by Extracting a Function</h2></a>
<p>Before diving into generics syntax, let’s first review how to remove
duplication that doesn’t involve generic types by extracting a function. Then,
we’ll apply this technique to extract a generic function! In the same way that
you recognize duplicated code to extract into a function, you’ll start to
recognize duplicated code that can use generics.</p>
<p>Consider a small program that finds the largest number in a list, as shown in
Listing 10-1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
#  assert_eq!(largest, 100);
}
</code></pre></pre>
<p><span class="caption">Listing 10-1: Code to find the largest number in a list
of numbers</span></p>
<p>This code stores a list of integers in the variable <code>number_list</code> and places
the first number in the list in a variable named <code>largest</code>. Then it iterates
through all the numbers in the list, and if the current number is greater than
the number stored in <code>largest</code>, it replaces the number in that variable. If the
current number is smaller than the largest number seen so far, however, the
variable doesn’t change and the code moves on to the next number in the list.
After all the numbers in the list have been considered, <code>largest</code> should hold
the largest number, which in this case is 100.</p>
<p>To find the largest number in two different lists of numbers, we can duplicate
the code in Listing 10-1 and use the same logic at two different places in the
program, as in Listing 10-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Listing 10-2: Code to find the largest number in <em>two</em>
lists of numbers</span></p>
<p>While this code works, duplicating code is tedious and error-prone. It also
means that we have to update the code in multiple places to change it.</p>
<p>To eliminate this duplication, we can create an abstraction by defining a
function that operates on any list of integers given to it in a parameter. This
makes our code clearer and lets us express the concept of finding the largest
number in a list abstractly.</p>
<p>In Listing 10-3, we’ve extracted the code that finds the largest number into a
function named <code>largest</code>. Unlike the code in Listing 10-1, which can find the
largest number in only one particular list, this program can find the largest
number in two different lists:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 6000);
}
</code></pre></pre>
<p><span class="caption">Listing 10-3: Abstracted code to find the largest number
in two lists</span></p>
<p>The <code>largest</code> function has a parameter called <code>list</code>, which represents any
concrete slice of <code>i32</code> values that we might pass into the function. This means
that when we call the function, the code runs on the specific values that we
pass in.</p>
<p>In sum, here are the steps we used to get from Listing 10-2 to Listing 10-3:</p>
<ol>
<li>Identify duplicate code.</li>
<li>Extract the duplicate code into the body of the function, and specify the
inputs and return values of that code in the function signature.</li>
<li>Update the two instances of duplicated code to call the function instead.</li>
</ol>
<p>Next, we’ll use these same steps with generics to reduce code duplication in
different ways. In the same way that the function body can operate on an
abstract <code>list</code> instead of specific values, generics allow code to operate on
abstract types.</p>
<p>For example, say we had two functions: one that finds the largest item in a
slice of <code>i32</code> values and one that finds the largest item in a slice of <code>char</code>
values. How would we get rid of that duplication? Let’s find out!</p>
<a class="header" href="print.html#generic-data-types" id="generic-data-types"><h2>Generic Data Types</h2></a>
<p>We can use generics to create definitions for items like function signatures or
structs that can then be used with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.</p>
<a class="header" href="print.html#in-function-definitions" id="in-function-definitions"><h3>In Function Definitions</h3></a>
<p>When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. This makes our code more flexible and provides
more functionality to callers of our function, while preventing code
duplication.</p>
<p>Continuing with our <code>largest</code> function, Listing 10-4 shows two functions that
both find the largest value in a slice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
#    assert_eq!(result, 'y');
}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span></p>
<p>The <code>largest_i32</code> function is the one we extracted in Listing 10-3 that finds
the largest <code>i32</code> in a slice. The <code>largest_char</code> function finds the largest
<code>char</code> in a slice. The function bodies have the exact same code, so let’s get
rid of the duplication by introducing a generic type parameter in a single
function.</p>
<p>To parameterize the types in the new function we’re going to define, we need to
name the type parameter, just like we do for the value parameters to a
function. You can use any identifier as a type parameter name, but we’ll using
<code>T</code> because, by convention, parameter names in Rust tend to be short, often
just a letter, and Rust’s type naming convention is CamelCase. Short for
“type”, <code>T</code> is the default choice of most Rust programmers.</p>
<p>When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so that the compiler knows what that name
means. Similarly, when we use a type parameter name in a function signature, we
have to declare the type parameter name before we use it. To define the generic
<code>largest</code> function, place type name declarations inside angle brackets (<code>&lt;&gt;</code>)
between the name of the function and the parameter list, like this:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>We read this as: the function <code>largest</code> is generic over some type <code>T</code>. This
function has one parameter named <code>list</code>, which is a slice of values of type
<code>T</code>. The <code>largest</code> function will return a value of the same type <code>T</code>.</p>
<p>Listing 10-5 shows the combined <code>largest</code> function definition using the generic
data type in its signature, and shows how we can call the function with either
a slice of <code>i32</code> values or <code>char</code> values. Note that this code won’t compile yet
but we’ll fix it later in this chapter!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-5: A definition of the <code>largest</code> function that
uses generic type parameters but doesn’t compile yet</span></p>
<p>If we compile this code right now, we’ll get this error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>The note mentions <code>std::cmp::PartialOrd</code>, which is a <em>trait</em>. We’re going to
talk about traits in the next section. For now, this error is saying that the
body of <code>largest</code> won’t work for all possible types that <code>T</code> could be. Because
we want to compare values of type <code>T</code> in the body, we can only use types whose
values can be ordered. To enable comparisons, the standard library has the
<code>std::cmp::PartialOrd</code> trait that you can implement on types (see Appendix C,
“Derivable Traits,” for more on this trait). You’ll learn how to specify that a
generic type has a particular trait in the “Trait Bounds” section, but let’s
first explore other ways of using generic type parameters.</p>
<a class="header" href="print.html#in-struct-definitions" id="in-struct-definitions"><h3>In Struct Definitions</h3></a>
<p>We can also define structs to use a generic type parameter in one or more
fields using the <code>&lt;&gt;</code> syntax. Listing 10-6 shows how to define a <code>Point&lt;T&gt;</code>
struct to hold <code>x</code> and <code>y</code> coordinate values of any type:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-6: A <code>Point&lt;T&gt;</code> struct that holds <code>x</code> and <code>y</code>
values of type <code>T</code></span></p>
<p>The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.</p>
<p>Note that because we’ve only used one generic type to define <code>Point&lt;T&gt;</code>, this
says that the <code>Point&lt;T&gt;</code> struct is generic over some type <code>T</code>, and the fields
<code>x</code> and <code>y</code> are <em>both</em> that same type, whatever that type may be. This means
that if we create an instance of a <code>Point&lt;T&gt;</code> that has values of different
types, as in Listing 10-7, our code won’t compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listing 10-7: The fields <code>x</code> and <code>y</code> must be the same
type because both have the same generic data type <code>T</code></span></p>
<p>In this example, when we assign the integer value 5 to <code>x</code>, we let the compiler
know that the generic type <code>T</code> will be an integer for this instance of
<code>Point&lt;T&gt;</code>. Then when we specify 4.0 for <code>y</code>, which we’ve defined to have the
same type as <code>x</code>, we will get a type mismatch error like this:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<p>To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics, but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of <code>Point</code> to be generic over types
<code>T</code> and <code>U</code> where <code>x</code> is of type <code>T</code> and <code>y</code> is of type <code>U</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-8: A <code>Point&lt;T, U&gt;</code> generic over two types so
that <code>x</code> and <code>y</code> may be values of different types</span></p>
<p>Now all the instances of <code>Point</code> shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you find yourself needing lots of generic types,
it may indicate that your code needs restructuring into smaller pieces.</p>
<a class="header" href="print.html#in-enum-definitions" id="in-enum-definitions"><h3>In Enum Definitions</h3></a>
<p>Like we did with structs, we can define enums to hold generic data types in
their variants. Let’s take another look at the <code>Option&lt;T&gt;</code> enum provided by the
standard library we used in Chapter 6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>This definition should now make more sense to you. As you can see, <code>Option&lt;T&gt;</code>
is an enum that is generic over type <code>T</code> and has two variants: <code>Some</code>, that
holds one value of type <code>T</code>, and a <code>None</code> variant that doesn’t hold any value.
By using the <code>Option&lt;T&gt;</code> enum, we can express the abstract concept of having an
optional value, and because <code>Option&lt;T&gt;</code> is generic, we can use this abstraction
no matter what the type of the optional value is.</p>
<p>Enums can use multiple generic types as well. The definition of the <code>Result</code>
enum that we used in Chapter 9 is one example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>The <code>Result</code> enum is generic over two types, <code>T</code> and <code>E</code>, and has two variants:
<code>Ok</code>, which holds a value of type <code>T</code>, and <code>Err</code>, which holds a value of type
<code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we
have an operation that might succeed (return a value of some type <code>T</code>) or fail
(return an error of some type <code>E</code>). In fact, this is what we used to open a
file in Listing 9-3 where <code>T</code> was filled in with the type <code>std::fs::File</code> when
the file was opened successfully and <code>E</code> was filled in with the type
<code>std::io::Error</code> when there were problems opening the file.</p>
<p>When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.</p>
<a class="header" href="print.html#in-method-definitions" id="in-method-definitions"><h3>In Method Definitions</h3></a>
<p>Like we did in Chapter 5, we can implement methods on structs and enums that
have generic types in their definitions. Listing 10-9 shows the <code>Point&lt;T&gt;</code>
struct we defined in Listing 10-6 with a method named <code>x</code> implemented on it:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listing 10-9: Implementing a method named <code>x</code> on the
<code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field of type
<code>T</code></span></p>
<p>Here, we’ve defined a method named <code>x</code> on <code>Point&lt;T&gt;</code> that returns a reference
to the data in the field <code>x</code>.</p>
<p>Note that we have to declare <code>T</code> just after <code>impl</code> so that we can use it to
specify that we’re implementing methods on the type <code>Point&lt;T&gt;</code>. Declaring <code>T</code>
as a generic type after <code>impl</code> is how Rust can tell the type in the angle
brackets in <code>Point</code> is a generic type rather than a concrete type. For example,
we could choose to implement methods only on <code>Point&lt;f32&gt;</code> instances rather than
on <code>Point&lt;T&gt;</code> instances with any generic type. Listing 10-10 shows that,
because we’re using the concrete type <code>f32</code> in this case, we don’t declare any
types after <code>impl</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-10: An <code>impl</code> block that only applies to a
struct with a particular concrete type for the generic type parameter <code>T</code></span></p>
<p>This code means the type <code>Point&lt;f32&gt;</code> will have a method named
<code>distance_from_origin</code>, and other instances of <code>Point&lt;T&gt;</code> where <code>T</code> is not of
type <code>f32</code> will not have this method defined. This method measures how far our
point is from the point of coordinates (0.0, 0.0) and uses mathematical
operations which are only available for floating point types.</p>
<p>Generic type parameters in a struct definition aren’t always the same as those
you use in that struct’s method signatures. For example, Listing 10-11 defines
the method <code>mixup</code> on the <code>Point&lt;T, U&gt;</code> struct from Listing 10-8. The method
takes another <code>Point</code> as a parameter, which might have different types than the
<code>self</code> <code>Point</code> we’re calling <code>mixup</code> on. The method creates a new <code>Point</code>
instance with the <code>x</code> value from the <code>self</code> <code>Point</code> (of type <code>T</code>) and the <code>y</code>
value from the passed-in <code>Point</code> (of type <code>W</code>):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listing 10-11: Methods that use different generic types
than their struct’s definition</span></p>
<p>In <code>main</code>, we’ve defined a <code>Point</code> that has an <code>i32</code> for <code>x</code> (with value 5) and
an <code>f64</code> for <code>y</code> (with value 10.4). The <code>p2</code> variable is a <code>Point</code> struct that
has a string slice for <code>x</code> (with value <code>&quot;Hello&quot;</code>) and a <code>char</code> for <code>y</code> (with
value <code>c</code>). Calling <code>mixup</code> on <code>p1</code> with the argument <code>p2</code> gives us <code>p3</code>, which
will have an <code>i32</code> for <code>x</code>, because <code>x</code> came from <code>p1</code>. The <code>p3</code> variable will
have a <code>char</code> for <code>y</code>, because <code>y</code> came from <code>p2</code>. The <code>println!</code> macro call
will print <code>p3.x = 5, p3.y = c</code>.</p>
<p>The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with <code>impl</code> and some are declared with the method
definition. Here, the generic parameters <code>T</code> and <code>U</code> are declared after <code>impl</code>,
because they go with the struct definition. The generic parameters <code>V</code> and <code>W</code>
are declared after <code>fn mixup</code>, because they are only relevant to the method.</p>
<a class="header" href="print.html#performance-of-code-using-generics" id="performance-of-code-using-generics"><h3>Performance of Code Using Generics</h3></a>
<p>You may be wondering whether there’s a runtime cost to using generic type
parameters. The good news is that Rust implements generics in such a way that
your code doesn’t run any slower using generic types than it would with
concrete types.</p>
<p>Rust accomplishes this by performing monomorphization of the code that’s using
generics at compile time. <em>Monomorphization</em> is the process of turning generic
code into specific code by filling in the concrete types that are actually used
when compiled.</p>
<p>In this process, the compiler is doing the opposite of the steps we performed
to create the generic function in Listing 10-5: the compiler looks at all the
places that generic code is called and generates code for the concrete types
the generic code is called with.</p>
<p>Let’s see how this works with an example that uses the standard library’s
<code>Option&lt;T&gt;</code> enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let integer = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in the instances of
<code>Option&lt;T&gt;</code> and sees that we have two kinds of <code>Option&lt;T&gt;</code>: one is <code>i32</code>, and
one is <code>f64</code>. As such, it expands the generic definition of <code>Option&lt;T&gt;</code> into
<code>Option_i32</code> and <code>Option_f64</code>, thereby replacing the generic definition with
the specific ones.</p>
<p>The monomorphized version of the code looks like this, with the generic
<code>Option&lt;T&gt;</code> replaced with the specific definitions created by the compiler:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just like it would if we had duplicated each particular definition by
hand. As you can see, the process of monomorphization makes Rust’s generics
extremely efficient at runtime.</p>
<a class="header" href="print.html#traits-defining-shared-behavior" id="traits-defining-shared-behavior"><h2>Traits: Defining Shared Behavior</h2></a>
<p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to state that a generic can be any type
that has certain behavior.</p>
<blockquote>
<p>Note: <em>Traits</em> are similar to a feature often called ‘interfaces’ in other
languages, though with some differences.</p>
</blockquote>
<a class="header" href="print.html#defining-a-trait" id="defining-a-trait"><h3>Defining a Trait</h3></a>
<p>A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together in order
to define a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, let’s say we have multiple structs that hold various kinds and
amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a
particular location, and a <code>Tweet</code> that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.</p>
<p>We want to make a media aggregator library that can display summaries of data
that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we
need a summary from each type, and we need to be able to ask for that summary
by calling a <code>summarize</code> method on an instance. Listing 10-12 shows the
definition of a <code>Summary</code> trait that expresses this behavior:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-12: Definition of a <code>Summary</code> trait that
consists of the behavior provided by a <code>summarize</code> method</span></p>
<p>Here, we declare a trait with the <code>trait</code> keyword, and then the trait’s name,
which is <code>Summary</code> in this case. Inside the curly brackets we declare the
method signatures that describe the behaviors of the types that implement this
trait, which in this case is <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>After the method signature, instead of providing an implementation within curly
brackets, we put a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method, but the compiler will
enforce that any type that has the <code>Summary</code> trait will have the method
<code>summarize</code> defined with this signature exactly.</p>
<p>A trait can have multiple methods in its body, with the method signatures
listed one per line and each line ending in a semicolon.</p>
<a class="header" href="print.html#implementing-a-trait-on-a-type" id="implementing-a-trait-on-a-type"><h3>Implementing a Trait on a Type</h3></a>
<p>Now that we’ve defined our desired behavior using the <code>Summary</code> trait, we can
implement it on the types in our media aggregator. Listing 10-13 shows an
implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses the
headline, the author, and the location to create the return value of
<code>summarize</code>. For the <code>Tweet</code> struct, we define <code>summarize</code> as the username
followed by the whole text of the tweet, assuming that tweet content is already
limited to 280 characters.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Summary {
#     fn summarize(&amp;self) -&gt; String;
# }
#
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-13: Implementing the <code>Summary</code> trait on the
<code>NewsArticle</code> and <code>Tweet</code> types</span></p>
<p>Implementing a trait on a type is similar to implementing regular methods. The
difference is that after <code>impl</code>, we put the trait name that we want to
implement, then use the <code>for</code> keyword, then specify the name of the type we
want to implement the trait for. Within the <code>impl</code> block, we put the method
signatures that the trait definition has defined, but instead of adding a
semicolon after each signature, we put curly brackets and fill in the method
body with the specific behavior that we want the methods of the trait to have
for the particular type.</p>
<p>After implementing the trait, we can call the methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same manner that we call regular methods, like
this:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>This prints: <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Note that because we defined the <code>Summary</code> trait and the <code>NewsArticle</code> and
<code>Tweet</code> types all in the same <em>lib.rs</em> in Listing 10-13, they’re all in the
same scope. If this <em>lib.rs</em> is for a crate we’ve called <code>aggregator</code>, and
someone else wants to use our crate’s functionality to implement the <code>Summary</code>
trait on a struct defined within their library’s scope, they would need to
import the trait into their scope first. They would do so by specifying <code>use aggregator::Summary;</code> which then enables them to implement <code>Summary</code> for their
type. <code>Summary</code> would also need to be a public trait for another crate to
implement it, which it is because we put the <code>pub</code> keyword before <code>trait</code> in
Listing 10-12.</p>
<p>One restriction to note with trait implementations is that we can implement a
trait on a type only if either the trait or the type is local to your crate.
For example, we can implement standard library traits like <code>Display</code> on a
custom type like <code>Tweet</code> as part of our <code>aggregator</code> crate functionality
because the type <code>Tweet</code> is local to our <code>aggregator</code> crate. We can also
implement <code>Summary</code> on <code>Vec&lt;T&gt;</code> in our <code>aggregator</code> crate, because the
trait <code>Summary</code> is local to our <code>aggregator</code> crate.</p>
<p>What we can’t do is implement external traits on external types. For example,
we can’t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code>
crate, because both <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library
and aren’t local to our <code>aggregator</code> crate. This restriction is part of a
property of programs called <em>coherence</em>, and more specifically the <em>orphan
rule</em>, so named because the parent type is not present. This rule ensures that
other people’s code can’t break your code and vice versa. Without it, two
crates could implement the same trait for the same type, and Rust wouldn’t know
which implementation to use.</p>
<a class="header" href="print.html#default-implementations" id="default-implementations"><h3>Default Implementations</h3></a>
<p>Sometimes it’s useful to have default behavior for some or all of the methods
in a trait, instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can choose to keep or
override each method’s default behavior.</p>
<p>Listing 10-14 shows how to specify a default string for the <code>summarize</code> method
of the <code>Summary</code> trait instead of only defining the method signature like we
did in Listing 10-12:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-14: Definition of a <code>Summary</code> trait with a
default implementation of the <code>summarize</code> method</span></p>
<p>To use a default implementation to summarize instances of <code>NewsArticle</code> instead
of defining a custom implementation, we specify an empty <code>impl</code> block with
<code>impl Summary for NewsArticle {}</code>.</p>
<p>Even though we’re no longer choosing to define the <code>summarize</code> method on
<code>NewsArticle</code> directly, we’ve provided a default implementation and specified
that <code>NewsArticle</code> implements the <code>Summary</code> trait, so we can still call the
<code>summarize</code> method on an instance of <code>NewsArticle</code>, like this:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summarize());
</code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Creating a default implementation for <code>summarize</code> does not require us to change
anything about the implementation of <code>Summary</code> on <code>Tweet</code> in Listing 10-13
because the syntax for overriding a default implementation is exactly the same
as the syntax for implementing a trait method that doesn’t have a default
implementation.</p>
<p>Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the <code>Summary</code> trait to have a
<code>summarize_author</code> method whose implementation is required, then a <code>summarize</code>
method that has a default implementation that calls the <code>summarize_author</code>
method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
#}</code></pre></pre>
<p>To use this version of <code>Summary</code>, we only need to define <code>summarize_author</code>
when we implement the trait on a type:</p>
<pre><code class="language-rust ignore">impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Once we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the
<code>Tweet</code> struct, and the default implementation of <code>summarize</code> will call the
definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented
<code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the
<code>summarize</code> method without requiring us to write any more code.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>This prints <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Note that it is not possible to call the default implementation from an
overriding implementation of that same method.</p>
<a class="header" href="print.html#trait-bounds" id="trait-bounds"><h3>Trait Bounds</h3></a>
<p>Now that you’ve learned how to define traits and implement those traits on
types, we can cover how to use traits with generic type parameters. We can use
<em>trait bounds</em> to constrain generic types to ensure the type will be limited to
those that implement a particular trait and behavior.</p>
<p>For example, in Listing 10-13, we implemented the <code>Summary</code> trait on the types
<code>NewsArticle</code> and <code>Tweet</code>. We can define a function <code>notify</code> that calls the
<code>summarize</code> method on its parameter <code>item</code>, which is of the generic type <code>T</code>.
To be able to call <code>summarize</code> on <code>item</code> without getting an error that the
generic type <code>T</code> doesn’t implement the method <code>summarize</code>, we can use trait
bounds on <code>T</code> to specify that <code>item</code> must be of a type that implements the
<code>Summary</code> trait:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>We place trait bounds with the declaration of the generic type parameter, after
a colon and inside angle brackets. Because of the trait bound on <code>T</code>, we can
call <code>notify</code> and pass in any instance of <code>NewsArticle</code> or <code>Tweet</code>. Code that
calls the function with any other type, like a <code>String</code> or an <code>i32</code>, won’t
compile, because those don’t implement <code>Summary</code>.</p>
<p>We can specify multiple trait bounds on a generic type using the <code>+</code> syntax.
For example, to use display formatting on the type <code>T</code> in a function as well as
the <code>summarize</code> method, we can use <code>T: Summary + Display</code> to say <code>T</code> can be any
type that implements both <code>Summary</code> and <code>Display</code>.</p>
<p>There are downsides to using too many trait bounds, however. Each generic has
its own trait bounds, so functions with multiple generic type parameters can
have lots of trait bound information between a function’s name and its
parameter list, making the function signature hard to read. For this reason,
Rust has alternate syntax for specifying trait bounds inside a <code>where</code> clause
after the function signature. So instead of writing this:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>We can use a <code>where</code> clause, like this:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>This function’s signature is less cluttered in that the function name,
parameter list, and return type are close together, similar to a function
without lots of trait bounds.</p>
<a class="header" href="print.html#fixing-the-largest-function-with-trait-bounds" id="fixing-the-largest-function-with-trait-bounds"><h3>Fixing the <code>largest</code> Function with Trait Bounds</h3></a>
<p>Now that we’ve covered how to specify the behavior you want to use using the
generic type parameter’s bounds, we can return to Listing 10-5 to fix the
definition of the <code>largest</code> function that uses a generic type parameter! Last
time we were trying out that code, we were getting this error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>In the body of <code>largest</code> we wanted to compare two values of type <code>T</code> using the
greater-than operator. Because that operator is defined as a default method on
the standard library trait <code>std::cmp::PartialOrd</code>, we need to specify
<code>PartialOrd</code> in the trait bounds for <code>T</code> so that the <code>largest</code> function can
work on slices of any type that can be compared. We don’t need to bring
<code>PartialOrd</code> into scope because it’s in the prelude. Change the signature of
<code>largest</code> to look like this:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>This time, when we compile the code, we’ll get a different set of errors:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>The key line in this error is <code>cannot move out of type [T], a non-copy slice</code>.
With our non-generic versions of the <code>largest</code> function, we were only trying to
find the largest <code>i32</code> or <code>char</code>. As we discussed in the “Stack-Only Data:
Copy” section in Chapter 4, types like <code>i32</code> and <code>char</code> that have a known size
can be stored on the stack, so they implement the <code>Copy</code> trait. But when we
made the <code>largest</code> function generic, it became possible that the <code>list</code>
parameter could have types in it that don’t implement the <code>Copy</code> trait, which
would mean we wouldn’t be able to move the value out of <code>list[0]</code> and into the
<code>largest</code> variable, resulting in this error.</p>
<p>To call this code with only those types that implement the <code>Copy</code> trait, we can
add <code>Copy</code> to the trait bounds of <code>T</code>! Listing 10-15 shows the complete code of
a generic <code>largest</code> function that will compile as long as the types of the
values in the slice that we pass into the function implement both the
<code>PartialOrd</code> and <code>Copy</code> traits, like <code>i32</code> and <code>char</code> do:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listing 10-15: A working definition of the <code>largest</code>
function that works on any generic type that implements the <code>PartialOrd</code> and
<code>Copy</code> traits</span></p>
<p>If we don’t want to restrict our <code>largest</code> function to the types that implement
the <code>Copy</code> trait, we could specify that <code>T</code> has the trait bound <code>Clone</code> instead
of <code>Copy</code> and clone each value in the slice when we want the <code>largest</code> function
to have ownership. Using the <code>clone</code> function means we’re potentially making
more heap allocations, though, in the case of types that own heap data like
<code>String</code>, and heap allocations can be slow if we’re working with large amounts
of data.</p>
<p>Another way we could implement <code>largest</code> is for the function to return a
reference to a <code>T</code> value in the slice. If we change the return type to <code>&amp;T</code>
instead of <code>T</code>, thereby changing the body of the function to return a
reference, we wouldn’t need either the <code>Clone</code> or <code>Copy</code> trait bounds and we
could avoid heap allocations altogether. Try implementing these alternate
solutions on your own!</p>
<a class="header" href="print.html#using-trait-bounds-to-conditionally-implement-methods" id="using-trait-bounds-to-conditionally-implement-methods"><h3>Using Trait Bounds to Conditionally Implement Methods</h3></a>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters,
we can conditionally implement methods only for types that implement the
specified traits. For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-16 always
implements the <code>new</code> function, but <code>Pair&lt;T&gt;</code> only implements the <code>cmp_display</code>
method if its inner type <code>T</code> implements the <code>PartialOrd</code> trait that enables
comparison and the <code>Display</code> trait that enables printing:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span></p>
<p>We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called <em>blanket implementations</em>, and are extensively used in the
Rust standard library. For example, the standard library implements the
<code>ToString</code> trait on any type that implements the <code>Display</code> trait. The <code>impl</code>
block in the standard library looks similar to this code:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Because the standard library has this blanket implementation, we can call the
<code>to_string</code> method defined by the <code>ToString</code> trait on any type that implements
the <code>Display</code> trait. For example, we can turn integers into their corresponding
<code>String</code> values like this because integers implement <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>Blanket implementations appear in the documentation for the trait in the
“Implementors” section.</p>
<p>Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
right behavior. Unlike in dynamically typed languages, where we’d get an error
at runtime if we tried to call a method on a type that the type didn’t
implement, Rust moves these errors to compile time so that we’re forced to fix
the problems before our code is even able to run. Additionally, we don’t have
to write code that checks for behavior at runtime because we’ve already checked
at compile time, which improves performance without having to give up the
flexibility of generics.</p>
<p>There’s another kind of generic that we’ve already been using called
<em>lifetimes</em>. Rather than ensuring that a type has the behavior we want,
lifetimes ensure that references are valid as long as we need them to be. Let’s
learn how lifetimes do that.</p>
<a class="header" href="print.html#validating-references-with-lifetimes" id="validating-references-with-lifetimes"><h2>Validating References with Lifetimes</h2></a>
<p>One thing we didn’t discuss in the “References and Borrowing” section in
Chapter 4 is that every reference in Rust has a <em>lifetime</em>, which is the scope
for which that reference is valid. Most of the time lifetimes are implicit and
inferred, just like most of the time types are inferred. Similar to the way we
annotate types when multiple types are possible, in cases where the lifetimes
of references could be related in a few different ways, Rust requires us to
annotate the relationships using generic lifetime parameters to ensure the
actual references used at runtime will definitely be valid.</p>
<p>This concept is somewhat different from tools in other programming languages,
arguably making lifetimes Rust’s most distinctive feature. Although we won’t
cover lifetimes in their entirety in this chapter, we’ll cover common ways you
might encounter lifetime syntax to get you familiar with the concepts. See the
“Advanced Lifetimes” section in Chapter 19 for more detailed information.</p>
<a class="header" href="print.html#lifetimes-prevent-dangling-references" id="lifetimes-prevent-dangling-references"><h3>Lifetimes Prevent Dangling References</h3></a>
<p>The main aim of lifetimes is to prevent dangling references, which will cause a
program to reference data other than the data it’s intended to reference.
Consider the program in Listing 10-17, with an outer scope and an inner scope:</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span></p>
<blockquote>
<p>Note: This example and the next few examples declare variables without giving
them an initial value, so that the variable name exists in the outer scope.
At first glance, this might appear to be in conflict with Rust having no null
values. However, if we try to use a variable before giving it a value, we’ll
get a compile-time error, which shows that Rust indeed does not allow null
values.</p>
</blockquote>
<p>The outer scope declares a variable named <code>r</code> with no initial value, and the
inner scope declares a variable named <code>x</code> with the initial value of 5. Inside
the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code>. Then
the inner scope ends, and we attempt to print the value in <code>r</code>. This code won’t
compile because the value <code>r</code> is referring to has gone out of scope before we
try to use it. Here’s the error message:</p>
<pre><code class="language-text">error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:5
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>The variable <code>x</code> doesn’t “live long enough.” This is because <code>x</code> will be out of
scope when the inner scope ends on line 7. But <code>r</code> is still valid for the outer
scope; because its scope is larger, we say that it “lives longer.” If Rust
allowed this code to work, <code>r</code> would be referencing memory that was deallocated
when <code>x</code> went out of scope, and anything we tried to do with <code>r</code> wouldn’t work
correctly. So how does Rust determine that this code is invalid?</p>
<a class="header" href="print.html#the-borrow-checker" id="the-borrow-checker"><h3>The Borrow Checker</h3></a>
<p>The Rust compiler has a <em>borrow checker</em>, which compares scopes to determine
that all borrows are valid. Listing 10-18 shows the same code as Listing 10-17,
but with annotations showing the lifetimes of the variables:</p>
<pre><code class="language-rust ignore">{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<p><span class="caption">Listing 10-18: Annotations of the lifetimes of <code>r</code> and
<code>x</code>, named <code>'a</code> and <code>'b</code>, respectively</span></p>
<p>Here, we’ve annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code>
with <code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer
<code>'a</code> lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that <code>r</code> has a lifetime of <code>'a</code>, but that it refers to
memory with a lifetime of <code>'b</code>. The program is rejected because <code>'b</code> is shorter
than <code>'a</code>: the subject of the reference doesn’t live as long as the reference.</p>
<p>Listing 10-19 fixes the code so it doesn’t have a dangling reference and
compiles without any errors:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
#}</code></pre></pre>
<p><span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span></p>
<p>Here, <code>x</code> has the lifetime <code>'b</code>, which in this case is larger than <code>'a</code>. This
means <code>r</code> can reference <code>x</code> because Rust knows that the reference in <code>r</code> will
always be valid while <code>x</code> is valid.</p>
<p>Now that we’ve seen where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let’s talk about generic
lifetimes of parameters and return values in the context of functions.</p>
<a class="header" href="print.html#generic-lifetimes-in-functions" id="generic-lifetimes-in-functions"><h3>Generic Lifetimes in Functions</h3></a>
<p>Let’s write a function that returns the longest of two string slices. This
function will take two string slices and return a string slice. The code in
Listing 10-20 should print <code>The longest string is abcd</code> once we’ve implemented
the <code>longest</code> function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-20: A <code>main</code> function that calls the <code>longest</code>
function to find the longest of two string slices</span></p>
<p>Note that we want the function to take string slices, which are references,
because we don’t want the <code>longest</code> function to take ownership of its
parameters. We want to allow the function to accept slices of a <code>String</code> (the
type stored in the variable <code>string1</code>) as well as string literals (which is
what variable <code>string2</code> contains).</p>
<p>Refer to the “String Slices as Parameters” section of Chapter 4 for more
discussion about why these are the parameters we want.</p>
<p>If we try to implement the <code>longest</code> function as shown in Listing 10-21, it
won’t compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Listing 10-21: An implementation of the <code>longest</code>
function that returns the longest of two string slices, but does not yet
compile</span></p>
<p>Instead, we get the following error that talks about lifetimes:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:33
  |
1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>The help text says that the return type needs a generic lifetime parameter on
it because Rust can’t tell whether the reference being returned refers to <code>x</code>
or <code>y</code>. Actually, we don’t know either, because the <code>if</code> block in the body of
this function returns a reference to <code>x</code> and the <code>else</code> block returns a
reference to <code>y</code>!</p>
<p>When we’re defining this function, we don’t know the concrete values that will
be passed into this function, so we don’t know whether the <code>if</code> case or the
<code>else</code> case will execute. We also don’t know the concrete lifetimes of the
references that will be passed in, so we can’t look at the scopes like we did
in Listings 10-18 and 10-19 to determine that the reference we return will
always be valid. The borrow checker can’t determine this either, because it
doesn’t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the
return value. To fix this error, we’re going to add generic lifetime parameters
that define the relationship between the references so that the borrow checker
can perform its analysis.</p>
<a class="header" href="print.html#lifetime-annotation-syntax" id="lifetime-annotation-syntax"><h3>Lifetime Annotation Syntax</h3></a>
<p>Lifetime annotations don’t actually change how long any of the references live.
Just like functions can accept any type when the signature specifies a generic
type parameter, functions can accept references with any lifetime by specifying
a generic lifetime parameter. Lifetime annotations describe the relationships
of the lifetimes of multiple references to each other without affecting the
lifetimes themselves.</p>
<p>Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe <code>'</code> and are usually all lowercase and
very short, like generic types. <code>'a</code> is the name most people use. We place
lifetime parameter annotations after the <code>&amp;</code> of a reference, using a space to
separate the annotation from the reference’s type.</p>
<p>Here are some examples: a reference to an <code>i32</code> without a lifetime parameter, a
reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>, and a mutable
reference to an <code>i32</code> that also has the lifetime <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>One lifetime annotation by itself doesn’t have much meaning because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, if we have a function with the
parameter <code>first</code> that is a reference to an <code>i32</code> with lifetime <code>'a</code>, and the
function has another parameter named <code>second</code> that is another reference to an
<code>i32</code> that also has the lifetime <code>'a</code>, the lifetime annotations indicate that
the references <code>first</code> and <code>second</code> must both live as long as that generic
lifetime.</p>
<a class="header" href="print.html#lifetime-annotations-in-function-signatures" id="lifetime-annotations-in-function-signatures"><h3>Lifetime Annotations in Function Signatures</h3></a>
<p>Now let’s examine lifetime annotations in the context of the <code>longest</code>
function. Just like with generic type parameters, we need to declare generic
lifetime parameters inside angle brackets between the function name and the
parameter list. The constraint we want to express in this signature is that all
the references in the parameters and the return value must have the same
lifetime, which we’ll name <code>'a</code>, and then add to each reference as shown in
Listing 10-22:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-22: The <code>longest</code> function definition
specifying that all the references in the signature must have the same
lifetime, <code>'a</code></span></p>
<p>This should compile and produce the result we want when used with the <code>main</code>
function in Listing 10-20.</p>
<p>The function signature now tells Rust that for some lifetime <code>'a</code>, the function
takes two parameters, both of which are string slices that live at least as
long as the lifetime <code>'a</code>. The function signature also tells Rust that the
string slice returned from the function will live at least as long as the
lifetime <code>'a</code>. This is the rule we want Rust to enforce.</p>
<p>As discussed, by specifying the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned, but we’re
specifying that the borrow checker should reject any values that don’t adhere
to this rule. Note that this function doesn’t need to know exactly how long <code>x</code>
and <code>y</code> will live, only that there is some scope that can be substituted for
<code>'a</code> that will satisfy this signature.</p>
<p>When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. Rust can analyze the code within the
function without any help. However, when a function has references to or from
code outside that function, it becomes almost impossible for Rust to figure out
the lifetimes of the parameters or return values on its own. The lifetimes
might be different each time the function is called. This is why we need to
annotate the lifetimes ourselves.</p>
<p>When we pass concrete references to <code>longest</code>, the concrete lifetime that is
substituted for <code>'a</code> is the part of the scope of <code>x</code> that overlaps with the
scope of <code>y</code>. In other words, the generic lifetime <code>'a</code> will get the concrete
lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code>. Because
we’ve annotated the returned reference with the same lifetime parameter <code>'a</code>,
the returned reference will be valid as long as the shorter of the lifetimes of
<code>x</code> and <code>y</code>.</p>
<p>Let’s see how the lifetime annotations restrict the <code>longest</code> function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 10-23: Using the <code>longest</code> function with
references to <code>String</code> values that have different concrete lifetimes</span></p>
<p>In this example, <code>string1</code> is valid until the end of the outer scope, <code>string2</code>
is valid until the end of the inner scope, and <code>result</code> references something
that is valid until the end of the inner scope. Run this and you’ll see that
the borrow checker approves of this code; it will compile and print <code>The longest string is long string is long</code> when run.</p>
<p>Next, let’s try an example that shows that the lifetime of the reference in
<code>result</code> must be the smaller lifetime of the two arguments. We’ll move the
declaration of the <code>result</code> variable outside the inner scope, but leave the
assignment of the value to the <code>result</code> variable inside the scope with
<code>string2</code>. Next, we’ll move the <code>println!</code> that uses <code>result</code> outside of the
inner scope, after it has ended. The code in Listing 10-24 will not compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-24: Attempting to use <code>result</code> after <code>string2</code>
has gone out of scope won’t compile</span></p>
<p>When we try to compile this, we’ll get this error:</p>
<pre><code class="language-text">error[E0597]: `string2` does not live long enough
  --&gt; src/main.rs:15:5
   |
14 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
15 |     }
   |     ^ `string2` dropped here while still borrowed
16 |     println!(&quot;The longest string is {}&quot;, result);
17 | }
   | - borrowed value needs to live until here
</code></pre>
<p>The error says that for <code>result</code> to be valid for the <code>println!</code> statement,
<code>string2</code> would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter, <code>'a</code>.</p>
<p>As humans, we can look at this code and see that <code>string1</code> is longer, and
therefore <code>result</code> will contain a reference to <code>string1</code>. Because <code>string1</code> has
not gone out of scope yet, a reference to <code>string1</code> will still be valid for the
<code>println!</code> statement. However, the compiler can’t see that the reference is
valid in this case. We’ve told Rust that the lifetime of the reference returned
by the <code>longest</code> function is the same as the smaller of the lifetimes of the
references passed in. Therefore, the borrow checker disallows the code in
Listing 10-24 as possibly having an invalid reference.</p>
<p>Try designing some more experiments that vary the values and lifetimes of the
references passed in to the <code>longest</code> function and how the returned reference
is used. Make hypotheses about whether your experiments will pass the borrow
checker or not before you compile, then check to see if you’re right!</p>
<a class="header" href="print.html#thinking-in-terms-of-lifetimes" id="thinking-in-terms-of-lifetimes"><h3>Thinking in Terms of Lifetimes</h3></a>
<p>The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
<code>longest</code> function to always return the first parameter rather than the longest
string slice, we wouldn’t need to specify a lifetime on the <code>y</code> parameter. The
following code will compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>In this example, we’ve specified a lifetime parameter <code>'a</code> for the parameter
<code>x</code> and the return type, but not for the parameter <code>y</code>, because the lifetime of
<code>y</code> does not have any relationship with the lifetime of <code>x</code> or the return value.</p>
<p>When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does <em>not</em> refer to one of the parameters, then it must
refer to a value created within this function, which would be a dangling
reference because the value will go out of scope at the end of the function.
Consider this attempted implementation of the <code>longest</code> function that won’t
compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Here, even though we’ve specified a lifetime parameter <code>'a</code> for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here’s the
error message we get:</p>
<pre><code class="language-text">error[E0597]: `result` does not live long enough
 --&gt; src/main.rs:3:5
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the
function body at 1:1...
 --&gt; src/main.rs:1:1
  |
1 | / fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
2 | |     let result = String::from(&quot;really long string&quot;);
3 | |     result.as_str()
4 | | }
  | |_^
</code></pre>
<p>The problem is that <code>result</code> goes out of scope and gets cleaned up at the end
of the <code>longest</code> function, and we’re trying to return a reference to <code>result</code>
from the function. There’s no way we can specify lifetime parameters that would
change the dangling reference, and Rust won’t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so that the calling function is then responsible for
cleaning up the value.</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they’re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.</p>
<a class="header" href="print.html#lifetime-annotations-in-struct-definitions" id="lifetime-annotations-in-struct-definitions"><h3>Lifetime Annotations in Struct Definitions</h3></a>
<p>So far, we’ve only defined structs to hold owned types. It is possible for
structs to hold references, but in that case we would need to add a lifetime
annotation on every reference in the struct’s definition. Listing 10-25 has a
struct named <code>ImportantExcerpt</code> that holds a string slice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<p><span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span></p>
<p>This struct has one field, <code>part</code>, that holds a string slice, which is a
reference. Like with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so that
we can use the lifetime parameter in the body of the struct definition. This
annotation means an instance of <code>ImportantExcerpt</code> can’t outlive the reference
it holds in its <code>part</code> field.</p>
<p>The <code>main</code> function here creates an instance of the <code>ImportantExcerpt</code> struct
that holds a reference to the first sentence of the <code>String</code> owned by the
variable <code>novel</code>. The data in <code>novel</code> exists before the <code>ImportantExcerpt</code>
instance is created, and it doesn’t go out of scope until after the
<code>ImportantExcerpt</code> goes out of scope, so the reference in the
<code>ImportantExcerpt</code> instance is valid.</p>
<a class="header" href="print.html#lifetime-elision" id="lifetime-elision"><h3>Lifetime Elision</h3></a>
<p>You’ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in the “String Slices” section, shown again in
Listing 10-26, that compiled without lifetime annotations:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-26: A function we defined in Chapter 4 that
compiled without lifetime annotations, even though the parameter and return
type are references</span></p>
<p>The reason this function compiles without lifetime annotations is historical:
in early versions of pre-1.0 Rust, this wouldn’t have compiled because every
reference needed an explicit lifetime. At that time, the function signature
would have been written like this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler’s code so
that the borrow checker can infer the lifetimes in these situations and doesn’t
need explicit annotations.</p>
<p>This piece of Rust history is relevant because it’s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.</p>
<p>The patterns programmed into Rust’s analysis of references are called the
<em>lifetime elision rules</em>. These aren’t rules for programmers to follow; they’re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don’t need to write the lifetimes explicitly.</p>
<p>The elision rules don’t provide full inference. If Rust deterministically
applies the rules but there’s still ambiguity as to what lifetimes the
references have, the compiler won’t guess what the lifetime of the remaining
references should be. In this case, instead of guessing, the compiler will give
you an error that you can resolve by adding the lifetime annotations that
specify how the references relate to each other.</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and
lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>The compiler uses three rules to figure out what lifetimes references have when
there aren’t explicit annotations. The first rule applies to input lifetimes,
and the second two rules apply to output lifetimes. If the compiler gets to the
end of the three rules and there are still references for which it can’t figure
out lifetimes, the compiler will stop with an error.</p>
<p>The first rule is that each parameter that is a reference gets its own lifetime
parameter. In other words, a function with one parameter gets one lifetime
parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>, a function with two parameters gets two
separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, and so
on.</p>
<p>The second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>The third rule is if there are multiple input lifetime parameters, but one of
them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, then the lifetime of
<code>self</code> is assigned to all output lifetime parameters. This makes writing
methods much nicer.</p>
<p>Let’s pretend we’re the compiler and apply these rules to figure out what the
lifetimes of the references in the signature of the <code>first_word</code> function in
Listing 10-26 are. The signature starts without any lifetimes associated with
the references:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Then the compiler applies the first rule, which says each parameter gets its
own lifetime. We’re going to call it <code>'a</code> as usual, so now the signature is:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>The second rule applies because there is exactly one input lifetime. The second
rule says the lifetime of the one input parameter gets assigned to the output
lifetime, so the signature is now this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.</p>
<p>Let’s do another example, this time with the <code>longest</code> function that had no
lifetime parameters when we started working with in Listing 10-21:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Let’s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>We can see that the second rule doesn’t apply because there is more than one
input lifetime. The third rule doesn’t apply either, because this is a function
rather than a method, so none of the parameters are <code>self</code>. After going through
all three rules, we still haven’t figured out what the return type’s lifetime
is. This is why we got an error trying to compile the code from Listing 10-21:
the compiler worked through the lifetime elision rules, but still couldn’t
figure out all the lifetimes of the references in the signature.</p>
<p>Because the third rule only really applies in method signatures, we’ll look at
lifetimes in that context next to see why the third rule means we don’t have to
annotate lifetimes in method signatures very often.</p>
<a class="header" href="print.html#lifetime-annotations-in-method-definitions" id="lifetime-annotations-in-method-definitions"><h3>Lifetime Annotations in Method Definitions</h3></a>
<p>When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they’re related to the struct
fields or the method parameters and return values.</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code>
keyword and then used after the struct’s name, because those lifetimes are part
of the struct’s type.</p>
<p>In method signatures inside the <code>impl</code> block, references might be tied to the
lifetime of references in the struct’s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren’t necessary in method signatures. Let’s look at some examples using the
struct named <code>ImportantExcerpt</code> that we defined in Listing 10-25.</p>
<p>First, here’s a method named <code>level</code> whose only parameter is a reference to
<code>self</code>, and whose return value is an <code>i32</code>, which is not a reference to
anything:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p>The lifetime parameter declaration after <code>impl</code> and use after the type name is
required, but we’re not required to annotate the lifetime of the reference to
<code>self</code> because of the first elision rule.</p>
<p>Here’s an example where the third lifetime elision rule applies:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
#}</code></pre></pre>
<p>There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both <code>&amp;self</code> and <code>announcement</code> their own lifetimes. Then, because
one of the parameters is <code>&amp;self</code>, the return type gets the lifetime of <code>&amp;self</code>,
and all lifetimes have been accounted for.</p>
<a class="header" href="print.html#the-static-lifetime" id="the-static-lifetime"><h3>The Static Lifetime</h3></a>
<p>One special lifetime we need to discuss is <code>'static</code>, which denotes the entire
duration of the program. All string literals have the <code>'static</code> lifetime, which
we can annotate as follows: <code>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;</code></p>
<p>The text of this string is stored directly in the binary of your program, which
is always available. Therefore, the lifetime of all string literals is
<code>'static</code>.</p>
<p>You may see suggestions to use the <code>'static</code> lifetime in error messages, but
before specifying <code>'static</code> as the lifetime for a reference, think about
whether the reference you have is one that actually lives the entire lifetime
of your program or not. You might consider whether you want it to live that
long, even if it could. Most of the time, the problem results from attempting
to create a dangling reference or a mismatch of the available lifetimes, in
which case the solution is fixing those problems, not specifying the <code>'static</code>
lifetime.</p>
<a class="header" href="print.html#generic-type-parameters-trait-bounds-and-lifetimes-together" id="generic-type-parameters-trait-bounds-and-lifetimes-together"><h2>Generic Type Parameters, Trait Bounds, and Lifetimes Together</h2></a>
<p>Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>This is the <code>longest</code> function from Listing 10-22 that returns the longest of
two string slices, but now with an extra parameter named <code>ann</code> of the generic
type <code>T</code>, which may be filled in by any type that implements the <code>Display</code>
trait as specified by the <code>where</code> clause. This extra parameter will be printed
before the function compares the lengths of the string slices, which is why the
<code>Display</code> trait bound is necessary. Because lifetimes are a type of generic,
the declarations of both the lifetime parameter <code>'a</code> and the generic type
parameter <code>T</code> go in the same list inside the angle brackets after the function
name.</p>
<a class="header" href="print.html#summary-5" id="summary-5"><h2>Summary</h2></a>
<p>We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code that isn’t repetitive yet works in many different
situations. Generic type parameters let you apply the code to different types.
Traits and trait bounds ensure that even though the types are generic, they
will have the behavior the code needs. You learned how to use lifetime
annotations to ensure that this flexible code won’t have any dangling
references. And all of this happens at compile time, which doesn’t affect
runtime performance!</p>
<p>Believe it or not, there’s much more to learn on these topics: Chapter 17 will
discuss trait objects, which are another way to use traits. Chapter 19 will
cover more complex scenarios involving lifetime annotations as well as some
advanced type system features. But in the next chapter, you’ll learn how to
write tests in Rust so that we can make sure our code is working the way it
should.</p>
<a class="header" href="print.html#writing-automated-tests" id="writing-automated-tests"><h1>Writing Automated Tests</h1></a>
<p>In his 1972 essay, “The Humble Programmer,” Edsger W. Dijkstra said that
“Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.” That doesn’t mean we
shouldn’t try to test as much as we can! Correctness in our programs is the
extent to which our code does what we intend it to do. Rust is a programming
language designed with a high degree of concern about the correctness of
programs, but correctness is complex and not easy to prove. Rust’s type system
shoulders a huge part of this burden, but the type system cannot catch every
kind of incorrectness. As such, Rust includes support for writing automated
software tests within the language.</p>
<p>As an example, say we write a function called <code>add_two</code> that adds two to
whatever number is passed to it. This function’s signature accepts an integer
as a parameter and returns an integer as a result. When we implement and
compile that function, Rust does all the type checking and borrow checking that
you’ve learned so far to ensure that, for instance, we aren’t passing a
<code>String</code> value or an invalid reference to this function. But Rust <em>can’t</em> check
that this function will do precisely what we intend, which is return the
parameter plus two rather than, say, the parameter plus 10 or the parameter
minus 50! That’s where tests come in.</p>
<p>We can write tests that assert, for example, that when we pass <code>3</code> to the
<code>add_two</code> function, the returned value is <code>5</code>. We can run these tests whenever
we make changes to our code to make sure any existing correct behavior has not
changed.</p>
<p>Testing is a complex skill: although we can’t cover every detail about how to
write good tests in one chapter, we’ll discuss the mechanics of Rust’s testing
facilities. We’ll talk about the annotations and macros available to you when
writing your tests, the default behavior and options provided for running your
tests, and how to organize tests into unit tests and integration tests.</p>
<a class="header" href="print.html#how-to-write-tests" id="how-to-write-tests"><h2>How to Write Tests</h2></a>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<ol>
<li>Set up any needed data or state</li>
<li>Run the code we want to test</li>
<li>Assert the results are what we expect</li>
</ol>
<p>Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the <code>test</code> attribute, a few macros, and the
<code>should_panic</code> attribute.</p>
<a class="header" href="print.html#the-anatomy-of-a-test-function" id="the-anatomy-of-a-test-function"><h3>The Anatomy of a Test Function</h3></a>
<p>At its simplest, a test in Rust is a function that’s annotated with the <code>test</code>
attribute. Attributes are metadata about pieces of Rust code; one example is
the <code>derive</code> attribute we used with structs in Chapter 5. To change a function
into a test function, we add <code>#[test]</code> on the line before <code>fn</code>. When we run our
tests with the <code>cargo test</code> command, Rust builds a test runner binary that runs
the functions annotated with the <code>test</code> attribute and reports on whether each
test function passes or fails.</p>
<p>In Chapter 7, we saw that when we make a new library project with Cargo, a test
module with a test function in it is automatically generated for us. This
module helps us start writing our tests so we don’t have to look up the exact
structure and syntax of test functions every time we start a new project. We
can add as many additional test functions and as many test modules as we want!</p>
<p>We’ll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then we’ll write some
real-world tests that call some code that we’ve written and assert that its
behavior is correct.</p>
<p>Let’s create a new library project called <code>adder</code>:</p>
<pre><code class="language-text">$ cargo new adder
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <em>src/lib.rs</em> file in your adder library should look like
Listing 11-1:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-1: The test module and function generated
automatically by <code>cargo new</code></span></p>
<p>For now, let’s ignore the top two lines and focus on the function to see how it
works. Note the <code>#[test]</code> annotation before the <code>fn</code> line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the <code>tests</code> module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the <code>#[test]</code> attribute.</p>
<p>The function body uses the <code>assert_eq!</code> macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Let’s run
it to see that this test passes.</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing
11-2:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">Listing 11-2: The output from running the automatically
generated test</span></p>
<p>Cargo compiled and ran the test. After the <code>Compiling</code>, <code>Finished</code>, and
<code>Running</code> lines is the line <code>running 1 test</code>. The next line shows the name
of the generated test function, called <code>it_works</code>, and the result of running
that test, <code>ok</code>. The overall summary of running the tests appears next. The
text <code>test result: ok.</code> means that all the tests passed, and the portion that
reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>Because we don’t have any tests we’ve marked as ignored, the summary shows <code>0 ignored</code>. We also haven’t filtered the tests being run, so the end of the
summary shows <code>0 filtered out</code>. We’ll talk about ignoring and filtering out
tests in the next section, “Controlling How Tests Are Run.”</p>
<p>The <code>0 measured</code> statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
Chapter 1 for more information about nightly Rust.</p>
<p>The next part of the test output, which starts with <code>Doc-tests adder</code>, is for
the results of any documentation tests. We don’t have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! We’ll
discuss how to write documentation tests in the “Documentation Comments”
section of Chapter 14. For now, we’ll ignore the <code>Doc-tests</code> output.</p>
<p>Let’s change the name of our test to see how that changes the test output.
Change the <code>it_works</code> function to a different name, such as <code>exploration</code>, like
so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Let’s add another test, but this time we’ll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the <code>panic!</code> macro. Enter the new test, <code>another</code>, so your
<em>src/lib.rs</em> file looks like Listing 11-3:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-3: Adding a second test that will fail because
we call the <code>panic!</code> macro</span></p>
<p>Run the tests again using <code>cargo test</code>. The output should look like Listing
11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed:</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed
</code></pre>
<p><span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span></p>
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
<code>another</code> failed because it <code>panicked at 'Make this test fail'</code>, which happened
on line 10 in the <em>src/lib.rs</em> file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; we’ll talk more about ways to run tests in
the “Controlling How Tests Are Run” section.</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>.
We had one test pass and one test fail.</p>
<p>Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than <code>panic!</code> that are useful in tests.</p>
<a class="header" href="print.html#checking-results-with-the-assert-macro" id="checking-results-with-the-assert-macro"><h3>Checking Results with the <code>assert!</code> Macro</h3></a>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to <code>true</code>. We give the
<code>assert!</code> macro an argument that evaluates to a Boolean. If the value is
<code>true</code>, <code>assert!</code> does nothing and the test passes. If the value is <code>false</code>,
the <code>assert!</code> macro calls the <code>panic!</code> macro, which causes the test to fail.
Using the <code>assert!</code> macro helps us check that our code is functioning in the
way we intend.</p>
<p>In Chapter 5, Listing 5-15, we used a <code>Rectangle</code> struct and a <code>can_hold</code>
method, which are repeated here in Listing 11-5. Let’s put this code in the
<em>src/lib.rs</em> file and write some tests for it using the <code>assert!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-5: Using the <code>Rectangle</code> struct and its
<code>can_hold</code> method from Chapter 5</span></p>
<p>The <code>can_hold</code> method returns a Boolean, which means it’s a perfect use case
for the <code>assert!</code> macro. In Listing 11-6, we write a test that exercises the
<code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a length of 8 and
a width of 7, and asserting that it can hold another <code>Rectangle</code> instance that
has a length of 5 and a width of 1:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-6: A test for <code>can_hold</code> that checks that a
larger rectangle can indeed hold a smaller rectangle</span></p>
<p>Note that we’ve added a new line inside the <code>tests</code> module: the <code>use super::*;</code>
line. The <code>tests</code> module is a regular module that follows the usual visibility
rules we covered in Chapter 7 in the “Privacy Rules” section. Because the
<code>tests</code> module is an inner module, we need to bring the code under test in the
outer module into the scope of the inner module. We use a glob here so anything
we define in the outer module is available to this <code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression
is supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
#}</code></pre></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. Let’s change the implementation of the <code>can_hold</code>
method by replacing the greater-than sign with a less-than sign when it
compares the lengths:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# pub struct Rectangle {
#     length: u32,
#     width: u32,
# }
// --snip--

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Our tests caught the bug! Because <code>larger.length</code> is 8 and <code>smaller.length</code> is
5, the comparison of the lengths in <code>can_hold</code> now returns <code>false</code>: 8 is not
less than 5.</p>
<a class="header" href="print.html#testing-equality-with-the-assert_eq-and-assert_ne-macros" id="testing-equality-with-the-assert_eq-and-assert_ne-macros"><h3>Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</h3></a>
<p>A common way to test functionality is to compare the result of the code under
test to the value we expect the code to return to make sure they’re equal. We
could do this using the <code>assert!</code> macro and passing it an expression using the
<code>==</code> operator. However, this is such a common test that the standard library
provides a pair of macros—<code>assert_eq!</code> and <code>assert_ne!</code>—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see <em>why</em> the test failed; conversely, the
<code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code>
expression, not the values that lead to the <code>false</code> value.</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its
parameter and returns the result. Then we test this function using the
<code>assert_eq!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-7: Testing the function <code>add_two</code> using the
<code>assert_eq!</code> macro</span></p>
<p>Let’s check that it passes!</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The first argument we gave to the <code>assert_eq!</code> macro, <code>4</code>, is equal to the
result of calling <code>add_two(2)</code>. The line for this test is <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>Let’s introduce a bug into our code to see what it looks like when a test that
uses <code>assert_eq!</code> fails. Change the implementation of the <code>add_two</code> function to
instead add <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
#}</code></pre></pre>
<p>Run the tests again:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
        thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed, displaying the message
<code>assertion failed: `(left == right)`</code> and showing that <code>left</code> was <code>4</code> and
<code>right</code> was <code>5</code>. This message is useful and helps us start debugging: it means
the <code>left</code> argument to <code>assert_eq!</code> was <code>4</code>, but the <code>right</code> argument, where we
had <code>add_two(2)</code>, was <code>5</code>.</p>
<p>Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called <code>expected</code> and <code>actual</code>,
and the order in which we specify the arguments matters. However, in Rust,
they’re called <code>left</code> and <code>right</code>, and the order in which we specify the value
we expect and the value that the code under test produces doesn’t matter. We
could write the assertion in this test as <code>assert_eq!(add_two(2), 4)</code>, which
would result in a failure message that displays <code>assertion failed: `(left == right)`</code> and that <code>left</code> was <code>5</code> and <code>right</code> was <code>4</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>won’t</em> be if our
code is functioning as we intend. For example, if we’re testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the <code>PartialEq</code> and <code>Debug</code> traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, you’ll need to implement <code>PartialEq</code> to assert that values of
those types are equal or not equal. You’ll need to implement <code>Debug</code> to print
out the values when the assertion fails. Because both traits are derivable
traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as
straightforward as adding the <code>#[derive(PartialEq, Debug)]</code> annotation to your
struct or enum definition. See Appendix C for more details about these and
other derivable traits.</p>
<a class="header" href="print.html#adding-custom-failure-messages" id="adding-custom-failure-messages"><h3>Adding Custom Failure Messages</h3></a>
<p>We can also add a custom message to be printed with the failure message as
optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the one required argument to <code>assert!</code> or the two
required arguments to <code>assert_eq!</code> and <code>assert_ne!</code> are passed along to the
<code>format!</code> macro (discussed in Chapter 8 in the “Concatenation with the <code>+</code>
Operator or the <code>format!</code> Macro” section), so you can pass a format string that
contains <code>{}</code> placeholders and values to go in those placeholders. Custom
messages are useful to document what an assertion means; when a test fails,
we’ll have a better idea of what the problem is with the code.</p>
<p>For example, let’s say we have a function that greets people by name, and we
want to test that the name we pass into the function appears in the output:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
#}</code></pre></pre>
<p>The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We
decided we don’t want to have to update the test for the name when that
happens, so instead of checking for exact equality to the value returned from
the <code>greeting</code> function, we’ll just assert that the output contains the text of
the input parameter.</p>
<p>Let’s introduce a bug into this code by changing <code>greeting</code> to not include
<code>name</code> to see what this test failure looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
#}</code></pre></pre>
<p>Running this test produces the following:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'assertion failed:
result.contains(&quot;Carol&quot;)', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the <code>greeting</code> function. Let’s change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the <code>greeting</code> function:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'Greeting did not
contain name, value was `Hello!`', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<a class="header" href="print.html#checking-for-panics-with-should_panic" id="checking-for-panics-with-should_panic"><h3>Checking for Panics with <code>should_panic</code></h3></a>
<p>In addition to checking that our code returns the correct values we expect,
it’s also important to check that our code handles error conditions as we
expect. For example, consider the <code>Guess</code> type that we created in Chapter 9,
Listing 9-9. Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code>
instances will only contain values between 1 and 100. We can write a test that
ensures that attempting to create a <code>Guess</code> instance with a value outside that
range panics.</p>
<p>We do this by adding another attribute, <code>should_panic</code>, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesn’t panic.</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code>
happen when we expect:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-8: Testing that a condition will cause a
<code>panic!</code></span></p>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result when this test
passes:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition
that the <code>new</code> function will panic if the value is greater than 100:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Guess {
#     value: u32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
#}</code></pre></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got
means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise because they only indicate that
the code has caused some panic. A <code>should_panic</code> test would pass even if the
test panics for a different reason than the one we were expecting to happen. To
make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code>
parameter to the <code>should_panic</code> attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function panics with
different messages depending on whether the value was too small or too large:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Guess {
#     value: u32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-9: Testing that a condition will cause a
<code>panic!</code> with a particular panic message</span></p>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is a substring of the message that the <code>Guess::new</code>
function panics with. We could have specified the entire panic message that we
expect, which in this case would be <code>Guess value must be less than or equal to 100, got 200.</code> What you choose to specify in the expected parameter for
<code>should_panic</code> depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the <code>else if value &gt; 100</code> case.</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message
fails, let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
        thread 'tests::greater_than_100' panicked at 'Guess value must be
greater than or equal to 1, got 200.', src/lib.rs:11:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string <code>'Guess value must be less than or equal to 100'</code>. The panic message that we did get in this case was
<code>Guess value must be greater than or equal to 1, got 200.</code> Now we can start
figuring out where our bug is!</p>
<p>Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with <code>cargo test</code>.</p>
<a class="header" href="print.html#controlling-how-tests-are-run" id="controlling-how-tests-are-run"><h2>Controlling How Tests Are Run</h2></a>
<p>Just as <code>cargo run</code> compiles your code and then runs the resulting binary,
<code>cargo test</code> compiles your code in test mode and runs the resulting test
binary. You can specify command line options to change the default behavior of
<code>cargo test</code>. For example, the default behavior of the binary produced by
<code>cargo test</code> is to run all the tests in parallel and capture output generated
during test runs, preventing the output from being displayed and making it
easier to read the output related to the test results.</p>
<p>Some command line options go to <code>cargo test</code> and some go to the resulting test
binary. To separate these two types of arguments, you list the arguments that
go to <code>cargo test</code> followed by the separator <code>--</code> and then the arguments that
go to the test binary. Running <code>cargo test --help</code> displays the options you can
use with <code>cargo test</code>, and running <code>cargo test -- --help</code> displays the options
you can use after the separator <code>--</code>.</p>
<a class="header" href="print.html#running-tests-in-parallel-or-consecutively" id="running-tests-in-parallel-or-consecutively"><h3>Running Tests in Parallel or Consecutively</h3></a>
<p>When you run multiple tests, by default they run in parallel using threads.
This means the tests will finish running faster so you can get feedback quicker
on whether or not your code is working. Because the tests are running at the
same time, make sure your tests don’t depend on each other or on any shared
state, including a shared environment, such as the current working directory or
environment variables.</p>
<p>For example, say each of your tests runs some code that creates a file on disk
named <em>test-output.txt</em> and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file between when another test writes and reads the
file. The second test will then fail, not because the code is incorrect, but
because the tests have interfered with each other while running in parallel.
One solution is to make sure each test writes to a different file; another
solution is to run the tests one at a time.</p>
<p>If you don’t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the <code>--test-threads</code> flag
and the number of threads you want to use to the test binary. Take a look at
the following example:</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<p>We set the number of test threads to <code>1</code>, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests won’t interfere with each other if they share
state.</p>
<a class="header" href="print.html#showing-function-output" id="showing-function-output"><h3>Showing Function Output</h3></a>
<p>By default, if a test passes, Rust’s test library captures anything printed to
standard output. For example, if we call <code>println!</code> in a test and the test
passes, we won’t see the <code>println!</code> output in the terminal: we’ll only see the
line that indicates the test passed. If a test fails, we’ll see whatever was
printed to standard output with the rest of the failure message.</p>
<p>As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-10: Tests for a function that calls
<code>println!</code></span></p>
<p>When we run these tests with <code>cargo test</code>, we’ll see the following output:</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
        I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Note that nowhere in this output do we see <code>I got the value 4</code>, which is what
is printed when the test that passes runs. That output has been captured. The
output from the test that failed, <code>I got the value 8</code>, appears in the section
of the test summary output, which also shows the cause of the test failure.</p>
<p>If we want to see printed values for passing tests as well, we can disable the
output capture behavior by using the <code>--nocapture</code> flag:</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<p>When we run the tests in Listing 11-10 again with the <code>--nocapture</code> flag, we
see the following output:</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Note that the output for the tests and the test results are interleaved; the
reason is that the tests are running in parallel, as we talked about in the
previous section. Try using the <code>--test-threads=1</code> option and the <code>--nocapture</code>
flag, and see what the output looks like then!</p>
<a class="header" href="print.html#running-a-subset-of-tests-by-name" id="running-a-subset-of-tests-by-name"><h3>Running a Subset of Tests by Name</h3></a>
<p>Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing <code>cargo test</code> the name
or names of the test(s) you want to run as an argument.</p>
<p>To demonstrate how to run a subset of tests, we’ll create three tests for our
<code>add_two</code> function, as shown in Listing 11-11, and choose which ones to run:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-11: Three tests with three different
names</span></p>
<p>If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#running-single-tests" id="running-single-tests"><h4>Running Single Tests</h4></a>
<p>We can pass the name of any test function to <code>cargo test</code> to run only that test:</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Only the test with the name <code>one_hundred</code> ran; the other two tests didn’t match
that name. The test output lets us know we had more tests than what this
command ran by displaying <code>2 filtered out</code> at the end of the summary line.</p>
<p>We can’t specify the names of multiple tests in this way; only the first value
given to <code>cargo test</code> will be used. But there is a way to run multiple tests.</p>
<a class="header" href="print.html#filtering-to-run-multiple-tests" id="filtering-to-run-multiple-tests"><h4>Filtering to Run Multiple Tests</h4></a>
<p>We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our tests’ names contain <code>add</code>, we can
run those two by running <code>cargo test add</code>:</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>This command ran all tests with <code>add</code> in the name name and filtered out the
test named <code>one_hundred</code>. Also note that the module in which tests appear
becomes part of the test’s name, so we can run all the tests in a module by
filtering on the module’s name.</p>
<a class="header" href="print.html#ignoring-some-tests-unless-specifically-requested" id="ignoring-some-tests-unless-specifically-requested"><h3>Ignoring Some Tests Unless Specifically Requested</h3></a>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of <code>cargo test</code>. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the <code>ignore</code> attribute to exclude them, as shown
here:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
#}</code></pre></pre>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. Now
when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn’t:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The <code>expensive_test</code> function is listed as <code>ignored</code>. If we want to run only
the ignored tests, we can use <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>By controlling which tests run, you can make sure your <code>cargo test</code> results
will be fast. When you’re at a point where it makes sense to check the results
of the <code>ignored</code> tests and you have time to wait for the results, you can run
<code>cargo test -- --ignored</code> instead.</p>
<a class="header" href="print.html#test-organization" id="test-organization"><h2>Test Organization</h2></a>
<p>As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: <em>unit tests</em> and
<em>integration tests</em>. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to separately and together.</p>
<a class="header" href="print.html#unit-tests" id="unit-tests"><h3>Unit Tests</h3></a>
<p>The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn’t working as
expected. We put unit tests in the <em>src</em> directory in each file with the code
that they’re testing. The convention is that we create a module named <code>tests</code>
in each file to contain the test functions, and we annotate the module with
<code>cfg(test)</code>.</p>
<a class="header" href="print.html#the-tests-module-and-cfgtest" id="the-tests-module-and-cfgtest"><h4>The Tests Module and <code>#[cfg(test)]</code></h4></a>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run
the test code only when we run <code>cargo test</code>, but not when we run <code>cargo build</code>.
This saves compile time when we only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. You’ll
see that because integration tests go in a different directory, they don’t need
the <code>#[cfg(test)]</code> annotation. However, because unit tests go in the same files
as the code, we use <code>#[cfg(test)]</code> to specify that they shouldn’t be included
in the compiled result.</p>
<p>Recall that when we generated the new <code>adder</code> project in the first section of
this chapter, Cargo generated this code for us:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>This code is the automatically generated test module. The attribute <code>cfg</code>
stands for <em>configuration</em> and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is <code>test</code>, which is provided by Rust for compiling and
running tests. By using the <code>cfg</code> attribute, Cargo compiles our test code only
if we actively run the tests with <code>cargo test</code>. This includes any helper
functions that might be within this module, in addition to the functions
annotated with <code>#[test]</code>.</p>
<a class="header" href="print.html#testing-private-functions" id="testing-private-functions"><h4>Testing Private Functions</h4></a>
<p>There’s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust’s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function <code>internal_adder</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-12: Testing a private function</span></p>
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>, but because
tests are just Rust code and the <code>tests</code> module is just another module, we can
import and call <code>internal_adder</code> in a test just fine. If you don’t think
private functions should be tested, there’s nothing in Rust that will compel
you to do so.</p>
<a class="header" href="print.html#integration-tests" id="integration-tests"><h3>Integration Tests</h3></a>
<p>In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
that many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a <em>tests</em> directory.</p>
<a class="header" href="print.html#the-tests-directory" id="the-tests-directory"><h4>The <em>tests</em> Directory</h4></a>
<p>We create a <em>tests</em> directory at the top level of our project directory, next
to <em>src</em>. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.</p>
<p>Let’s create an integration test. With the code in Listing 11-12 still in the
<em>src/lib.rs</em> file, make a <em>tests</em> directory, create a new file named
<em>tests/integration_test.rs</em>, and enter the code in Listing 11-13:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Listing 11-13: An integration test of a function in the
<code>adder</code> crate</span></p>
<p>We’ve added <code>extern crate adder</code> at the top of the code, which we didn’t need
in the unit tests. The reason is that each test in the <code>tests</code> directory is a
separate crate, so we need to import our library into each of them.</p>
<p>We don’t need to annotate any code in <em>tests/integration_test.rs</em> with
<code>#[cfg(test)]</code>. Cargo treats the <code>tests</code> directory specially and compiles files
in this directory only when we run <code>cargo test</code>. Run <code>cargo test</code> now:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as we’ve been
seeing: one line for each unit test (one named <code>internal</code> that we added in
Listing 11-12) and then a summary line for the unit tests.</p>
<p>The integration tests section starts with the line <code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code> (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the <code>Doc-tests adder</code> section starts.</p>
<p>Recall that adding more unit test functions in any <em>src</em> file adds more test
result lines to the unit tests section. Adding more test functions to the
integration test file we created adds more lines to that file’s section. Each
integration test file has its own section, so if we add more files in the
<em>tests</em> directory, there will be more integration test sections.</p>
<p>We can still run a particular integration test function by specifying the test
function’s name as an argument to <code>cargo test</code>. To run all the tests in a
particular integration test file, use the <code>--test</code> argument of <code>cargo test</code>
followed by the name of the file:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>This command runs only the tests in the <em>tests/integration_test.rs</em> file.</p>
<a class="header" href="print.html#submodules-in-integration-tests" id="submodules-in-integration-tests"><h4>Submodules in Integration Tests</h4></a>
<p>As you add more integration tests, you might want to make more than one file in
the <em>tests</em> directory to help organize them; for example, you can group the
test functions by the functionality they’re testing. As mentioned earlier, each
file in the <em>tests</em> directory is compiled as its own separate crate.</p>
<p>Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the <em>tests</em> directory don’t share the same
behavior as files in <em>src</em> do, which you learned in Chapter 7 regarding how to
separate code into modules and files.</p>
<p>The different behavior of files in the <em>tests</em> directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the “Moving Modules
to Other Files” section of Chapter 7 to extract them into a common module. For
example, if we create <em>tests/common.rs</em> and place a function named <code>setup</code> in
it, we can add some code to <code>setup</code> that we want to call from multiple test
functions in multiple test files:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn setup() {
    // setup code specific to your library's tests would go here
}
#}</code></pre></pre>
<p>When we run the tests again, we’ll see a new section in the test output for the
<em>common.rs</em> file, even though this file doesn’t contain any test functions, nor
did we call the <code>setup</code> function from anywhere:</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Having <code>common</code> appear in the test results with <code>running 0 tests</code> displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.</p>
<p>To avoid having <code>common</code> appear in the test output, instead of creating
<em>tests/common.rs</em>, we’ll create <em>tests/common/mod.rs</em>. In the “Rules of Module
Filesystems” section of Chapter 7, we used the naming convention
<em>module_name/mod.rs</em> for files of modules that have submodules, and we don’t
have submodules for <code>common</code> here, but naming the file this way tells Rust not
to treat the <code>common</code> module as an integration test file. When we move the
<code>setup</code> function code into <em>tests/common/mod.rs</em> and delete the
<em>tests/common.rs</em> file, the section in the test output will no longer appear.
Files in subdirectories of the <em>tests</em> directory don’t get compiled as separate
crates or have sections in the test output.</p>
<p>After we’ve created <em>tests/common/mod.rs</em>, we can use it from any of the
integration test files as a module. Here’s an example of calling the <code>setup</code>
function from the <code>it_adds_two</code> test in <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Note that the <code>mod common;</code> declaration is the same as the module declarations
we demonstrated in Listing 7-4. Then in the test function, we can call the
<code>common::setup()</code> function.</p>
<a class="header" href="print.html#integration-tests-for-binary-crates" id="integration-tests-for-binary-crates"><h4>Integration Tests for Binary Crates</h4></a>
<p>If our project is a binary crate that only contains a <em>src/main.rs</em> file and
doesn’t have a <em>src/lib.rs</em> file, we can’t create integration tests in the
<em>tests</em> directory and use <code>extern crate</code> to import functions defined in the
<em>src/main.rs</em> file. Only library crates expose functions that other crates can
call and use; binary crates are meant to be run on their own.</p>
<p>This is one of the reasons Rust projects that provide a binary have a
straightforward <em>src/main.rs</em> file that calls logic that lives in the
<em>src/lib.rs</em> file. Using that structure, integration tests <em>can</em> test the
library crate by using <code>extern crate</code> to exercise the important functionality.
If the important functionality works, the small amount of code in the
<em>src/main.rs</em> file will work as well, and that small amount of code doesn’t
need to be tested.</p>
<a class="header" href="print.html#summary-6" id="summary-6"><h2>Summary</h2></a>
<p>Rust’s testing features provide a way to specify how code should function to
ensure it continues to work as we expect even as we make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Rust’s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
help reduce logic bugs having to do with how your code is expected to behave.</p>
<p>Let’s combine the knowledge you learned in this chapter and in previous
chapters and work on a project in the next chapter!</p>
<a class="header" href="print.html#an-io-project-building-a-command-line-program" id="an-io-project-building-a-command-line-program"><h1>An I/O Project: Building a Command Line Program</h1></a>
<p>This chapter is a recap of the many skills you’ve learned so far and an
exploration of a few more standard library features. We’ll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.</p>
<p>Rust’s speed, safety, <em>single binary</em> output, and cross-platform support make
it an ideal language for creating command line tools, so for our project, we’ll
make our own version of the classic command line tool <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). In the simplest use case,
<code>grep</code> searches a specified file for a specified string. To do so, <code>grep</code> takes
as its arguments a filename and a string, and then reads the file and finds
lines in that file that contain the string argument. It then prints those lines.</p>
<p>Along the way, we’ll show how to make our command line tool use features of the
terminal that many command line tools use. We’ll read the value of an
environment variable to allow the user to configure the behavior of our tool.
We’ll also print to the standard error console stream (<code>stderr</code>) instead of
standard output (<code>stdout</code>), so, for example, the user can redirect successful
output to a file while still seeing error messages onscreen.</p>
<p>One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of <code>grep</code>, called <code>ripgrep</code>. By comparison, our
version of <code>grep</code> will be fairly simple, but this chapter will give you some of
the background knowledge you need to understand a real-world project like
<code>ripgrep</code>.</p>
<p>Our <code>grep</code> project will combine a number of concepts you’ve learned so far:</p>
<ul>
<li>Organizing code (using what you learned in modules, Chapter 7)</li>
<li>Using vectors and strings (collections, Chapter 8)</li>
<li>Handling errors (Chapter 9)</li>
<li>Using traits and lifetimes where appropriate (Chapter 10)</li>
<li>Writing tests (Chapter 11)</li>
</ul>
<p>We’ll also briefly introduce closures, iterators, and trait objects, which
Chapters 13 and 17 will cover in detail.</p>
<a class="header" href="print.html#accepting-command-line-arguments" id="accepting-command-line-arguments"><h2>Accepting Command Line Arguments</h2></a>
<p>Let’s create a new project with, as always, <code>cargo new</code>. We’ll call our project
<code>minigrep</code> to distinguish it from the <code>grep</code> tool that you might already have
on your system.</p>
<pre><code class="language-text">$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>The first task is to make <code>minigrep</code> accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with <code>cargo run</code>, a string to search for, and a path to a file to
search in, like so:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> cannot process arguments we
give it. However, some existing libraries on <a href="https://crates.io/">Crates.io</a>
can help us with writing a program that accepts command line arguments, but
because you’re just learning this concept, let’s implement this capability
ourselves.</p>
<a class="header" href="print.html#reading-the-argument-values" id="reading-the-argument-values"><h3>Reading the Argument Values</h3></a>
<p>To make sure <code>minigrep</code> is able to read the values of command line arguments we
pass to it, we’ll need a function provided in Rust’s standard library, which is
<code>std::env::args</code>. This function returns an <em>iterator</em> of the command line
arguments that were given to <code>minigrep</code>. We haven’t discussed iterators yet
(we’ll cover them fully in Chapter 13), but for now you only need to know two
details about iterators: iterators produce a series of values, and we can call
the <code>collect</code> function on an iterator to turn it into a collection, such as a
vector, containing all the elements the iterator produces.</p>
<p>Use the code in Listing 12-1 to allow your <code>minigrep</code> program to read any
command line arguments passed to it and then collect the values into a vector:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span></p>
<p>First, we bring the <code>std::env</code> module into scope with a <code>use</code> statement so we
can use its <code>args</code> function. Notice that the <code>std::env::args</code> function is
nested in two levels of modules. As we discussed in Chapter 7, in cases where
the desired function is nested in more than one module, it’s conventional to
bring the parent module into scope rather than the function. As a result, we
can easily use other functions from <code>std::env</code>. It’s also less ambiguous than
adding <code>use std::env::args</code> and then calling the function with just <code>args</code>
because <code>args</code> might easily be mistaken for a function that’s defined in the
current module.</p>
<blockquote>
<a class="header" href="print.html#the-args-function-and-invalid-unicode" id="the-args-function-and-invalid-unicode"><h3>The <code>args</code> Function and Invalid Unicode</h3></a>
<p>Note that <code>std::env::args</code> will panic if any argument contains invalid
Unicode. If your program needs to accept arguments containing invalid
Unicode, use <code>std::env::args_os</code> instead. That function returns <code>OsString</code>
values instead of <code>String</code> values. We’ve chosen to use <code>std::env::args</code> here
for simplicity because <code>OsString</code> values differ per platform and are more
complex to work with than <code>String</code> values.</p>
</blockquote>
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and immediately use <code>collect</code>
to turn the iterator into a vector containing all the values produced by the
iterator. We can use the <code>collect</code> function to create many kinds of
collections, so we explicitly annotate the type of <code>args</code> to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, <code>collect</code> is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.</p>
<p>Finally, we print the vector using the debug formatter, <code>:?</code>. Let’s try running
the code with no arguments, and then with two arguments:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Notice that the first value in the vector is <code>&quot;target/debug/minigrep&quot;</code>, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case we want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.</p>
<a class="header" href="print.html#saving-the-argument-values-in-variables" id="saving-the-argument-values-in-variables"><h3>Saving the Argument Values in Variables</h3></a>
<p>Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span></p>
<p>As we saw when we printed the vector, the program’s name takes up the first
value in the vector at <code>args[0]</code>, so we’re starting at index <code>1</code>. The first
argument <code>minigrep</code> takes is the string we’re searching for, so we put a
reference to the first argument in the variable <code>query</code>. The second argument
will be the filename, so we put a reference to the second argument in the
variable <code>filename</code>.</p>
<p>We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments <code>test</code>
and <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file reading
capabilities instead.</p>
<a class="header" href="print.html#reading-a-file" id="reading-a-file"><h2>Reading a File</h2></a>
<p>Now we’ll add functionality to read the file that is specified in the
<code>filename</code> command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure <code>minigrep</code> is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
<em>poem.txt</em> at the root level of your project, and enter the poem “I’m Nobody!
Who are you?”</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listing 12-3: A poem by Emily Dickinson will make a good
test case.</span></p>
<p>With the text in place, edit <em>src/main.rs</em> and add code to open the file, as
shown in Listing 12-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
#     let args: Vec&lt;String&gt; = env::args().collect();
#
#     let query = &amp;args[1];
#     let filename = &amp;args[2];
#
#     println!(&quot;Searching for {}&quot;, query);
    // --snip--
    println!(&quot;In file {}&quot;, filename);

    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Listing 12-4: Reading the contents of the file specified
by the second argument</span></p>
<p>First, we add some more <code>use</code> statements to bring in relevant parts of the
standard library: we need <code>std::fs::File</code> to handle files, and
<code>std::io::prelude::*</code> contains various useful traits for doing I/O, including
file I/O. In the same way that Rust has a general prelude that brings certain
types and functions into scope automatically, the <code>std::io</code> module has its own
prelude of common types and functions you’ll need when working with I/O. Unlike
the default prelude, we must explicitly add a <code>use</code> statement for the prelude
from <code>std::io</code>.</p>
<p>In <code>main</code>, we’ve added three statements: first, we get a mutable handle to the
file by calling the <code>File::open</code> function and passing it the value of the
<code>filename</code> variable. Second, we create a variable called <code>contents</code> and set it
to a mutable, empty <code>String</code>. This will hold the content of the file after we
read it in. Third, we call <code>read_to_string</code> on our file handle and pass a
mutable reference to <code>contents</code> as an argument.</p>
<p>After those lines, we’ve again added a temporary <code>println!</code> statement that
prints the value of <code>contents</code> after the file is read, so we can check that the
program is working so far.</p>
<p>Let’s run this code with any string as the first command line argument (because
we haven’t implemented the searching part yet) and the <em>poem.txt</em> file as the
second argument:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Great! The code read and then printed the content of the file. But the code has
a few flaws. The <code>main</code> function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that we’re not handling errors as well
as we could be. The program is still small so these flaws aren’t a big problem,
but as the program grows, it will be harder to fix them cleanly. It’s good
practice to begin refactoring early on when developing a program, because it’s
much easier to refactor smaller amounts of code. We’ll do that next.</p>
<a class="header" href="print.html#refactoring-to-improve-modularity-and-error-handling" id="refactoring-to-improve-modularity-and-error-handling"><h2>Refactoring to Improve Modularity and Error Handling</h2></a>
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors.</p>
<p>First, our <code>main</code> function now performs two tasks: it parses arguments and
opens files. For such a small function, this isn’t a major problem. However, if
we continue to grow our program inside <code>main</code>, the number of separate tasks the
<code>main</code> function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It’s best to separate functionality so each
function is responsible for one task.</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>filename</code>
are configuration variables to our program, variables like <code>f</code> and <code>contents</code>
are used to perform the program’s logic. The longer <code>main</code> becomes, the more
variables we’ll need to bring into scope; the more variables we have in scope,
the harder it will be to keep track of the purpose of each. It’s best to group
the configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
opening the file fails, but the error message just prints <code>file not found</code>.
Opening a file can fail in a number of ways besides the file being missing: for
example, the file might exist, but we might not have permission to open it.
Right now, if we’re in that situation, we’d print the <code>file not found</code> error
message that would give the user the wrong information!</p>
<p>Fourth, we use <code>expect</code> repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they’ll get an <code>index out of bounds</code> error from Rust that doesn’t clearly explain the problem. It would
be best if all the error handling code was in one place so future maintainers
have only one place to consult in the code if the error handling logic needs to
change. Having all the error handling code in one place will also ensure that
we’re printing messages that will be meaningful to our end users.</p>
<p>Let’s address these four problems by refactoring our project.</p>
<a class="header" href="print.html#separation-of-concerns-for-binary-projects" id="separation-of-concerns-for-binary-projects"><h3>Separation of Concerns for Binary Projects</h3></a>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, the Rust
community has developed a type of guideline process for splitting the separate
concerns of a binary program when <code>main</code> starts getting large. The process has
the following steps:</p>
<ul>
<li>
<p>Split your program into a <em>main.rs</em> and a <em>lib.rs</em>, and move your program’s
logic to <em>lib.rs</em>.</p>
</li>
<li>
<p>While your command line parsing logic is small, it can remain in <em>main.rs</em>.</p>
</li>
<li>
<p>When the command line parsing logic starts getting complicated, extract it
from <em>main.rs</em> and move it to <em>lib.rs</em>.</p>
</li>
<li>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program, and <em>lib.rs</em> handles all the logic of the task at hand. Because we
can’t test the <code>main</code> function directly, this structure lets us test all of our
program’s logic by moving it into functions in <em>lib.rs</em>. The only code that
remains in <em>main.rs</em> will be small enough to verify its correctness by reading
it. Let’s rework our program by following this process.</p>
<a class="header" href="print.html#extracting-the-argument-parser" id="extracting-the-argument-parser"><h4>Extracting the Argument Parser</h4></a>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call to prepare for moving the command line parsing logic to
<em>src/lib.rs</em>. Listing 12-5 shows the new start of <code>main</code> that calls a new
function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em> for the moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listing 12-5: Extracting a <code>parse_config</code> function from
<code>main</code></span></p>
<p>We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index <code>1</code> to the variable <code>query</code> and the
argument value at index <code>2</code> to the variable <code>filename</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that determines which argument
goes in which variable and passes the values back to <code>main</code>. We still create
the <code>query</code> and <code>filename</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of determining how the command line arguments and variables
correspond.</p>
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, because that will help you identify the cause of problems when they
occur.</p>
<a class="header" href="print.html#grouping-configuration-values" id="grouping-configuration-values"><h4>Grouping Configuration Values</h4></a>
<p>We can take another small step to improve the <code>parse_config</code> function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.</p>
<p>Another indicator that shows there’s room for improvement is the <code>config</code> part
of <code>parse_config</code>, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than grouping the two values into a
tuple: we could put the two values into one struct and give each of the struct
fields a meaningful name. Doing so will make it easier for future maintainers
of this code to understand how the different values relate to each other and
what their purpose is.</p>
<blockquote>
<p>Note: Some people call this anti-pattern of using primitive values when a
complex type would be more appropriate <em>primitive obsession</em>.</p>
</blockquote>
<p>Listing 12-6 shows the addition of a struct named <code>Config</code> defined to have
fields named <code>query</code> and <code>filename</code>. We’ve also changed the <code>parse_config</code>
function to return an instance of the <code>Config</code> struct and updated <code>main</code> to use
the struct fields rather than having separate variables:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Listing 12-6: Refactoring <code>parse_config</code> to return an
instance of a <code>Config</code> struct</span></p>
<p>The signature of <code>parse_config</code> now indicates that it returns a <code>Config</code> value.
In the body of <code>parse_config</code>, where we used to return string slices that
reference <code>String</code> values in <code>args</code>, we now define <code>Config</code> to contain owned
<code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of the argument
values and is only letting the <code>parse_config</code> function borrow them, which means
we’d violate Rust’s borrowing rules if <code>Config</code> tried to take ownership of the
values in <code>args</code>.</p>
<p>We could manage the <code>String</code> data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the <code>clone</code> method on
the values. This will make a full copy of the data for the <code>Config</code> instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don’t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.</p>
<blockquote>
<a class="header" href="print.html#the-trade-offs-of-using-clone" id="the-trade-offs-of-using-clone"><h3>The Trade-Offs of Using <code>clone</code></h3></a>
<p>There’s a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In Chapter 13, you’ll learn
how to use more efficient methods in this type of situation. But for now,
it’s okay to copy a few strings to continue making progress because we’ll
make these copies only once, and our filename and query string are very
small. It’s better to have a working program that’s a bit inefficient than to
try to hyperoptimize code on your first pass. As you become more experienced
with Rust, it’ll be easier to start with the most efficient solution, but for
now, it’s perfectly acceptable to call <code>clone</code>.</p>
</blockquote>
<p>We’ve updated <code>main</code> so it places the instance of <code>Config</code> returned by
<code>parse_config</code> into a variable named <code>config</code>, and we updated the code that
previously used the separate <code>query</code> and <code>filename</code> variables so it now uses
the fields on the <code>Config</code> struct instead.</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>filename</code> are related, and
their purpose is to configure how the program will work. Any code that uses
these values knows to find them in the <code>config</code> instance in the fields named
for their purpose.</p>
<a class="header" href="print.html#creating-a-constructor-for-config" id="creating-a-constructor-for-config"><h4>Creating a Constructor for <code>Config</code></h4></a>
<p>So far, we’ve extracted the logic responsible for parsing the command line
arguments from <code>main</code> and placed it in the <code>parse_config</code> function, which
helped us to see that the <code>query</code> and <code>filename</code> values were related and that
relationship should be conveyed in our code. We then added a <code>Config</code> struct to
name the related purpose of <code>query</code> and <code>filename</code>, and to be able to return
the values’ names as struct field names from the <code>parse_config</code> function.</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from being a plain function to a
function named <code>new</code> that is associated with the <code>Config</code> struct. Making this
change will make the code more idiomatic: we can create instances of types in
the standard library, such as <code>String</code>, by calling <code>String::new</code>, and by
changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll
be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7
shows the changes we need to make:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 12-7: Changing <code>parse_config</code> into
<code>Config::new</code></span></p>
<p>We’ve updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We’ve changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try
compiling this code again to make sure it works.</p>
<a class="header" href="print.html#fixing-the-error-handling" id="fixing-the-error-handling"><h3>Fixing the Error Handling</h3></a>
<p>Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the <code>args</code> vector at index <code>1</code> or index <code>2</code> will cause the
program to panic if the vector contains fewer than three items. Try running the
program without any arguments; it will look like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error
message intended for programmers. It won’t help our end users understand what
happened and what they should do instead. Let’s fix that now.</p>
<a class="header" href="print.html#improving-the-error-message" id="improving-the-error-message"><h4>Improving the Error Message</h4></a>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the
slice is long enough before accessing index <code>1</code> and <code>2</code>. If the slice isn’t
long enough, the program panics and displays a better error message than the
<code>index out of bounds</code> message:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">Listing 12-8: Adding a check for the number of
arguments</span></p>
<p>This code is similar to the <code>Guess::new</code> function we wrote in Listing 9-9 where
we called <code>panic!</code> when the <code>value</code> argument was out of the range of valid
values. Instead of checking for a range of values here, we’re checking that the
length of <code>args</code> is at least <code>3</code> and the rest of the function can operate under
the assumption that this condition has been met. If <code>args</code> has fewer than three
items, this condition will be true, and we call the <code>panic!</code> macro to end the
program immediately.</p>
<p>With these extra few lines of code in <code>new</code>, let’s run the program without any
arguments again to see what the error looks like now:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps using
the technique we used in Listing 9-9 isn’t the best to use here: a call to
<code>panic!</code> is more appropriate for a programming problem rather than a usage
problem, as discussed in Chapter 9. Instead, we can use the other technique you
learned about in Chapter 9—returning a <code>Result</code> that indicates either success
or an error.</p>
<a class="header" href="print.html#returning-a-result-from-new-instead-of-calling-panic" id="returning-a-result-from-new-instead-of-calling-panic"><h4>Returning a <code>Result</code> from <code>new</code> Instead of Calling <code>panic!</code></h4></a>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in
the successful case and will describe the problem in the error case. When
<code>Config::new</code> is communicating to <code>main</code>, we can use the <code>Result</code> type to
signal there was a problem. Then we can change <code>main</code> to convert an <code>Err</code>
variant into a more practical error for our users without the surrounding text
about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>Listing 12-9 shows the changes we need to make to the return value of
<code>Config::new</code> and the body of the function needed to return a <code>Result</code>. Note
that this won’t compile until we update <code>main</code> as well, which we’ll do in the
next listing:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listing 12-9: Returning a <code>Result</code> from
<code>Config::new</code></span></p>
<p>Our <code>new</code> function now returns a <code>Result</code> with a <code>Config</code> instance in the
success case and a <code>&amp;'static str</code> in the error case. Recall from “The Static
Lifetime” section in Chapter 10 that <code>&amp;'static str</code> is the type of string
literals, which is our error message type for now.</p>
<p>We’ve made two changes in the body of the <code>new</code> function: instead of calling
<code>panic!</code> when the user doesn’t pass enough arguments, we now return an <code>Err</code>
value, and we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes
make the function conform to its new type signature.</p>
<p>Returning an <code>Err</code> value from <code>Config::new</code> allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>new</code> function and exit the process
more cleanly in the error case.</p>
<a class="header" href="print.html#calling-confignew-and-handling-errors" id="calling-confignew-and-handling-errors"><h4>Calling <code>Config::new</code> and Handling Errors</h4></a>
<p>To handle the error case and print a user-friendly message, we need to update
<code>main</code> to handle the <code>Result</code> being returned by <code>Config::new</code>, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code from <code>panic!</code> and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">Listing 12-10: Exiting with an error code if creating a
new <code>Config</code> fails</span></p>
<p>In this listing, we’ve used a method we haven’t covered before:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar
to <code>unwrap</code>: it returns the inner value <code>Ok</code> is wrapping. However, if the value
is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is an
anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We’ll
cover closures in more detail in Chapter 13. For now, you just need to know
that <code>unwrap_or_else</code> will pass the inner value of the <code>Err</code>, which in this
case is the static string <code>not enough arguments</code> that we added in Listing 12-9,
to our closure in the argument <code>err</code> that appears between the vertical pipes.
The code in the closure can then use the <code>err</code> value when it runs.</p>
<p>We’ve added a new <code>use</code> line to import <code>process</code> from the standard library. The
code in the closure that will be run in the error case is only two lines: we
print the <code>err</code> value and then call <code>process::exit</code>. The <code>process::exit</code>
function will stop the program immediately and return the number that was
passed as the exit status code. This is similar to the <code>panic!</code>-based handling
we used in Listing 12-8, but we no longer get all the extra output. Let’s try
it:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<a class="header" href="print.html#extracting-logic-from-main" id="extracting-logic-from-main"><h3>Extracting Logic from <code>main</code></h3></a>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in “Separation of Concerns for Binary
Projects”, we’ll extract a function named <code>run</code> that will hold all the logic
currently in the <code>main</code> function that isn’t involved with setting up
configuration or handling errors. When we’re done, <code>main</code> will be concise and
easy to verify by inspection, and we’ll be able to write tests for all the
other logic.</p>
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">Listing 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<a class="header" href="print.html#returning-errors-from-the-run-function" id="returning-errors-from-the-run-function"><h4>Returning Errors from the <code>run</code> Function</h4></a>
<p>With the remaining program logic separated into the <code>run</code> function, we can
improve the error handling, as we did with <code>Config::new</code> in Listing 12-9.
Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code>
function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let
us further consolidate into <code>main</code> the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of <code>run</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listing 12-12: Changing the <code>run</code> function to return
<code>Result</code></span></p>
<p>We’ve made three significant changes here. First, we changed the return type of
the <code>run</code> function to <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>. This function previously
returned the unit type, <code>()</code>, and we keep that as the value returned in the
<code>Ok</code> case.</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;Error&gt;</code> (and we’ve brought
<code>std::error::Error</code> into scope with a <code>use</code> statement at the top). We’ll cover
trait objects in Chapter 17. For now, just know that <code>Box&lt;Error&gt;</code> means the
function will return a type that implements the <code>Error</code> trait, but we don’t
have to specify what particular type the return value will be. This gives us
flexibility to return error values that may be of different types in different
error cases.</p>
<p>Second, we’ve removed the calls to <code>expect</code> in favor of <code>?</code>, as we talked about
in Chapter 9. Rather than <code>panic!</code> on an error, <code>?</code> will return the error value
from the current function for the caller to handle.</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case. We’ve
declared the <code>run</code> function’s success type as <code>()</code> in the signature, which
means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code>
syntax might look a bit strange at first, but using <code>()</code> like this is the
idiomatic way to indicate that we’re calling <code>run</code> for its side effects only;
it doesn’t return a value we need.</p>
<p>When you run this code, it will compile but will display a warning:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value, and the <code>Result</code> value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error handling code here! Let’s rectify that problem now.</p>
<a class="header" href="print.html#handling-errors-returned-from-run-in-main" id="handling-errors-returned-from-run-in-main"><h4>Handling Errors Returned from <code>run</code> in <code>main</code></h4></a>
<p>We’ll check for errors and handle them using a technique similar to the way we
handled errors with <code>Config::new</code> in Listing 12-10, but with a slight
difference:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an
<code>Err</code> value and call <code>process::exit(1)</code> if it does. The <code>run</code> function doesn’t
return a value that we want to <code>unwrap</code> in the same way that <code>Config::new</code>
returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in the success case,
we only care about detecting an error, so we don’t need <code>unwrap_or_else</code> to
return the unwrapped value because it would only be <code>()</code>.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases: we print the error and exit.</p>
<a class="header" href="print.html#splitting-code-into-a-library-crate" id="splitting-code-into-a-library-crate"><h3>Splitting Code into a Library Crate</h3></a>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file so we can test
it and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>Let’s move all the code that isn’t the <code>main</code> function from <em>src/main.rs</em> to
<em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::new</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won't
compile until we modify <em>src/main.rs</em> in the listing after this one:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 12-13: Moving <code>Config</code> and <code>run</code> into
<em>src/lib.rs</em></span></p>
<p>We’ve made liberal use of <code>pub</code> here: on <code>Config</code>, its fields and its <code>new</code>
method, and on the <code>run</code> function. We now have a library crate that has a
public API that we can test!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em>, as shown in Listing 12-14:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listing 12-14: Bringing the <code>minigrep</code> crate into the
scope of <em>src/main.rs</em></span></p>
<p>To bring the library crate into the binary crate, we use <code>extern crate minigrep</code>. Then we’ll add a <code>use minigrep::Config</code> line to bring the <code>Config</code>
type into scope, and we’ll prefix the <code>run</code> function with our crate name. Now
all the functionality should be connected and should work. Run the program with
<code>cargo run</code> and make sure everything works correctly.</p>
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!</p>
<a class="header" href="print.html#developing-the-librarys-functionality-with-test-driven-development" id="developing-the-librarys-functionality-with-test-driven-development"><h2>Developing the Library’s Functionality with Test Driven Development</h2></a>
<p>Now that we’ve extracted the logic into <em>src/lib.rs</em> and left the argument
collecting and error handling in <em>src/main.rs</em>, it’s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the <code>Config::new</code> and <code>run</code> functions on your own.</p>
<p>In this section, we’ll add the searching logic to the <code>minigrep</code> program by
using the Test Driven Development (TDD) process. This software development
technique follows these steps:</p>
<ol>
<li>Write a test that fails, and run it to make sure it fails for the reason you
expected.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed, and make sure the tests
continue to pass.</li>
<li>Repeat from step 1!</li>
</ol>
<p>This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.</p>
<p>We’ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
<code>search</code>.</p>
<a class="header" href="print.html#writing-a-failing-test" id="writing-a-failing-test"><h3>Writing a Failing Test</h3></a>
<p>Because we don’t need them anymore, let’s remove the <code>println!</code> statements from
<em>src/lib.rs</em> and <em>src/main.rs</em> that we used to check the program’s behavior.
Then, in <em>src/lib.rs</em>, we’ll add a <code>test</code> module with a test function, as we
did in Chapter 11. The test function specifies the behavior we want the
<code>search</code> function to have: it will take a query and the text to search for the
query in, and will return only the lines from the text that contain the query.
Listing 12-15 shows this test, which won't compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-15: Creating a failing test for the <code>search</code>
function we wish we had</span></p>
<p>This test searches for the string “duct.” The text we’re searching is three
lines, only one of which contains “duct.” We assert that the value returned
from the <code>search</code> function contains only the line we expect.</p>
<p>We aren’t able to run this test and watch it fail because the test doesn’t even
compile: the <code>search</code> function doesn’t exist yet! So now we’ll add just enough
code to get the test to compile and run by adding a definition of the <code>search</code>
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn’t match a vector
containing the line <code>&quot;safe, fast, productive.&quot;</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-16: Defining just enough of the <code>search</code>
function so our test will compile</span></p>
<p>Notice that we need an explicit lifetime <code>'a</code> defined in the signature of
<code>search</code> and used with the <code>contents</code> argument and the return value. Recall in
Chapter 10 that the lifetime parameters specify which argument lifetime is
connected to the lifetime of the return value. In this case, we indicate that
the returned vector should contain string slices that reference slices of the
argument <code>contents</code> (rather than the argument <code>query</code>).</p>
<p>In other words, we tell Rust that the data returned by the <code>search</code> function
will live as long as the data passed into the <code>search</code> function in the
<code>contents</code> argument. This is important! The data referenced <em>by</em> a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of <code>query</code> rather than <code>contents</code>, it will do its safety checking
incorrectly.</p>
<p>If we forget the lifetime annotations and try to compile this function, we’ll
get this error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust can’t possibly know which of the two arguments we need, so we need to tell
it. Because <code>contents</code> is the argument that contains all of our text and we
want to return the parts of that text that match, we know <code>contents</code> is the
argument that should be connected to the return value using the lifetime syntax.</p>
<p>Other programming languages don’t require you to connect arguments to return
values in the signature, so although this might seem strange, it will get
easier over time. You might want to compare this example with the “Validating
References with Lifetimes” section in Chapter 10.</p>
<p>Now let’s run the test:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
        thread 'test::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Great, the test fails, exactly as we expected. Let’s get the test to pass!</p>
<a class="header" href="print.html#writing-code-to-pass-the-test" id="writing-code-to-pass-the-test"><h3>Writing Code to Pass the Test</h3></a>
<p>Currently, our test is failing because we always return an empty vector. To fix
that and implement <code>search</code>, our program needs to follow these steps:</p>
<ul>
<li>Iterate through each line of the contents.</li>
<li>Check whether the line contains our query string.</li>
<li>If it does, add it to the list of values we’re returning.</li>
<li>If it doesn’t, do nothing.</li>
<li>Return the list of results that match.</li>
</ul>
<p>Let’s work through each step, starting with iterating through lines.</p>
<a class="header" href="print.html#iterating-through-lines-with-the-lines-method" id="iterating-through-lines-with-the-lines-method"><h4>Iterating Through Lines with the <code>lines</code> Method</h4></a>
<p>Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note this
won’t compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
</code></pre>
<p><span class="caption">Listing 12-17: Iterating through each line in <code>contents</code>
</span></p>
<p>The <code>lines</code> method returns an iterator. We’ll talk about iterators in depth in
Chapter 13, but recall that you saw this way of using an iterator in Listing
3-4, where we used a <code>for</code> loop with an iterator to run some code on each item
in a collection.</p>
<a class="header" href="print.html#searching-each-line-for-the-query" id="searching-each-line-for-the-query"><h4>Searching Each Line for the Query</h4></a>
<p>Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named <code>contains</code> that does this for
us! Add a call to the <code>contains</code> method in the <code>search</code> function, as shown in
Listing 12-18. Note this still won’t compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in <code>query</code></span></p>
<a class="header" href="print.html#storing-matching-lines" id="storing-matching-lines"><h4>Storing Matching Lines</h4></a>
<p>We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the <code>for</code> loop and call the <code>push</code> method
to store a <code>line</code> in the vector. After the <code>for</code> loop, we return the vector, as
shown in Listing 12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span></p>
<p>Now the <code>search</code> function should return only the lines that contain <code>query</code>,
and our test should pass. Let’s run the test:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Our test passed, so we know it works!</p>
<p>At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in Chapter 13 where we’ll explore iterators in detail
and look at how to improve it.</p>
<a class="header" href="print.html#using-the-search-function-in-the-run-function" id="using-the-search-function-in-the-run-function"><h4>Using the <code>search</code> Function in the <code>run</code> Function</h4></a>
<p>Now that the <code>search</code> function is working and tested, we need to call <code>search</code>
from our <code>run</code> function. We need to pass the <code>config.query</code> value and the
<code>contents</code> that <code>run</code> reads from the file to the <code>search</code> function. Then <code>run</code>
will print each line returned from <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>We’re still using a <code>for</code> loop to return each line from <code>search</code> and print it.</p>
<p>Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, “frog”:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Now let’s try a word that will match multiple lines, like “body”:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as “monomorphization”:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.</p>
<p>To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.</p>
<a class="header" href="print.html#working-with-environment-variables" id="working-with-environment-variables"><h2>Working with Environment Variables</h2></a>
<p>We’ll improve <code>minigrep</code> by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead we’ll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.</p>
<a class="header" href="print.html#writing-a-failing-test-for-the-case-insensitive-search-function" id="writing-a-failing-test-for-the-case-insensitive-search-function"><h3>Writing a Failing Test for the Case-Insensitive <code>search</code> Function</h3></a>
<p>We want to add a new <code>search_case_insensitive</code> function that we’ll call when
the environment variable is on. We’ll continue to follow the TDD process, so
the first step is again to write a failing test. We’ll add a new test for the
new <code>search_case_insensitive</code> function and rename our old test from
<code>one_result</code> to <code>case_sensitive</code> to clarify the differences between the two
tests, as shown in Listing 12-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-20: Adding a new failing test for the
case-insensitive function we’re about to add</span></p>
<p>Note that we’ve edited the old test’s <code>contents</code> too. We’ve added a new line
with the text <code>“Duct tape”</code> using a capital D that shouldn’t match the query
“duct” when we’re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don’t accidentally break the case-sensitive
search functionality that we’ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.</p>
<p>The new test for the case-<em>insensitive</em> search uses “rUsT” as its query. In the
<code>search_case_insensitive</code> function we’re about to add, the query “rUsT” should
match the line containing “Rust:” with a capital R and also the line “Trust
me.” even though both have different casing than the query. This is our failing
test, and it will fail to compile because we haven’t yet defined the
<code>search_case_insensitive</code> function. Feel free to add a skeleton implementation
that always returns an empty vector, similar to the way we did for the <code>search</code>
function in Listing 12-16 to see the test compile and fail.</p>
<a class="header" href="print.html#implementing-the-search_case_insensitive-function" id="implementing-the-search_case_insensitive-function"><h3>Implementing the <code>search_case_insensitive</code> Function</h3></a>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost
the same as the <code>search</code> function. The only difference is that we’ll lowercase
the <code>query</code> and each <code>line</code> so whatever the case of the input arguments,
they’ll be the same case when we check whether the line contains the query:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-21: Defining the <code>search_case_insensitive</code>
function to lowercase the query and the line before comparing them</span></p>
<p>First, we lowercase the <code>query</code> string and store it in a shadowed variable with
the same name. Calling <code>to_lowercase</code> on the query is necessary so no matter
whether the user’s query is “rust”, “RUST”, “Rust”, or “rUsT”, we’ll treat the
query as if it was “rust” and be insensitive to the case.</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice, because calling
<code>to_lowercase</code> creates new data rather than referencing existing data. Say the
query is “rUsT”, as an example: that string slice doesn’t contain a lowercase
“u” or “t” for us to use, so we have to allocate a new <code>String</code> containing
“rust”. When we pass <code>query</code> as an argument to the <code>contains</code> method now, we
need to add an ampersand because the signature of <code>contains</code> is defined to take
a string slice.</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> before we check whether it
contains <code>query</code> to lowercase all characters. Now that we’ve converted <code>line</code>
and <code>query</code> to lowercase, we’ll find matches no matter what the case of the
query is.</p>
<p>Let’s see if this implementation passes the tests:</p>
<pre><code class="language-text">running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Great! They passed. Now, let’s call the new <code>search_case_insensitive</code> function
from the <code>run</code> function. First, we’ll add a configuration option to the
<code>Config</code> struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors since we aren’t initializing this
field anywhere yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<p>Note that we added the <code>case_sensitive</code> field that holds a Boolean. Next, we
need the <code>run</code> function to check the <code>case_sensitive</code> field’s value and use
that to decide whether to call the <code>search</code> function or the
<code>search_case_insensitive</code> function, as shown in Listing 12-22. Note this still
won’t compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::File;
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-22: Calling either <code>search</code> or
<code>search_case_insensitive</code> based on the value in <code>config.case_sensitive</code></span></p>
<p>Finally, we need to check for the environment variable. The functions for
working with environment variables are in the <code>env</code> module in the standard
library, so we want to bring that module into scope with a <code>use std::env;</code> line
at the top of <em>src/lib.rs</em>. Then we’ll use the <code>var</code> method from the <code>env</code>
module to check for an environment variable named <code>CASE_INSENSITIVE</code>, as shown
in Listing 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-23: Checking for an environment variable named
<code>CASE_INSENSITIVE</code></span></p>
<p>Here, we create a new variable <code>case_sensitive</code>. To set its value, we call the
<code>env::var</code> function and pass it the name of the <code>CASE_INSENSITIVE</code> environment
variable. The <code>env::var</code> method returns a <code>Result</code> that will be the successful
<code>Ok</code> variant that contains the value of the environment variable if the
environment variable is set. It will return the <code>Err</code> variant if the
environment variable is not set.</p>
<p>We’re using the <code>is_err</code> method on the <code>Result</code> to check whether it’s an error
and therefore unset, which means it <em>should</em> do a case-sensitive search. If the
<code>CASE_INSENSITIVE</code> environment variable is set to anything, <code>is_err</code> will
return false and will perform a case-insensitive search. We don’t care about
the <em>value</em> of the environment variable, just whether it’s set or unset, so
we’re checking <code>is_err</code> rather than <code>unwrap</code>, <code>expect</code>, or any of the other
methods we’ve seen on <code>Result</code>.</p>
<p>We pass the value in the <code>case_sensitive</code> variable to the <code>Config</code> instance so
the <code>run</code> function can read that value and decide whether to call <code>search</code> or
<code>search_case_insensitive</code> as we implemented in Listing 12-22.</p>
<p>Let’s give it a try! First, we’ll run our program without the environment
variable set and with the query “to”, which should match any line that contains
the word “to” in all lowercase:</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now, let’s run the program with <code>CASE_INSENSITIVE</code>
set to <code>1</code> but with the same query “to”; we should get lines that contain “to”
that might have uppercase letters:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>If you’re using PowerShell, you will need to set the environment variable and
run the program in two commands rather than one:</p>
<pre><code class="language-text">$ $env.CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<p>Excellent, we also got lines containing “To”! Our <code>minigrep</code> program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables!</p>
<p>Some programs allow arguments <em>and</em> environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.</p>
<a class="header" href="print.html#writing-error-messages-to-standard-error-instead-of-standard-output" id="writing-error-messages-to-standard-error-instead-of-standard-output"><h2>Writing Error Messages to Standard Error Instead of Standard Output</h2></a>
<p>At the moment we’re writing all of our output to the terminal using the
<code>println!</code> function. Most terminals provide two kinds of output: <em>standard
output</em> (<code>stdout</code>) for general information and <em>standard error</em> (<code>stderr</code>)
for error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.</p>
<p>The <code>println!</code> function is only capable of printing to standard output, so we
have to use something else to print to standard error.</p>
<a class="header" href="print.html#checking-where-errors-are-written-to" id="checking-where-errors-are-written-to"><h3>Checking Where Errors Are Written to</h3></a>
<p>First, let’s observe how the content printed by <code>minigrep</code> is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We won’t redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.</p>
<p>Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
we’re about to see that it saves the error message output to a file instead!</p>
<p>The way to demonstrate this behavior is by running the program with <code>&gt;</code> and the
filename, <em>output.txt</em>, that we want to redirect the standard output stream to.
We won’t pass any arguments, which should cause an error:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard output to
<em>output.txt</em> instead of the screen. We didn’t see the error message we were
expecting printed on the screen, so that means it must have ended up in the
file. This is what <em>output.txt</em> contains:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error and have
only data from a successful run end up in the file when we redirect standard
output this way. We’ll change that.</p>
<a class="header" href="print.html#printing-errors-to-standard-error" id="printing-errors-to-standard-error"><h3>Printing Errors to Standard Error</h3></a>
<p>We’ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, <code>main</code>. The standard library provides
the <code>eprintln!</code> macro that prints to the standard error stream, so let’s change
the two places we were calling <code>println!</code> to print errors to use <code>eprintln!</code>
instead:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listing 12-24: Writing error messages to standard error
instead of standard output using <code>eprintln!</code></span></p>
<p>After changing <code>println!</code> to <code>eprintln!</code>, let’s run the program again in the
same way, without any arguments and redirecting standard output with <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Now we see the error onscreen and <em>output.txt</em> contains nothing, which is the
behavior we expect of command line programs.</p>
<p>Let’s run the program again with arguments that don’t cause an error but still
redirect standard output to a file, like so:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>We won’t see any output to the terminal, and <em>output.txt</em> will contain our
results:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>This demonstrates that we’re now using standard output for successful output
and standard error for error output as appropriate.</p>
<a class="header" href="print.html#summary-7" id="summary-7"><h2>Summary</h2></a>
<p>In this chapter, we’ve recapped some of the major concepts you’ve learned so
far and covered how to do common I/O operations in a Rust context. By using
command line arguments, files, environment variables, and the <code>eprintln!</code> macro
for printing errors, you’re now prepared to write command line applications. By
using the concepts in previous chapters, your code will be well organized,
store data effectively in the appropriate data structures, handle errors
nicely, and be well tested.</p>
<p>Next, we’ll explore some Rust features that were influenced by functional
languages: closures and iterators.</p>
<a class="header" href="print.html#functional-language-features-iterators-and-closures" id="functional-language-features-iterators-and-closures"><h1>Functional Language Features: Iterators and Closures</h1></a>
<p>Rust’s design has taken inspiration from many existing languages and
techniques, and one significant influence is <em>functional programming</em>.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.</p>
<p>In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.</p>
<p>More specifically, we’ll cover:</p>
<ul>
<li><em>Closures</em>, a function-like construct you can store in a variable</li>
<li><em>Iterators</em>, a way of processing a series of elements</li>
<li>How to use these two features to improve the I/O project in Chapter 12</li>
<li>The performance of these two features (Spoiler alert: they’re faster than you
might think!)</li>
</ul>
<p>Other Rust features are influenced by the functional style as well, such as
pattern matching and enums, which we’ve covered in other chapters. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so we’ll devote this entire chapter to them.</p>
<a class="header" href="print.html#closures-anonymous-functions-that-can-capture-their-environment" id="closures-anonymous-functions-that-can-capture-their-environment"><h2>Closures: Anonymous Functions that Can Capture Their Environment</h2></a>
<p>Rust’s <em>closures</em> are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place, and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re called. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<a class="header" href="print.html#creating-an-abstraction-of-behavior-with-closures" id="creating-an-abstraction-of-behavior-with-closures"><h3>Creating an Abstraction of Behavior with Closures</h3></a>
<p>Let’s work on an example of a situation in which it’s useful to store a closure
to be executed at a later time. Along the way, we’ll talk about the syntax of
closures, type inference, and traits.</p>
<p>Consider this hypothetical situation: we work at a startup that’s making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many different
factors, such as the app user’s age, body mass index, preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isn’t
important in this example; what’s important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once, so we don’t make the user wait more than necessary.</p>
<p>We’ll simulate calling this hypothetical algorithm with the
<code>simulated_expensive_calculation</code> function shown in Listing 13-1, which will
print <code>calculating slowly...</code>, wait for two seconds, and then return whatever
number we passed in:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about two seconds to run</span></p>
<p>Next is the <code>main</code> function that contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
app’s frontend isn’t relevant to the use of closures, we’ll hardcode values
representing inputs to our program and print the outputs.</p>
<p>The required inputs are:</p>
<ul>
<li><em>An intensity number from the user</em>, which is specified when they request
a workout to indicate whether they want a low-intensity workout or a
high-intensity workout.</li>
<li><em>A random number</em> that will generate some variety in the workout plans.</li>
</ul>
<p>The output will be the recommended workout plan. Listing 13-2 shows the <code>main</code>
function we’ll use:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
# fn generate_workout(intensity: u32, random_number: u32) {}
</code></pre></pre>
<p><span class="caption">Listing 13-2: A <code>main</code> function with hardcoded values to
simulate user input and random number generation</span></p>
<p>We’ve hardcoded the variable <code>simulated_user_specified_value</code> to 10 and the
variable <code>simulated_random_number</code> to 7 for simplicity’s sake; in an actual
program, we’d get the intensity number from the app frontend and we’d use the
<code>rand</code> crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The <code>main</code> function calls a <code>generate_workout</code> function
with the simulated input values.</p>
<p>Now that we have the context, let’s get to the algorithm. The
<code>generate_workout</code> function in Listing 13-3 contains the business logic of the
app that we’re most concerned with in this example. The rest of the code
changes in this example will be made to this function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the <code>simulated_expensive_calculation</code>
function</span></p>
<p>The code in Listing 13-3 has multiple calls to the slow calculation function.
The first <code>if</code> block calls <code>simulated_expensive_calculation</code> twice, the <code>if</code>
inside the outer <code>else</code> doesn’t call it at all, and the code inside the
second <code>else</code> case calls it once.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>The desired behavior of the <code>generate_workout</code> function is to first check
whether the user wants a low-intensity workout (indicated by a number less
than 25) or a high-intensity workout (a number of 25 or greater).</p>
<p>Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm we’re simulating.</p>
<p>If the user wants a high-intensity workout, there’s some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.</p>
<p>The data science team has let us know that we’ll have to make some changes to
the way we call the algorithm in the future. To simplify the update when those
changes happen, we want to refactor this code so it calls the
<code>simulated_expensive_calculation</code> function only once. We also want to cut the
place where we’re currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we don’t want
to call it if the result isn’t needed, and we still want to call it only once.</p>
<a class="header" href="print.html#refactoring-using-functions" id="refactoring-using-functions"><h4>Refactoring Using Functions</h4></a>
<p>We could restructure the workout program in many ways. First, we’ll try
extracting the duplicated call to the <code>expensive_calculation</code> function into
a variable, as shown in Listing 13-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-4: Extracting the calls to
<code>simulated_expensive_calculation</code> to one place and storing the result in the
<code>expensive_result</code> variable</span></p>
<p>This change unifies all the calls to <code>simulated_expensive_calculation</code> and
solves the problem of the first <code>if</code> block unnecessarily calling the function
twice. Unfortunately, we’re now calling this function and waiting for the
result in all cases, which includes the inner <code>if</code> block that doesn’t use the
result value at all.</p>
<p>We want to define code in one place in our program, but only <em>execute</em> that
code where we actually need the result. This is a use case for closures!</p>
<a class="header" href="print.html#refactoring-with-closures-to-store-code" id="refactoring-with-closures-to-store-code"><h4>Refactoring with Closures to Store Code</h4></a>
<p>Instead of always calling the <code>simulated_expensive_calculation</code> function before
the <code>if</code> blocks, we can define a closure and store the <em>closure</em> in a variable
rather than storing the result, as shown in Listing 13-5. We can actually move
the whole body of <code>simulated_expensive_calculation</code> within the closure we’re
introducing here:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
# expensive_closure(5);
#}</code></pre></pre>
<p><span class="caption">Listing 13-5: Defining a closure and storing it in the
<code>expensive_closure</code> variable</span></p>
<p>The closure definition comes after the <code>=</code> to assign it to the variable
<code>expensive_closure</code>. To define a closure, we start with a pair of vertical
pipes (<code>|</code>), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named <code>num</code>: if we had more than one
parameter, we would separate them with commas, like <code>|param1, param2|</code>.</p>
<p>After the parameters, we place curly brackets that hold the body of the
closure—these are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
<code>let</code> statement. The value returned from the last line in the closure body
(<code>num</code>) will be the value returned from the closure when it’s called, because
that line doesn’t end in a semicolon; just like in function bodies.</p>
<p>Note that this <code>let</code> statement means <code>expensive_closure</code> contains the
<em>definition</em> of an anonymous function, not the <em>resulting value</em> of calling the
anonymous function. Recall that we’re using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in <code>expensive_closure</code>.</p>
<p>With the closure defined, we can change the code in the <code>if</code> blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-6: Calling the <code>expensive_closure</code> we’ve
defined</span></p>
<p>Now the expensive calculation is called in only one place, and we’re only
executing that code where we need the results.</p>
<p>However, we’ve reintroduced one of the problems from Listing 13-3: we’re still
calling the closure twice in the first <code>if</code> block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that <code>if</code> block to hold
the result of calling the closure, but closures provide us with another
solution. We’ll talk about that solution in a bit. But first let’s talk about
why there aren’t type annotations in the closure definition and the traits
involved with closures.</p>
<a class="header" href="print.html#closure-type-inference-and-annotation" id="closure-type-inference-and-annotation"><h3>Closure Type Inference and Annotation</h3></a>
<p>Closures don’t require you to annotate the types of the parameters or the
return value like <code>fn</code> functions do. Type annotations are required on functions
because they’re part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures aren’t used in an
exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Additionally, closures are usually short and only relevant within a narrow
context rather than in any arbitrary scenario. Within these limited contexts,
the compiler is reliably able to infer the types of the parameters and return
type, similar to how it’s able to infer the types of most variables.</p>
<p>Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.</p>
<p>Like variables, we can add type annotations if we want to increase explicitness
and clarity at the cost of being more verbose than is strictly necessary;
annotating the types for the closure we defined in Listing 13-5 would look like
the definition shown in Listing 13-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
#}</code></pre></pre>
<p><span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span></p>
<p>The syntax of closures and functions looks more similar with type annotations.
The following is a vertical comparison of the syntax for the definition of a
function that adds one to its parameter, and a closure that has the same
behavior. We’ve added some spaces to line up the relevant parts. This
illustrates how closure syntax is similar to function syntax except for the use
of pipes and the amount of syntax that is optional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets that are
optional, because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when they’re called.</p>
<p>Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition: if
we then try to call the closure twice, using a <code>String</code> as an argument the
first time and a <code>u32</code> the second time, we’ll get an error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<p><span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked in to the closure in <code>example_closure</code>, and we get a type
error if we try to use a different type with the same closure.</p>
<a class="header" href="print.html#storing-closures-using-generic-parameters-and-the-fn-traits" id="storing-closures-using-generic-parameters-and-the-fn-traits"><h3>Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</h3></a>
<p>Let’s return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable instead in each place we need the
result instead of calling the closure again. However, this method could result
in a lot of repeated code.</p>
<p>Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will only execute the closure if we need the resulting value, and it
will cache the resulting value so the rest of our code doesn’t have to be
responsible for saving and reusing the result. You may know this pattern as
<em>memoization</em> or <em>lazy evaluation</em>.</p>
<p>To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.</p>
<p>The <code>Fn</code> traits are provided by the standard library. All closures implement at
least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>. We’ll discuss the
difference between these traits in the &quot;Capturing the Environment with
Closures&quot; section; in this example, we can use the <code>Fn</code> trait.</p>
<p>We add types to the <code>Fn</code> trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type <code>u32</code> and returns a <code>u32</code>, so the
trait bound we specify is <code>Fn(u32) -&gt; u32</code>.</p>
<p>Listing 13-9 shows the definition of the <code>Cacher</code> struct that holds a closure
and an optional result value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-9: Defining a <code>Cacher</code> struct that holds a
closure in <code>calculation</code> and an optional result in <code>value</code></span></p>
<p>The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code>. The
trait bounds on <code>T</code> specify that it’s a closure by using the <code>Fn</code> trait. Any
closure we want to store in the <code>calculation</code> field must have one <code>u32</code>
parameter (specified within the parentheses after <code>Fn</code>) and must return a
<code>u32</code> (specified after the <code>-&gt;</code>).</p>
<blockquote>
<p>Note: Functions implement all three of the <code>Fn</code> traits too. If what we want
to do doesn’t require capturing a value from the environment, we can use a
function rather than a closure where we need something that implements an <code>Fn</code>
trait.</p>
</blockquote>
<p>The <code>value</code> field is of type <code>Option&lt;u32&gt;</code>. Before we execute the closure,
<code>value</code> will be <code>None</code>. When code using a <code>Cacher</code> asks for the <em>result</em> of the
closure, the <code>Cacher</code> will execute the closure at that time and store the
result within a <code>Some</code> variant in the <code>value</code> field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
<code>Cacher</code> will return the result held in the <code>Some</code> variant.</p>
<p>The logic around the <code>value</code> field we’ve just described is defined in Listing
13-10:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-10: The caching logic of <code>Cacher</code></span></p>
<p>We want <code>Cacher</code> to manage the struct fields’ values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.</p>
<p>The <code>Cacher::new</code> function takes a generic parameter <code>T</code>, which we’ve defined
as having the same trait bound as the <code>Cacher</code> struct. Then <code>Cacher::new</code>
returns a <code>Cacher</code> instance that holds the closure specified in the
<code>calculation</code> field and a <code>None</code> value in the <code>value</code> field, because we haven’t
executed the closure yet.</p>
<p>When the calling code wants the result of evaluating the closure, instead of
calling the closure directly, it will call the <code>value</code> method. This method
checks whether we already have a resulting value in <code>self.value</code> in a <code>Some</code>;
if we do, it returns the value within the <code>Some</code> without executing the closure
again.</p>
<p>If <code>self.value</code> is <code>None</code>, we call the closure stored in <code>self.calculation</code>,
save the result in <code>self.value</code> for future use, and return the value as well.</p>
<p>Listing 13-11 shows how we can use this <code>Cacher</code> struct in the
<code>generate_workout</code> function from Listing 13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
# impl&lt;T&gt; Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
#
#     fn value(&amp;mut self, arg: u32) -&gt; u32 {
#         match self.value {
#             Some(v) =&gt; v,
#             None =&gt; {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             },
#         }
#     }
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-11: Using <code>Cacher</code> in the <code>generate_workout</code>
function to abstract away the caching logic</span></p>
<p>Instead of saving the closure in a variable directly, we save a new instance of
<code>Cacher</code> that holds the closure. Then, in each place we want the result, we
call the <code>value</code> method on the <code>Cacher</code> instance. We can call the <code>value</code>
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.</p>
<p>Try running this program with the <code>main</code> function from Listing 13-2. Change the
values in the <code>simulated_user_specified_value</code> and <code>simulated_random_number</code>
variables to verify that in all the cases in the various <code>if</code> and <code>else</code>
blocks, <code>calculating slowly...</code> only appears once and only when needed. The
<code>Cacher</code> takes care of the logic necessary to ensure we aren’t calling the
expensive calculation more than we need to, so <code>generate_workout</code> can focus on
the business logic.</p>
<a class="header" href="print.html#limitations-of-the-cacher-implementation" id="limitations-of-the-cacher-implementation"><h3>Limitations of the <code>Cacher</code> Implementation</h3></a>
<p>Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of <code>Cacher</code> that would make reusing it
in different contexts difficult.</p>
<p>The first problem is that a <code>Cacher</code> instance assumes it will always get the
same value for the parameter <code>arg</code> to the <code>value</code> method. That is, this test of
<code>Cacher</code> will fail:</p>
<pre><code class="language-rust ignore">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<p>This test creates a new <code>Cacher</code> instance with a closure that returns the value
passed into it. We call the <code>value</code> method on this <code>Cacher</code> instance with an
<code>arg</code> value of 1 and then an <code>arg</code> value of 2, and we expect that the call to
<code>value</code> with the <code>arg</code> value of 2 should return 2.</p>
<p>Run this test with the <code>Cacher</code> implementation in Listing 13-9 and Listing
13-10, and the test will fail on the <code>assert_eq!</code> with this message:</p>
<pre><code class="language-text">thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/main.rs
</code></pre>
<p>The problem is that the first time we called <code>c.value</code> with 1, the <code>Cacher</code>
instance saved <code>Some(1)</code> in <code>self.value</code>. Thereafter, no matter what we pass in
to the <code>value</code> method, it will always return 1.</p>
<p>Try modifying <code>Cacher</code> to hold a hash map rather than a single value. The keys
of the hash map will be the <code>arg</code> values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether <code>self.value</code> directly has a <code>Some</code> or a <code>None</code> value, the
<code>value</code> function will look up the <code>arg</code> in the hash map and return the value if
it’s present. If it’s not present, the <code>Cacher</code> will call the closure and save
the resulting value in the hash map associated with its <code>arg</code> value.</p>
<p>The second problem with the current <code>Cacher</code> implementation is that it only
accepts closures that take one parameter of type <code>u32</code> and return a <code>u32</code>. We
might want to cache the results of closures that take a string slice and return
<code>usize</code> values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the <code>Cacher</code> functionality.</p>
<a class="header" href="print.html#capturing-the-environment-with-closures" id="capturing-the-environment-with-closures"><h3>Capturing the Environment with Closures</h3></a>
<p>In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions don’t
have: they can capture their environment and access variables from the scope in
which they’re defined.</p>
<p>Listing 13-12 has an example of a closure stored in the variable <code>equal_to_x</code>
that uses the variable <code>x</code> from the closure’s surrounding environment:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span></p>
<p>Here, even though <code>x</code> is not one of the parameters of <code>equal_to_x</code>, the
<code>equal_to_x</code> closure is allowed to use the <code>x</code> variable that’s defined in the
same scope that <code>equal_to_x</code> is defined in.</p>
<p>We can’t do the same with functions; if we try with the following example, our
code won’t compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>We get an error:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ...
} closure form instead
 --&gt; src/main.rs
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<p>The compiler even reminds us that this only works with closures!</p>
<p>When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
don’t want to pay in more common cases where we want to execute code that
doesn’t capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.</p>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three <code>Fn</code> traits as follows:</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known
as the closure’s <em>environment</em>. To consume the captured variables, the
closure must take ownership of these variables and move them into the closure
when it is defined. The <code>Once</code> part of the name represents the fact that the
closure can’t take ownership of the same variables more than once, so it can
be called only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
<p>When we create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement <code>FnOnce</code>,
because they can all be called at least once. Closures that don't move the
captured variables also implement <code>FnMut</code>, and closures that don't need mutable
access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the
<code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait)
because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If we want to force the closure to take ownership of the values it uses in the
environment, we can use the <code>move</code> keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so it’s owned by the new thread.</p>
<p>We’ll have more examples of <code>move</code> closures in Chapter 16 when we talk about
concurrency. For now, here’s the code from Listing 13-12 with the <code>move</code>
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>We receive the following error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
  implement the `Copy` trait
</code></pre>
<p>The <code>x</code> value is moved into the closure when the closure is defined, because we
added the <code>move</code> keyword. The closure then has ownership of <code>x</code>, and <code>main</code>
isn’t allowed to use <code>x</code> anymore in the <code>println!</code> statement. Removing
<code>println!</code> will fix this example.</p>
<p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start
with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based
on what happens in the closure body.</p>
<p>To illustrate situations where closures that can capture their environment are
useful as function parameters, let’s move on to our next topic: iterators.</p>
<a class="header" href="print.html#processing-a-series-of-items-with-iterators" id="processing-a-series-of-items-with-iterators"><h2>Processing a Series of Items with Iterators</h2></a>
<p>The iterator pattern allows you to perform some task on a sequence of items in
turn. An <em>iterator</em> is responsible for the logic of iterating over each item
and determining when the sequence has finished. When we use iterators, we don’t
have to reimplement that logic ourselves.</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until we call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector <code>v1</code> by calling
the <code>iter</code> method defined on <code>Vec</code>. This code by itself doesn’t do anything
useful:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
#}</code></pre></pre>
<p><span class="caption">Listing 13-13: Creating an iterator</span></p>
<p>Once we’ve created an iterator, we can use it in a variety of ways. In Listing
3-4 in Chapter 3, we used iterators with <code>for</code> loops to execute some code on
each item, although we glossed over what the call to <code>iter</code> did until now.</p>
<p>The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the <code>for</code> loop. The iterator is stored in the <code>v1_iter</code>
variable, and no iteration takes place at that time. When the <code>for</code> loop is
called using the iterator in <code>v1_iter</code>, each element in the iterator is used in
one iteration of the loop, which prints out each value:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-14: Using an iterator in a <code>for</code> loop</span></p>
<p>In languages that don’t have iterators provided by their standard libraries, we
would likely write this same functionality by starting a variable at index 0,
using that variable to index into the vector to get a value, and incrementing
the variable value in a loop until it gets to the total number of items in the
vector.</p>
<p>Iterators handle all that logic for us, cutting down on repetitive code we
could potentially mess up. Iterators give us more flexibility to use the same
logic with many different kinds of sequences, not just data structures we can
index into, like vectors. Let’s examine how iterators do that.</p>
<a class="header" href="print.html#the-iterator-trait-and-the-next-method" id="the-iterator-trait-and-the-next-method"><h3>The <code>Iterator</code> Trait and the <code>next</code> Method</h3></a>
<p>All iterators implement a trait named <code>Iterator</code> that is defined in the
standard library. The definition of the trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
#}</code></pre></pre>
<p>Notice some new syntax that we haven’t covered yet: <code>type Item</code> and
<code>Self::Item</code>, which are defining an <em>associated type</em> with this trait. We’ll
talk about associated types in depth in Chapter 19. For now, all you need to
know is that this code says implementing the <code>Iterator</code> trait requires that you
also define an <code>Item</code> type, and this <code>Item</code> type is used in the return type of
the <code>next</code> method. In other words, the <code>Item</code> type will be the type returned
from the iterator.</p>
<p>The <code>Iterator</code> trait only requires implementors to define one method: the
<code>next</code> method, which returns one item of the iterator at a time wrapped in
<code>Some</code> and, when iteration is over, it returns <code>None</code>.</p>
<p>We can call the <code>next</code> method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to <code>next</code> on the iterator created
from the vector:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-15: Calling the <code>next</code> method on an
iterator</span></p>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an
iterator changes state that keeps track of where it is in the sequence. In
other words, this code <em>consumes</em>, or uses up, the iterator. Each call to
<code>next</code> eats up an item from the iterator. We didn’t need to make <code>v1_iter</code>
mutable when we used a <code>for</code> loop because the loop took ownership of <code>v1_iter</code>
and made it mutable behind the scenes.</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable
references to the values in the vector. The <code>iter</code> method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of
<code>iter</code>. Similarly, if we want to iterate over mutable references, we can call
<code>iter_mut</code> instead of <code>iter</code>.</p>
<a class="header" href="print.html#methods-that-consume-the-iterator" id="methods-that-consume-the-iterator"><h3>Methods that Consume the Iterator</h3></a>
<p>The <code>Iterator</code> trait has a number of different methods with default
implementations provided for us by the standard library; you can find out about
these methods by looking in the standard library API documentation for the
<code>Iterator</code> trait. Some of these methods call the <code>next</code> method in their
definition, which is why we’re required to implement the <code>next</code> method when
implementing the <code>Iterator</code> trait.</p>
<p>Methods that call <code>next</code> are called <em>consuming adaptors</em>, because calling them
uses up the iterator. One example is the <code>sum</code> method, which takes ownership of
the iterator and iterates through the items by repeatedly calling <code>next</code>, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the <code>sum</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-16: Calling the <code>sum</code> method to get the total
of all items in the iterator</span></p>
<p>We aren’t allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes
ownership of the iterator we call it on.</p>
<a class="header" href="print.html#methods-that-produce-other-iterators" id="methods-that-produce-other-iterators"><h3>Methods that Produce Other Iterators</h3></a>
<p>Other methods defined on the <code>Iterator</code> trait, known as <em>iterator adaptors</em>,
allow us to change iterators into different kind of iterators. We can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, we have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.</p>
<p>Listing 13-17 shows an example of calling the iterator adaptor method <code>map</code>,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
#}</code></pre></pre>
<p><span class="caption">Listing 13-17: Calling the iterator adaptor <code>map</code> to
create a new iterator</span></p>
<p>The warning we get is:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>The code in Listing 13-17 doesn’t do anything; the closure we’ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.</p>
<p>To fix this and consume the iterator, we’ll use the <code>collect</code> method, which we
used in Chapter 12 with <code>env::args</code> in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.</p>
<p>In Listing 13-18, we collect the results of iterating over the iterator that’s
returned from the call to <code>map</code> into a vector. This vector will end up
containing each item from the original vector incremented by 1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
#}</code></pre></pre>
<p><span class="caption">Listing 13-18: Calling the <code>map</code> method to create a new
iterator, and then calling the <code>collect</code> method to consume the new iterator and
create a vector</span></p>
<p>Because <code>map</code> takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let us customize some
behavior while reusing the iteration behavior that the <code>Iterator</code> trait
provides.</p>
<a class="header" href="print.html#using-closures-that-capture-their-environment" id="using-closures-that-capture-their-environment"><h3>Using Closures that Capture Their Environment</h3></a>
<p>Now that we’ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the <code>filter</code> iterator adaptor.
The <code>filter</code> method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns <code>true</code>, the value
will be included in the iterator produced by <code>filter</code>. If the closure returns
<code>false</code>, the value won’t be included in the resulting iterator.</p>
<p>In Listing 13-19 we use <code>filter</code> with a closure that captures the <code>shoe_size</code>
variable from its environment to iterate over a collection of <code>Shoe</code> struct
instances. It will return only shoes that are the specified size:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-19: Using the <code>filter</code> method with a closure
that captures <code>shoe_size</code></span></p>
<p>The <code>shoes_in_my_size</code> function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.</p>
<p>In the body of <code>shoes_in_my_size</code>, we call <code>into_iter</code> to create an iterator
that takes ownership of the vector. Then we call <code>filter</code> to adapt that
iterator into a new iterator that only contains elements for which the closure
returns <code>true</code>.</p>
<p>The closure captures the <code>shoe_size</code> parameter from the environment and
compares the value with each shoe’s size, keeping only shoes of the size
specified. Finally, calling <code>collect</code> gathers the values returned by the
adapted iterator into a vector that’s returned by the function.</p>
<p>The test shows that when we call <code>shoes_in_my_size</code>, we only get back shoes
that have the same size as the value we specified.</p>
<a class="header" href="print.html#creating-our-own-iterators-with-iterator" id="creating-our-own-iterators-with-iterator"><h3>Creating Our Own Iterators with <code>Iterator</code></h3></a>
<p>We’ve shown that we can create an iterator by calling <code>iter</code>, <code>into_iter</code>, or
<code>iter_mut</code> on a vector. We can create iterators from the other collection types
in the standard library, such as hash map. We can also create iterators that do
anything we want by implementing the <code>Iterator</code> trait on our own types. As
previously mentioned, the only method we’re required to provide a definition
for is the <code>next</code> method. Once we’ve done that, we can use all other methods
that have default implementations provided by the <code>Iterator</code> trait!</p>
<p>To demonstrate, let’s create an iterator that will only ever count from 1 to 5.
First, we’ll create a struct to hold some values, and then we’ll make this
struct into an iterator by implementing the <code>Iterator</code> trait and use the values
in that implementation.</p>
<p>Listing 13-20 has the definition of the <code>Counter</code> struct and an associated
<code>new</code> function to create instances of <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-20: Defining the <code>Counter</code> struct and a <code>new</code>
function that creates instances of <code>Counter</code> with an initial value of 0 for
<code>count</code></span></p>
<p>The <code>Counter</code> struct has one field named <code>count</code>. This field holds a <code>u32</code>
value that will keep track of where we are in the process of iterating from 1
to 5. The <code>count</code> field is private because we want the implementation of
<code>Counter</code> to manage its value. The <code>new</code> function enforces the behavior of
always starting new instances with a value of 0 in the <code>count</code> field.</p>
<p>Next, we’ll implement the <code>Iterator</code> trait for our <code>Counter</code> type by defining
the body of the <code>next</code> method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-21: Implementing the <code>Iterator</code> trait on our
<code>Counter</code> struct</span></p>
<p>We set the associated <code>Item</code> type for our iterator to <code>u32</code>, meaning the
iterator will return <code>u32</code> values. Again, don’t worry about associated types
yet, we’ll cover them in Chapter 19.</p>
<p>We want our iterator to add one to the current state, so we initialized <code>count</code>
to 0 so it would return 1 first. If the value of <code>count</code> is less than 6, <code>next</code>
will return the current value wrapped in <code>Some</code>, but if <code>count</code> is 6 or higher,
our iterator will return <code>None</code>.</p>
<a class="header" href="print.html#using-our-counter-iterators-next-method" id="using-our-counter-iterators-next-method"><h4>Using Our <code>Counter</code> Iterator’s <code>next</code> Method</h4></a>
<p>Once we’ve implemented the <code>Iterator</code> trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
<code>Counter</code> struct by calling the <code>next</code> method on it directly, just like we did
with the iterator created from a vector in Listing 13-15:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         self.count += 1;
#
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-22: Testing the functionality of the <code>next</code>
method implementation</span></p>
<p>This test creates a new <code>Counter</code> instance in the <code>counter</code> variable and then
calls <code>next</code> repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.</p>
<a class="header" href="print.html#using-other-iterator-trait-methods" id="using-other-iterator-trait-methods"><h4>Using Other <code>Iterator</code> Trait Methods</h4></a>
<p>Because we implemented the <code>Iterator</code> trait by defining the <code>next</code> method, we
can now use any <code>Iterator</code> trait method’s default implementations as defined in
the standard library, because they all use the <code>next</code> method’s functionality.</p>
<p>For example, if for some reason we wanted to take the values produced by an
instance of <code>Counter</code>, pair them with values produced by another <code>Counter</code>
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by three, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -&gt; Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // check to see if we've finished counting or not.
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-23: Using a variety of <code>Iterator</code> trait
methods on our <code>Counter</code> iterator</span></p>
<p>Note that <code>zip</code> produces only four pairs; the theoretical fifth pair <code>(5, None)</code> is never produced because <code>zip</code> returns <code>None</code> when either of its input
iterators return <code>None</code>.</p>
<p>All of these method calls are possible because we specified how the <code>next</code>
method works, and the standard library provides default implementations for
other methods that call <code>next</code>.</p>
<a class="header" href="print.html#improving-our-io-project" id="improving-our-io-project"><h2>Improving Our I/O Project</h2></a>
<p>With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let’s look at how iterators can improve our implementation of the
<code>Config::new</code> function and the <code>search</code> function.</p>
<a class="header" href="print.html#removing-a-clone-using-an-iterator" id="removing-a-clone-using-an-iterator"><h3>Removing a <code>clone</code> Using an Iterator</h3></a>
<p>In Listing 12-6, we added code that took a slice of <code>String</code> values and created
an instance of the <code>Config</code> struct by indexing into the slice and cloning the
values, allowing the <code>Config</code> struct to own those values. In Listing 13-24,
we’ve reproduced the implementation of the <code>Config::new</code> function as it was in
Listing 12-23 at the end of Chapter 12:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<p><span class="caption">Listing 13-24: Reproduction of the <code>Config::new</code> function
from the end of Chapter 12</span></p>
<p>At the time, we said not to worry about the inefficient <code>clone</code> calls because
we would remove them in the future. Well, that time is now!</p>
<p>We needed <code>clone</code> here because we have a slice with <code>String</code> elements in the
parameter <code>args</code>, but the <code>new</code> function doesn’t own <code>args</code>. To return
ownership of a <code>Config</code> instance, we had to clone the values from the <code>query</code>
and <code>filename</code> fields of <code>Config</code> so the <code>Config</code> instance can own its values.</p>
<p>With our new knowledge about iterators, we can change the <code>new</code> function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
<code>Config::new</code> function is doing because the iterator will access the values.</p>
<p>Once <code>Config::new</code> takes ownership of the iterator and stops using indexing
operations that borrow, we can move the <code>String</code> values from the iterator into
<code>Config</code> rather than calling <code>clone</code> and making a new allocation.</p>
<a class="header" href="print.html#using-the-returned-iterator-directly" id="using-the-returned-iterator-directly"><h4>Using the Returned Iterator Directly</h4></a>
<p>Open your I/O project’s <em>src/main.rs</em> file, which should look like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p>We’ll change the start of the <code>main</code> function that we had in Listing 12-24 at
the end of Chapter 12 to the code in Listing 13-25. This won’t compile yet
until we update <code>Config::new</code> as well:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p><span class="caption">Listing 13-25: Passing the return value of <code>env::args</code> to
<code>Config::new</code></span></p>
<p>The <code>env::args</code> function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to <code>Config::new</code>, now
we’re passing ownership of the iterator returned from <code>env::args</code> to
<code>Config::new</code> directly.</p>
<p>Next, we need to update the definition of <code>Config::new</code>. In your I/O project’s
<em>src/lib.rs</em> file, let’s change the signature of <code>Config::new</code> to look like
Listing 13-26. This still won’t compile yet because we need to update the
function body:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
</code></pre>
<p><span class="caption">Listing 13-26: Updating the signature of <code>Config::new</code> to
expect an iterator</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>. We’ve updated the
signature of the <code>Config::new</code> function so the parameter <code>args</code> has the type
<code>std::env::Args</code> instead of <code>&amp;[String]</code>. Because we’re taking ownership of
<code>args</code> and we’ll be mutating <code>args</code> by iterating over it, we can add the <code>mut</code>
keyword into the specification of the <code>args</code> parameter to make it mutable.</p>
<a class="header" href="print.html#using-iterator-trait-methods-instead-of-indexing" id="using-iterator-trait-methods-instead-of-indexing"><h4>Using <code>Iterator</code> Trait Methods Instead of Indexing</h4></a>
<p>Next, we’ll fix the body of <code>Config::new</code>. The standard library documentation
also mentions that <code>std::env::Args</code> implements the <code>Iterator</code> trait, so we know
we can call the <code>next</code> method on it! Listing 13-27 updates the code from
Listing 12-23 to use the <code>next</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::env;
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-27: Changing the body of <code>Config::new</code> to use
iterator methods</span></p>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Second, we call <code>next</code> on the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns a
<code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means
not enough arguments were given and we return early with an <code>Err</code> value. We do
the same thing for the <code>filename</code> value.</p>
<a class="header" href="print.html#making-code-clearer-with-iterator-adaptors" id="making-code-clearer-with-iterator-adaptors"><h3>Making Code Clearer with Iterator Adaptors</h3></a>
<p>We can also take advantage of iterators in the <code>search</code> function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19
at the end of Chapter 12:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 13-28: The implementation of the <code>search</code>
function from Chapter 12</span></p>
<p>We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might make it easier for us to
make a future enhancement to make searching happen in parallel, because we
wouldn’t have to manage concurrent access to the <code>results</code> vector. Listing
13-29 shows this change:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<p><span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the <code>search</code> function</span></p>
<p>Recall that the purpose of the <code>search</code> function is to return all lines in
<code>contents</code> that contain the <code>query</code>. Similar to the <code>filter</code> example in Listing
13-19, we can use the <code>filter</code> adaptor to keep only the lines that
<code>line.contains(query)</code> returns true for. We then collect the matching lines
into another vector with <code>collect</code>. Much simpler! Feel free to make the same
change to use iterator methods in the <code>search_case_insensitive</code> function as
well.</p>
<p>The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. It’s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so it’s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.</p>
<p>But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let’s talk about
performance.</p>
<a class="header" href="print.html#comparing-performance-loops-vs-iterators" id="comparing-performance-loops-vs-iterators"><h2>Comparing Performance: Loops vs. Iterators</h2></a>
<p>To determine whether to use loops or iterators, we need to know which version
of our <code>search</code> functions is faster: the version with an explicit <code>for</code> loop or
the version with iterators.</p>
<p>We ran a benchmark by loading the entire contents of <em>The Adventures of
Sherlock Holmes</em> by Sir Arthur Conan Doyle into a <code>String</code> and looking for the
word “the” in the contents. Here are the results of the benchmark on the
version of <code>search</code> using the <code>for</code> loop and the version using iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>The iterator version was slightly faster! We won’t explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.</p>
<p>For a more comprehensive benchmark, you should check various texts of various
sizes, different words, words of different lengths, and all kinds of other
variations. The point is this: iterators, although a high-level abstraction,
get compiled down to roughly the same code as if you’d written the lower-level
code yourself. Iterators are one of Rust’s <em>zero-cost</em> <em>abstractions</em>, by which
we mean using the abstraction imposes no additional runtime overhead in the
same way that Bjarne Stroustrup, the original designer and implementor of C++,
defines <em>zero-overhead</em>:</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
code any better.</p>
<p>Bjarne Stroustrup’s “Foundations of C++”</p>
</blockquote>
<p>As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
<code>buffer</code> slice of data, an array of 12 <code>coefficients</code>, and an amount by which
to shift data in <code>qlp_shift</code>. We’ve declared the variables within this example
but not given them any values; although this code doesn’t have much meaning
outside of its context, it’s still a concise, real-world example of how Rust
translates high-level ideas to low-level code:</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>To calculate the value of <code>prediction</code>, this code iterates through each of the
12 values in <code>coefficients</code> and uses the <code>zip</code> method to pair the coefficient
values with the previous 12 values in <code>buffer</code>. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum <code>qlp_shift</code> bits to the right.</p>
<p>Calculations in applications like audio decoders often prioritize performance
most highly. Here, we’re creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you’d write by hand.
There’s no loop at all corresponding to the iteration over the values in
<code>coefficients</code>: Rust knows that there are 12 iterations, so it “unrolls” the
loop. <em>Unrolling</em> is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.</p>
<p>All of the coefficients get stored in registers, which means it’s very fast to
access the values. There are no bounds checks on the array access at runtime.
All these optimizations Rust is able to apply make the resulting code extremely
efficient. Now that you know this, you can use iterators and closures without
fear! They make code seem like it’s higher level but don’t impose a runtime
performance penalty for doing so.</p>
<a class="header" href="print.html#summary-8" id="summary-8"><h2>Summary</h2></a>
<p>Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust’s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust’s goal to strive to provide zero-cost abstractions.</p>
<p>Now that we’ve improved the expressiveness of our I/O project, let’s look at
some more features of <code>cargo</code> that will help us share the project with the
world.</p>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More About Cargo and Crates.io</h1></a>
<p>So far we’ve used only the most basic features of Cargo to build, run, and test
our code, but it can do a lot more. In this chapter, we’ll discuss some of its
other, more advanced features to show you how to:</p>
<ul>
<li>Customize your build through release profiles</li>
<li>Publish libraries on <a href="https://crates.io">crates.io</a><!-- ignore --></li>
<li>Organize large projects with workspaces</li>
<li>Install binaries from <a href="https://crates.io">crates.io</a><!-- ignore --></li>
<li>Extend Cargo using custom commands</li>
</ul>
<p>Cargo can do even more than what we cover in this chapter, so for a full
explanation of all its features, see <a href="https://doc.rust-lang.org/cargo/">its
documentation</a>.</p>
<a class="header" href="print.html#customizing-builds-with-release-profiles" id="customizing-builds-with-release-profiles"><h2>Customizing Builds with Release Profiles</h2></a>
<p>In Rust, <em>release profiles</em> are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.</p>
<p>Cargo has two main profiles: the <code>dev</code> profile Cargo uses when you run <code>cargo build</code> and the <code>release</code> profile Cargo uses when you run <code>cargo build --release</code>. The <code>dev</code> profile is defined with good defaults for developing, and
the <code>release</code> profile has good defaults for release builds.</p>
<p>These profile names might be familiar from the output of your builds, which
shows the profile used in the build:</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<p>The <code>dev</code> and <code>release</code> shown in this build output indicate that the compiler
is using different profiles.</p>
<p>Cargo has default settings for each of the profiles that apply when there
aren’t any <code>[profile.*]</code> sections in the project’s <em>Cargo.toml</em> file. By adding
<code>[profile.*]</code> sections for any profile we want to customize, we can override
any subset of the default settings. For example, here are the default values
for the <code>opt-level</code> setting for the <code>dev</code> and <code>release</code> profiles:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>The <code>opt-level</code> setting controls the number of optimizations Rust will apply to
your code with a range of zero to three. Applying more optimizations extends
compiling time, so if you’re in development and compiling your code often, you
want faster compiling even at the expense of the resulting code running slower.
That is the reason the default <code>opt-level</code> for <code>dev</code> is <code>0</code>. When you’re ready
to release your code, it’s best to spend more time compiling. You’ll only
compile in release mode once and run the compiled program many times, so
release mode trades longer compile time for code that runs faster. That is the
reason the default <code>opt-level</code> for the <code>release</code> profile is <code>3</code>.</p>
<p>We can override any default setting by adding a different value for it in
<em>Cargo.toml</em>. For example, if we want to use optimization level 1 in the
development profile, we can add these two lines to our project’s <em>Cargo.toml</em>
file:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>This code overrides the default setting of <code>0</code>. Now when we run <code>cargo</code>
<code>build</code>, Cargo will use the defaults for the <code>dev</code> profile plus our
customization to <code>opt-level</code>. Because we set <code>opt-level</code> to <code>1</code>, Cargo will
apply more optimizations than the default, but not as many as a release build.</p>
<p>For the full list of configuration options and defaults for each profile, see
<a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a>.</p>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h2>Publishing a Crate to Crates.io</h2></a>
<p>We’ve used packages from <a href="https://crates.io">crates.io</a><!-- ignore --> as
dependencies of our project, but you can also share your code for other people
to use by publishing your own packages. The crate registry at
<a href="https://crates.io">crates.io</a><!-- ignore --> distributes the source code of
your packages, so it primarily hosts code that is open source.</p>
<p>Rust and Cargo have features that help make your published package easier for
people to use and to find in the first place. We’ll talk about some of these
features next, and then explain how to publish a package.</p>
<a class="header" href="print.html#making-useful-documentation-comments" id="making-useful-documentation-comments"><h3>Making Useful Documentation Comments</h3></a>
<p>Accurately documenting your packages will help other users know how and when to
use them, so it’s worth spending time writing documentation. In Chapter 3, we
discussed how to comment Rust code using <code>//</code>. Rust also has a particular kind
of comment for documentation, which is known conveniently as <em>documentation
comments</em>, that will generate HTML documentation. The HTML displays the
contents of documentation comments for public API items intended for
programmers interested in knowing how to <em>use</em> your crate as opposed to how
your crate is <em>implemented</em>.</p>
<p>Documentation comments use <code>///</code> instead of <code>//</code> and support Markdown notation
for formatting the text if you want to use it. You place documentation comments
just before the item they’re documenting. Listing 14-1 shows documentation
comments for an <code>add_one</code> function in a crate named <code>my_crate</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, my_crate::add_one(5));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">Listing 14-1: A documentation comment for a
function</span></p>
<p>Here, we give a description of what the <code>add_one</code> function does, start a
section with the heading <code>Examples</code>, and then provide code that demonstrates
how to use the <code>add_one</code> function. We can generate the HTML documentation from
this documentation comment by running <code>cargo doc</code>. This command runs the
<code>rustdoc</code> tool distributed with Rust and puts the generated HTML documentation
in the <em>target/doc</em> directory.</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
<code>add_one</code> function and you’ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1:</p>
<p><img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" /></p>
<p><span class="caption">Figure 14-1: HTML documentation for the <code>add_one</code>
function</span></p>
<a class="header" href="print.html#commonly-used-sections" id="commonly-used-sections"><h4>Commonly Used Sections</h4></a>
<p>We used the <code># Examples</code> Markdown heading in Listing 14-1 to create a section
in the HTML with the title “Examples.” Some other sections that crate authors
commonly use in their documentation include:</p>
<ul>
<li><strong>Panics</strong>: The scenarios in which the function being documented could
<code>panic!</code>. Callers of the function who don’t want their programs to panic
should make sure they don’t call the function in these situations.</li>
<li><strong>Errors</strong>: If the function returns a <code>Result</code>, describing the kinds of
errors that might occur and what conditions might cause those errors to be
returned can be helpful to callers so they can write code to handle the
different kinds of errors in different ways.</li>
<li><strong>Safety</strong>: If the function is <code>unsafe</code> to call (we discuss unsafety in
Chapter 19), there should be a section explaining why the function is unsafe
and covering the invariants that the function expects callers to uphold.</li>
</ul>
<p>Most documentation comment sections don’t need all of these sections, but it’s
a good list to check to remind you of the aspects of your code that people
calling your code will be interested in knowing about.</p>
<a class="header" href="print.html#documentation-comments-as-tests" id="documentation-comments-as-tests"><h4>Documentation Comments as Tests</h4></a>
<p>Adding examples in code blocks in your documentation comments can clearly
demonstrate how to use your library, and doing so has an additional bonus:
running <code>cargo test</code> will run the code examples in your documentation as
tests! Nothing is better than documentation with examples. But nothing is worse
than examples that don’t work because the code has changed since the
documentation was written. Run <code>cargo test</code> with the documentation for the
<code>add_one</code> function from Listing 14-1; you should see a section in the test
results like this:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Now change either the function or the example so the <code>assert_eq!</code> in the
example panics. Run <code>cargo test</code> again; you’ll see that the doc tests catch
that the example and the code are out of sync from one another!</p>
<a class="header" href="print.html#commenting-contained-items" id="commenting-contained-items"><h4>Commenting Contained Items</h4></a>
<p>Another style of doc comment, <code>//!</code>, adds documentation to the item that
contains the comments rather than adding documentation to the items following
the comments. We typically use these doc comments inside the crate root file
(<em>src/lib.rs</em> by convention) or inside a module to document the crate or the
module as a whole.</p>
<p>For example, if we want to add documentation that describes the purpose of the
<code>my_crate</code> crate that contains the <code>add_one</code> function, we can add documentation
comments that start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as
shown in Listing 14-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
</code></pre>
<p><span class="caption">Listing 14-2: Documentation for the <code>my_crate</code> crate as a
whole</span></p>
<p>Notice there isn’t any code after the last line that begins with <code>//!</code>. Because
we started the comments with <code>//!</code> instead of <code>///</code>, we’re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, the item that contains this comment is the <em>src/lib.rs</em> file, which
is the crate root. These comments describe the entire crate.</p>
<p>When we run <code>cargo doc --open</code>, these comments will display on the front
page of the documentation for <code>my_crate</code> above the list of public items in the
crate, as shown in Figure 14-2:</p>
<p><img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" /></p>
<p><span class="caption">Figure 14-2: Rendered documentation for <code>my_crate</code>
including the comment describing the crate as a whole</span></p>
<p>Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the purpose of the container overall to
help your crate users understand your organization.</p>
<a class="header" href="print.html#exporting-a-convenient-public-api-with-pub-use" id="exporting-a-convenient-public-api-with-pub-use"><h3>Exporting a Convenient Public API with <code>pub use</code></h3></a>
<p>In Chapter 7, we covered how to organize our code into modules using the <code>mod</code>
keyword, how to make items public using the <code>pub</code> keyword, and how to bring
items into a scope with the <code>use</code> keyword. However, the structure that makes
sense to you while you’re developing a crate might not be very convenient for
your users. You might want to organize your structs in a hierarchy containing
multiple levels, but people who want to use a type you’ve defined deep in the
hierarchy might have trouble finding out that those types exist. They might
also be annoyed at having to enter <code>use</code>
<code>my_crate::some_module::another_module::UsefulType;</code> rather than <code>use</code>
<code>my_crate::UsefulType;</code>.</p>
<p>The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.</p>
<p>The good news is that if the structure <em>isn’t</em> convenient for others to use
from another library, you don’t have to rearrange your internal organization:
instead, you can re-export items to make a public structure that’s different
than your private structure by using <code>pub use</code>. Re-exporting takes a public
item in one location and makes it public in another location, as if it was
defined in the other location instead.</p>
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts.
Within this library are two modules: a <code>kinds</code> module containing two enums
named <code>PrimaryColor</code> and <code>SecondaryColor</code>, and a <code>utils</code> module containing a
function named <code>mix</code>, as shown in Listing 14-3:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listing 14-3: An <code>art</code> library with items organized into
<code>kinds</code> and <code>utils</code> modules</span></p>
<p>Figure 14-3 shows what the front page of the documentation for this crate
generated by <code>cargo doc</code> would look like:</p>
<p><img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" /></p>
<p><span class="caption">Figure 14-3: Front page of the documentation for <code>art</code>
that lists the <code>kinds</code> and <code>utils</code> modules</span></p>
<p>Note that the <code>PrimaryColor</code> and <code>SecondaryColor</code> types aren’t listed on the
front page, nor is the <code>mix</code> function. We have to click <code>kinds</code> and <code>utils</code> to
see them.</p>
<p>Another crate that depends on this library would need <code>use</code> statements that
import the items from <code>art</code>, including specifying the module structure that’s
currently defined. Listing 14-4 shows an example of a crate that uses the
<code>PrimaryColor</code> and <code>mix</code> items from the <code>art</code> crate:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Listing 14-4: A crate using the <code>art</code> crate’s items with
its internal structure exported</span></p>
<p>The author of the code in Listing 14-4, which uses the <code>art</code> crate, had to
figure out that <code>PrimaryColor</code> is in the <code>kinds</code> module and <code>mix</code> is in the
<code>utils</code> module. The module structure of the <code>art</code> crate is more relevant to
developers working on the <code>art</code> crate than developers using the <code>art</code> crate.
The internal structure that organizes parts of the crate into the <code>kinds</code>
module and the <code>utils</code> module doesn’t contain any useful information for
someone trying to understand how to use the <code>art</code> crate. Instead, the <code>art</code>
crate’s module structure causes confusion because developers have to figure out
where to look, and the structure is inconvenient because developers must
specify the module names in the <code>use</code> statements.</p>
<p>To remove the internal organization from the public API, we can modify the
<code>art</code> crate code in Listing 14-3 to add <code>pub use</code> statements to re-export the
items at the top level, as shown in Listing 14-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 14-5: Adding <code>pub use</code> statements to re-export
items</span></p>
<p>The API documentation that <code>cargo doc</code> generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, which makes the
<code>PrimaryColor</code> and <code>SecondaryColor</code> types and the <code>mix</code> function easier to find:</p>
<p><img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" /></p>
<p><span class="caption">Figure 14-4: Front page of the documentation for <code>art</code>
that lists the re-exports</span></p>
<p>The <code>art</code> crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 14-6: A program using the re-exported items from
the <code>art</code> crate</span></p>
<p>In cases where there are many nested modules, re-exporting the types at the top
level with <code>pub use</code> can make a significant difference in the experience of
people who use the crate.</p>
<p>Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing <code>pub</code>
<code>use</code> gives you flexibility in how you structure your crate internally and
decouples that internal structure with what you present to your users. Look at
some of the code of crates you’ve installed to see if their internal structure
differs from their public API.</p>
<a class="header" href="print.html#setting-up-a-cratesio-account" id="setting-up-a-cratesio-account"><h3>Setting Up a Crates.io Account</h3></a>
<p>Before you can publish any crates, you need to create an account on
<a href="https://crates.io">crates.io</a><!-- ignore --> and get an API token. To do so,
visit the home page at <a href="https://crates.io">crates.io</a><!-- ignore --> and log in
via a GitHub account: the GitHub account is currently a requirement, but the
site might support other ways of creating an account in the future. Once you’re
logged in, visit your account settings at
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> and retrieve your
API key. Then run the <code>cargo</code> <code>login</code> command with your API key, like this:</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in
<em>~/.cargo/credentials</em>. Note that this token is a <em>secret</em>: do not share it
with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on <a href="https://crates.io">crates.io</a><!-- ignore
-->.</p>
<a class="header" href="print.html#before-publishing-a-new-crate" id="before-publishing-a-new-crate"><h3>Before Publishing a New Crate</h3></a>
<p>Now that you have an account, let’s say you have a crate you want to publish.
Before publishing, you’ll need to add some metadata to your crate by adding it
to the <code>[package]</code> section of the crate’s <em>Cargo.toml</em> file.</p>
<p>Your crate will need a unique name. While you’re working on a crate locally,
you can name a crate whatever you’d like. However, crate names on
<a href="https://crates.io">crates.io</a><!-- ignore --> are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Search for the name you want to use on the site to find out if
it has been used. If it hasn’t, edit the name in the <em>Cargo.toml</em> file under
<code>[package]</code> to use the name for publishing, like so:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Even if you’ve chosen a unique name, when you run <code>cargo publish</code> to publish
the crate at this point, you’ll get a warning and then an error:</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
--snip--
error: api errors: missing or empty metadata fields: description, license.
</code></pre>
<p>The reason is that you’re missing some crucial information: a description and
license are required so people will know what your crate does and under what
terms they can use it. To rectify this error, you need to include this
information in the <em>Cargo.toml</em> file.</p>
<p>Add a description that is just a sentence or two, because it will appear with
your crate in search results. For the <code>license</code> field, you need to give a
<em>license identifier value</em>. The Linux Foundation’s Software Package Data
Exchange (SPDX) at <em>http://spdx.org/licenses/</em> lists the identifiers you can
use for this value. For example, to specify that you’ve licensed your crate
using the MIT License, add the <code>MIT</code> identifier:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>If you want to use a license that doesn’t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use <code>license-file</code> to specify the name of that file instead of using the
<code>license</code> key.</p>
<p>Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of <code>MIT OR Apache-2.0</code>, which
demonstrates that you can also specify multiple license identifiers separated
by <code>OR</code> to have multiple licenses for your project.</p>
<p>With a unique name, the version, the author details that <code>cargo new</code> added
when you created the crate, your description, and a license added, the
<em>Cargo.toml</em> file for a project that is ready to publish might look like this:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other
metadata you can specify to ensure others can discover and use your crate more
easily!</p>
<a class="header" href="print.html#publishing-to-cratesio" id="publishing-to-cratesio"><h3>Publishing to Crates.io</h3></a>
<p>Now that you’ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you’re ready to publish!
Publishing a crate uploads a specific version to
<a href="https://crates.io">crates.io</a><!-- ignore --> for others to use.</p>
<p>Be careful when publishing a crate because a publish is <em>permanent</em>. The
version can never be overwritten, and the code cannot be deleted. One major
goal of <a href="https://crates.io">crates.io</a><!-- ignore --> is to act as a permanent
archive of code so that builds of all projects that depend on crates from
<a href="https://crates.io">crates.io</a><!-- ignore --> will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.</p>
<p>Run the <code>cargo publish</code> command again. It should succeed now:</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Congratulations! You’ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.</p>
<a class="header" href="print.html#publishing-a-new-version-of-an-existing-crate" id="publishing-a-new-version-of-an-existing-crate"><h3>Publishing a New Version of an Existing Crate</h3></a>
<p>When you’ve made changes to your crate and are ready to release a new version,
you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and
republish. Use the <a href="http://semver.org/">Semantic Versioning rules</a> to decide what an
appropriate next version number is based on the kinds of changes you’ve made.
Then run <code>cargo publish</code> to upload the new version.</p>
<a class="header" href="print.html#removing-versions-from-cratesio-with-cargo-yank" id="removing-versions-from-cratesio-with-cargo-yank"><h3>Removing Versions from Crates.io with <code>cargo yank</code></h3></a>
<p>Although you can’t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports <em>yanking</em> a crate version.</p>
<p>Yanking a version prevents new projects from starting to depend on that version
while allowing all existing projects that depend on it to continue to download
and depend on that version. Essentially, a yank means that all projects with a
<em>Cargo.lock</em> will not break, and any future <em>Cargo.lock</em> files generated will
not use the yanked version.</p>
<p>To yank a version of a crate, run <code>cargo yank</code> and specify which version you
want to yank:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<p>By adding <code>--undo</code> to the command, you can also undo a yank and allow projects
to start depending on a version again:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>A yank <em>does not</em> delete any code. For example, the yank feature is not
intended for deleting accidentally uploaded secrets. If that happens, you must
reset those secrets immediately.</p>
<a class="header" href="print.html#cargo-workspaces" id="cargo-workspaces"><h2>Cargo Workspaces</h2></a>
<p>In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split up your package further into
multiple library crates. In this situation, Cargo offers a feature called
<em>workspaces</em> that can help manage multiple related packages that are developed
in tandem.</p>
<p>A <em>workspace</em> is a set of packages that share the same <em>Cargo.lock</em> and output
directory. Let’s make a project using a workspace and use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace; we’re going to show a common way. We’ll have a workspace
containing a binary and two libraries. The binary will provide the main
functionality to be used as a command line tool, and it will depend on the two
libraries. One library will provide an <code>add_one</code> function, and a second library
will provide an <code>add_two</code> function. These three crates will be part of the same
workspace. We’ll start by creating a new directory for the workspace:</p>
<pre><code class="language-text">$ mkdir add
$ cd add
</code></pre>
<p>In the <em>add</em> directory, create a <em>Cargo.toml</em> file. This is the <em>Cargo.toml</em>
file that configures the entire workspace. It won’t have a <code>[package]</code> section
or metadata we’ve seen in other <em>Cargo.toml</em> files. Instead, we’ll start with a
<code>[workspace]</code> section and add a member to the workspace by specifying the path
<em>adder</em>, which is where we’ll put our binary crate:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>Next, we’ll create the <code>adder</code> binary crate by running <code>cargo new</code> within the
<em>add</em> directory:</p>
<pre><code class="language-text">$ cargo new --bin adder
     Created binary (application) `adder` project
</code></pre>
<p>At this point, we can build the workspace by running <code>cargo build</code>. The files
in your <em>add</em> directory should look like this:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>The workspace has one <em>target</em> directory at the top level; the <code>adder</code> crate
doesn’t have its own <em>target</em> directory. Even if we go into the <em>adder</em>
directory and run <code>cargo build</code>, the compiled artifacts end up in
<em>add/target</em> rather than <em>add/adder/target</em>. The crates in a workspace are
meant to depend on each other. If each crate had its own <em>target</em> directory,
each crate in the workspace would have to recompile each of the other crates in
the workspace to have the artifacts in its own <em>target</em> directory. By sharing
one <em>target</em> directory, the crates in the workspace can avoid rebuilding the
other crates in the workspace more than necessary.</p>
<a class="header" href="print.html#creating-the-second-crate-in-the-workspace" id="creating-the-second-crate-in-the-workspace"><h3>Creating the Second Crate in the Workspace</h3></a>
<p>Next, let’s specify another member crate in the workspace. This crate will be
in the <em>add-one</em> directory, so change the top-level <em>Cargo.toml</em> to have the
<em>add-one</em> path as well:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<p>Then generate a new library crate named <code>add-one</code>:</p>
<pre><code class="language-text">$ cargo new add-one
     Created library `add-one` project
</code></pre>
<p>Your <em>add</em> directory should now have these directories and files:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>In the <em>add-one/src/lib.rs</em> file, let’s add an <code>add_one</code> function:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>Now that we have a library crate in the workspace, let’s have the binary crate
<code>adder</code> depend on the library crate <code>add-one</code>. First, we’ll need to add a path
dependency on <code>add-one</code> to <em>adder/Cargo.toml</em>:</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<p>Crates in a workspace don’t have to depend on each other, so we still need to
be explicit about the dependency relationships between the crates in a
workspace.</p>
<p>Next, let’s use the <code>add_one</code> function from the <code>add-one</code> crate in the <code>adder</code>
crate. Open the <em>adder/src/main.rs</em> file and add an <code>extern crate</code> line at
the top to bring the new <code>add-one</code> library crate into scope. Then change the
<code>main</code> function to call the <code>add_one</code> function, as in Listing 14-7:</p>
<p><span class="filename">Filename: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<p><span class="caption">Listing 14-7: Using the <code>add-one</code> library crate from the
<code>adder</code> crate</span></p>
<p>Let’s build the workspace by running <code>cargo build</code> in the <em>add</em> directory!</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<p>To run the binary crate from the top-level <em>add</em> directory, we need to specify
which package in the workspace we want to use by using the <code>-p</code> argument and
the package name with <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>This runs the code in <em>adder/src/main.rs</em>, which depends on the <code>add-one</code> crate.</p>
<a class="header" href="print.html#depending-on-an-external-crate-in-a-workspace" id="depending-on-an-external-crate-in-a-workspace"><h4>Depending on an External Crate in a Workspace</h4></a>
<p>Notice that the workspace has only one <em>Cargo.lock</em> file at the top level of
the workspace rather than having a <em>Cargo.lock</em> in each crate’s directory. This
ensures that all crates are using the same version of all dependencies. If we
add the <code>rand</code> crate to the <em>adder/Cargo.toml</em> and <em>add-one/Cargo.toml</em>
files, Cargo will resolve both of those to one version of <code>rand</code> and record
that in the one <em>Cargo.lock</em>. Making all crates in the workspace use the same
dependencies means the crates in the workspace will always be compatible with
each other. Let’s add the <code>rand</code> crate to the <code>[dependencies]</code> section in the
<em>add-one/Cargo.toml</em> file to be able to use the <code>rand</code> crate in the <code>add-one</code>
crate:</p>
<p><span class="filename">Filename: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>We can now add <code>extern crate rand;</code> to the <em>add-one/src/lib.rs</em> file, and
building the whole workspace by running <code>cargo build</code> in the <em>add</em> directory
will bring in and compile the <code>rand</code> crate:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   --snip--
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<p>The top-level <em>Cargo.lock</em> now contains information about the dependency of
<code>add-one</code> on <code>rand</code>. However, even though <code>rand</code> is used somewhere in the
workspace, we can’t use it in other crates in the workspace unless we add
<code>rand</code> to their <em>Cargo.toml</em> files as well. For example, if we add <code>extern crate rand;</code> to the <em>adder/src/main.rs</em> file for the <code>adder</code> crate, we’ll get
an error:</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
 --&gt; adder/src/main.rs:1:1
  |
1 | extern crate rand;
</code></pre>
<p>To fix this, edit the <em>Cargo.toml</em> file for the <code>adder</code> crate and indicate that
<code>rand</code> is a dependency for that crate as well. Building the <code>adder</code> crate will
add <code>rand</code> to the list of dependencies for <code>adder</code> in <em>Cargo.lock</em>, but no
additional copies of <code>rand</code> will be downloaded. Cargo has ensured that any
crate in the workspace using the <code>rand</code> crate will be using the same version.
Using the same version of <code>rand</code> across the workspace saves space because we
won’t have multiple copies and ensures that the crates in the workspace will be
compatible with each other.</p>
<a class="header" href="print.html#adding-a-test-to-a-workspace" id="adding-a-test-to-a-workspace"><h4>Adding a Test to a Workspace</h4></a>
<p>For another enhancement, let’s add a test of the <code>add_one::add_one</code> function
within the <code>add_one</code> crate:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
#}</code></pre></pre>
<p>Now run <code>cargo test</code> in the top-level <em>add</em> directory:</p>
<pre><code class="language-text">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The first section of the output shows that the <code>it_works</code> test in the <code>add-one</code>
crate passed. The next section shows that 0 tests were found in the <code>adder</code>
crate, and then the last section shows 0 documentation tests were found in the
<code>add-one</code> crate. Running <code>cargo test</code> in a workspace structured like this one
will run the tests for all the crates in the workspace.</p>
<p>We can also run tests for one particular crate in a workspace from the
top-level directory by using the <code>-p</code> flag and specifying the name of the crate
we want to test:</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>This output shows <code>cargo test</code> only ran the tests for the <code>add-one</code> crate and
didn’t run the <code>adder</code> crate tests.</p>
<p>If you publish the crates in the workspace to <em>https://crates.io/</em>, each crate
in the workspace will need to be published separately. The <code>cargo publish</code>
command does not have an <code>--all</code> flag or a <code>-p</code> flag, so you must change to
each crate’s directory and run <code>cargo publish</code> on each crate in the workspace
to publish them.</p>
<p>For additional practice, add an <code>add-two</code> crate to this workspace in a similar
way as the <code>add-one</code> crate!</p>
<p>As your project grows, consider using a workspace: it’s easier to understand
smaller, individual components than one big blob of code. Keeping the crates in
a workspace can make coordination between them easier if they are often changed
at the same time.</p>
<a class="header" href="print.html#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install"><h2>Installing Binaries from Crates.io with <code>cargo install</code></h2></a>
<p>The <code>cargo install</code> command allows you to install and use binary crates
locally. This isn’t intended to replace system packages; it’s meant to be a
convenient way for Rust developers to install tools that others have shared on
<a href="https://crates.io">crates.io</a><!-- ignore -->. You can only install packages
that have binary targets. A binary target is the runnable program that is
created if the crate has a <em>src/main.rs</em> file or another file specified as a
binary, as opposed to a library target that isn’t runnable on its own but is
suitable for including within other programs. Usually, crates have information
in the <em>README</em> file about whether a crate is a library, has a binary target,
or both.</p>
<p>All binaries installed with <code>cargo install</code> are stored in the installation
root’s <em>bin</em> folder. If you installed Rust using <em>rustup.rs</em> and don’t have any
custom configurations, this directory will be <em>$HOME/.cargo/bin</em>. Ensure that
directory is in your <code>$PATH</code> to be able to run programs you’ve installed with
<code>cargo install</code>.</p>
<p>For example, in Chapter 12 we mentioned that there’s a Rust implementation of
the <code>grep</code> tool called <code>ripgrep</code> for searching files. If we want to install
<code>ripgrep</code>, we can run the following:</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<p>The last line of the output shows the location and the name of the installed
binary, which in the case of <code>ripgrep</code> is <code>rg</code>. As long as the installation
directory is in your <code>$PATH</code>, as mentioned previously, you can then run <code>rg</code>
<code>--help</code> and start using a faster, rustier tool for searching files!</p>
<a class="header" href="print.html#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands"><h2>Extending Cargo with Custom Commands</h2></a>
<p>Cargo is designed so you can extend it with new subcommands without having to
modify Cargo. If a binary in your <code>$PATH</code> is named <code>cargo-something</code>, you can
run it as if it was a Cargo subcommand by running <code>cargo something</code>. Custom
commands like this are also listed when you run <code>cargo --list</code>. Being able to
use <code>cargo install</code> to install extensions and then run them just like the
built-in Cargo tools is a super convenient benefit of Cargo’s design!</p>
<a class="header" href="print.html#summary-9" id="summary-9"><h2>Summary</h2></a>
<p>Sharing code with Cargo and <a href="https://crates.io">crates.io</a><!-- ignore --> is
part of what makes the Rust ecosystem useful for many different tasks. Rust’s
standard library is small and stable, but crates are easy to share, use, and
improve on a timeline different from the language. Don’t be shy about sharing
code that’s useful to you on <a href="https://crates.io">crates.io</a><!-- ignore -->;
it’s likely that it will be useful to someone else as well!</p>
<a class="header" href="print.html#smart-pointers" id="smart-pointers"><h1>Smart Pointers</h1></a>
<p>A <em>pointer</em> is a general concept for a variable that contains an address in
memory. This address refers to, or “points at,” some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the <code>&amp;</code> symbol and borrow the value they
point to. They don’t have any special capabilities other than referring to
data. Also, they don’t have any overhead and are the kind of pointer we use
most often.</p>
<p><em>Smart pointers</em>, on the other hand, are data structures that act like a
pointer but also have additional metadata and capabilities. The concept of
smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist
in other languages as well. In Rust, the different smart pointers defined in
the standard library provide extra functionality beyond that provided by
references. One example that we’ll explore in this chapter is the <em>reference
counting</em> smart pointer type. This pointer enables you to have multiple owners
of data by keeping track of the number of owners and, when no owners remain,
taking care of cleaning up the data.</p>
<p>In Rust, where we have the concept of ownership and borrowing, an additional
difference between references and smart pointers is that references are
pointers that only borrow data; in contrast, in many cases, smart pointers
<em>own</em> the data they point to.</p>
<p>We’ve already encountered a few smart pointers in this book, such as <code>String</code>
and <code>Vec&lt;T&gt;</code> in Chapter 8, although we didn’t call them smart pointers at the
time. Both these types count as smart pointers because they own some memory and
allow you to manipulate it. They also have metadata (such as their capacity)
and extra capabilities or guarantees (such as with <code>String</code> ensuring its data
will always be valid UTF-8).</p>
<p>Smart pointers are usually implemented using structs. The characteristic that
distinguishes a smart pointer from an ordinary struct is that smart pointers
implement the <code>Deref</code> and <code>Drop</code> traits. The <code>Deref</code> trait allows an instance
of the smart pointer struct to behave like a reference so we can write code
that works with either references or smart pointers. The <code>Drop</code> trait allows us
to customize the code that is run when an instance of the smart pointer goes
out of scope. In this chapter, we’ll discuss both traits and demonstrate why
they’re important to smart pointers.</p>
<p>Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won’t cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. We’ll
cover the most common smart pointers in the standard library:</p>
<ul>
<li><code>Box&lt;T&gt;</code> for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>, a reference counted type that enables multiple ownership</li>
<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces
the borrowing rules at runtime instead of compile time</li>
</ul>
<p>In addition, we’ll cover the <em>interior mutability</em> pattern where an immutable
type exposes an API for mutating an interior value. We’ll also discuss
<em>reference cycles</em>: how they can leak memory and how to prevent them.</p>
<p>Let’s dive in!</p>
<a class="header" href="print.html#boxt-points-to-data-on-the-heap-and-has-a-known-size" id="boxt-points-to-data-on-the-heap-and-has-a-known-size"><h2><code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</h2></a>
<p>The most straightforward smart pointer is a <em>box</em>, whose type is written
<code>Box&lt;T&gt;</code>. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data. Refer to Chapter 4 to
review the difference between the stack and the heap.</p>
<p>Boxes don’t have performance overhead, other than storing their data on the
heap instead of on the stack. But they don’t have many extra capabilities
either. You’ll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time, and you want
to use a value of that type in a context that needs to know an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but
ensure the data won’t be copied when you do so</li>
<li>When you want to own a value and only care that it’s a type that implements a
particular trait rather than knowing the concrete type</li>
</ul>
<p>We’ll demonstrate the first situation in this section. But before we do so,
we’ll elaborate on the other two situations a bit more: in the second case,
transferring ownership of a large amount of data can take a long time because
the data is copied around on the stack. To improve performance in this
situation, we can store the large amount of data on the heap in a box. Then,
only the small amount of pointer data is copied around on the stack, and the
data stays in one place on the heap. The third case is known as a <em>trait
object</em>, and Chapter 17 devotes an entire section just to that topic. So what
you learn here you’ll apply again in Chapter 17!</p>
<a class="header" href="print.html#using-a-boxt-to-store-data-on-the-heap" id="using-a-boxt-to-store-data-on-the-heap"><h3>Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</h3></a>
<p>Before we discuss this use case for <code>Box&lt;T&gt;</code>, we’ll cover the syntax and how to
interact with values stored within a <code>Box&lt;T&gt;</code>.</p>
<p>Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listing 15-1: Storing an <code>i32</code> value on the heap using a
box</span></p>
<p>We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the
value <code>5</code>, which is allocated on the heap. This program will print <code>b = 5</code>; in
this case, we can access the data in the box in a similar way as we would if
this data was on the stack. Just like any owned value, when a box goes out of
scope like <code>b</code> does at the end of <code>main</code>, it will be deallocated. The
deallocation happens for the box (stored on the stack) and the data it points
to (stored on the heap).</p>
<p>Putting a single value on the heap isn’t very useful, so you won’t use boxes by
themselves in this way very often. Having values like a single <code>i32</code> on the
stack, where they’re stored by default, is more appropriate in the majority of
situations. Let’s look at a case where boxes allow us to define types that we
wouldn’t be allowed to if we didn’t have boxes.</p>
<a class="header" href="print.html#boxes-enable-recursive-types" id="boxes-enable-recursive-types"><h3>Boxes Enable Recursive Types</h3></a>
<p>At compile time, Rust needs to know how much space a type takes up. One type
whose size can’t be known at compile time is a <em>recursive type</em>, where a value
can have as part of itself another value of the same type. Because this nesting
of values could theoretically continue infinitely, Rust doesn’t know how much
space a value of a recursive type needs. However, boxes have a known size, so
by inserting a box in a recursive type definition, we can have recursive types.</p>
<p>Let’s explore the <em>cons list</em>, which is a data type common in functional
programming languages, as an example of a recursive type. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful any time you get into
more complex situations involving recursive types.</p>
<a class="header" href="print.html#more-information-about-the-cons-list" id="more-information-about-the-cons-list"><h4>More Information About the Cons List</h4></a>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language
and its dialects. In Lisp, the <code>cons</code> function (short for “construct function”)
constructs a new pair from its two arguments, which usually are a single value
and another pair. These pairs containing pairs form a list.</p>
<p>The cons function concept has made its way into more general functional
programming jargon: “to cons x onto y” informally means to construct a new
container instance by putting the element x at the start of this new container,
followed by the container y.</p>
<p>Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called <code>Nil</code>
without a next item. A cons list is produced by recursively calling the <code>cons</code>
function. The canonical name to denote the base case of the recursion is <code>Nil</code>.
Note that this is not the same as the “null” or “nil” concept in Chapter 6,
which is an invalid or absent value.</p>
<p>Although functional programming languages use cons lists frequently, it isn’t a
commonly used data structure in Rust. Most of the time when you have a list of
items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use. Other, more complex
recursive data types <em>are</em> useful in various situations, but by starting with
the cons list, we can explore how boxes let us define a recursive data type
without much distraction.</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet because the <code>List</code> type doesn’t have a known size, which
we’ll demonstrate:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listing 15-2: The first attempt at defining an enum to
represent a cons list data structure of <code>i32</code> values</span></p>
<blockquote>
<p>Note: We’re implementing a cons list that only holds <code>i32</code> values for the
purposes of this example. We could have implemented it using generics, as we
discussed in Chapter 10, to define a cons list type that could store values of
any type.</p>
</blockquote>
<p>Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in
Listing 15-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Listing 15-3: Using the <code>List</code> enum to store the list <code>1, 2, 3</code></span></p>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is
another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">Listing 15-4: The error we get when attempting to define
a recursive enum</span></p>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined
<code>List</code> with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
<code>List</code> value. Let’s break down why we get this error a bit: first, let’s look
at how Rust decides how much space it needs to store a value of a non-recursive
type.</p>
<a class="header" href="print.html#computing-the-size-of-a-non-recursive-type" id="computing-the-size-of-a-non-recursive-type"><h4>Computing the Size of a Non-Recursive Type</h4></a>
<p>Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p>To determine how much space to allocate for a <code>Message</code> value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough
space to store two <code>i32</code> values, and so forth. Because only one variant will be
used, the most space a <code>Message</code> value will need is the space it would take to
store the largest of its variants.</p>
<p>Contrast this to what happens when Rust tries to determine how much space a
recursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts
by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value
of type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of
an <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code>
type needs, the compiler looks at the variants, starting with the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, and this process continues infinitely, as shown in Figure 15-1:</p>
<p><img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 15-1: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants</span></p>
<a class="header" href="print.html#using-boxt-to-get-a-recursive-type-with-a-known-size" id="using-boxt-to-get-a-recursive-type-with-a-known-size"><h4>Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</h4></a>
<p>Rust can’t figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-4. But the error does include
this helpful suggestion:</p>
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p>In this suggestion, “indirection” means that instead of storing a value
directly, we’ll change the data structure to store the value indirectly by
storing a pointer to the value instead.</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code>
needs: a pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead
of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code>
value that will be on the heap rather than inside the <code>Cons</code> variant.
Conceptually, we still have a list, created with lists “holding” other lists,
but this implementation is now more like the items being next to one another
rather than inside one another.</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage
of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listing 15-5: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in
order to have a known size</span></p>
<p>The <code>Cons</code> variant will need the size of an <code>i32</code> plus the space to store the
box’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space
than the <code>Cons</code> variant. We now know that any <code>List</code> value will take up the
size of an <code>i32</code> plus the size of a box’s pointer data. By using a box, we’ve
broken the infinite, recursive chain, so the compiler can figure out the size
it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code> variant
looks like now:</p>
<p><img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized
because <code>Cons</code> holds a <code>Box</code></span></p>
<p>Boxes only provide the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have any performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 17, too.</p>
<p>The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait,
which allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code>
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the <code>Drop</code> trait implementation. Let’s explore these two
traits in more detail. These two traits will be even more important to the
functionality provided by the other smart pointer types we’ll discuss in the
rest of this chapter.</p>
<a class="header" href="print.html#treating-smart-pointers-like-regular-references-with-the-deref-trait" id="treating-smart-pointers-like-regular-references-with-the-deref-trait"><h2>Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</h2></a>
<p>Implementing the <code>Deref</code> trait allows us to customize the behavior of the
<em>dereference operator</em>, <code>*</code> (as opposed to the multiplication or glob
operator). By implementing <code>Deref</code> in such a way that a smart pointer can be
treated like a regular reference, we can write code that operates on references
and use that code with smart pointers too.</p>
<p>Let’s first look at how <code>*</code> works with regular references, and then try to
define our own type like <code>Box&lt;T&gt;</code> and see why <code>*</code> doesn’t work like a reference
on our newly defined type. We’ll explore how implementing the <code>Deref</code> trait
makes it possible for smart pointers to work in a similar way as references.
Then we’ll look at Rust’s <em>deref coercion</em> feature and how it lets us work with
either references or smart pointers.</p>
<a class="header" href="print.html#following-the-pointer-to-the-value-with-" id="following-the-pointer-to-the-value-with-"><h3>Following the Pointer to the Value with <code>*</code></h3></a>
<p>A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an <code>i32</code> value and then use the dereference operator to follow the
reference to the data:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an <code>i32</code> value</span></p>
<p>The variable <code>x</code> holds an <code>i32</code> value, <code>5</code>. We set <code>y</code> equal to a reference to
<code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an
assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference
to the value it’s pointing to (hence <em>dereference</em>). Once we dereference <code>y</code>,
we have access to the integer value <code>y</code> is pointing to that we can compare with
<code>5</code>.</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation
error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is
not satisfied
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre>
<p>Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use <code>*</code> to follow the reference to the value it’s
pointing to.</p>
<a class="header" href="print.html#using-boxt-like-a-reference" id="using-boxt-like-a-reference"><h3>Using <code>Box&lt;T&gt;</code> Like a Reference</h3></a>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a
reference, and the dereference operator will work the same way as shown in
Listing 15-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>The only difference between Listing 15-7 and Listing 15-6 is that here we set
<code>y</code> to be an instance of a box pointing to the value in <code>x</code> rather than a
reference pointing to the value of <code>x</code>. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when <code>y</code> was a reference. Next, we’ll explore what is special about <code>Box&lt;T&gt;</code>
that enables us to use the dereference operator by defining our own box type.</p>
<a class="header" href="print.html#defining-our-own-smart-pointer" id="defining-our-own-smart-pointer"><h3>Defining Our Own Smart Pointer</h3></a>
<p>Let’s build a smart pointer similar to the <code>Box&lt;T&gt;</code> type provided by the
standard library to experience how smart pointers behave differently to
references by default. Then we’ll look at how to add the ability to use the
dereference operator.</p>
<p>The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We’ll also define a
<code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-8: Defining a <code>MyBox&lt;T&gt;</code> type</span></p>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code>, because
we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct
with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of
type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and
changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
<code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Listing 15-9: Attempting to use <code>MyBox&lt;T&gt;</code> in the same
way we used references and <code>Box&lt;T&gt;</code></span></p>
<p>Here’s the resulting compilation error:</p>
<pre><code class="language-text">error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<p>Our <code>MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the <code>*</code> operator, we
implement the <code>Deref</code> trait.</p>
<a class="header" href="print.html#treating-a-type-like-a-reference-by-implementing-the-deref-trait" id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"><h3>Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</h3></a>
<p>As discussed in Chapter 10, to implement a trait, we need to provide
implementations for the trait’s required methods. The <code>Deref</code> trait, provided
by the standard library, requires us to implement one method named <code>deref</code> that
borrows <code>self</code> and returns a reference to the inner data. Listing 15-10
contains an implementation of <code>Deref</code> to add to the definition of <code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Deref;

# struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-10: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code></span></p>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code> trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don’t need to worry about them for now; we’ll cover them in
more detail in Chapter 19.</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a
reference to the value we want to access with the <code>*</code> operator. The <code>main</code>
function in Listing 15-9 that calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles
and the assertions pass!</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.
The <code>deref</code> method gives the compiler the ability to take a value of any type
that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that
it knows how to dereference.</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this
code:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a
plain dereference so as programmers we don’t have to think about whether or not
we need to call the <code>deref</code> method. This Rust feature lets us write code that
functions identically whether we have a regular reference or a type that
implements <code>Deref</code>.</p>
<p>The reason the <code>deref</code> method returns a reference to a value and that the plain
dereference outside the parentheses in <code>*(y.deref())</code> is still necessary is due
to the ownership system. If the <code>deref</code> method returned the value directly
instead of a reference to the value, the value would be moved out of <code>self</code>. We
don’t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in this case
and in most cases where we use the dereference operator.</p>
<p>Note that the <code>*</code> is replaced with a call to the <code>deref</code> method and then a call
to <code>*</code> just once, each time we type a <code>*</code> in our code. Because the substitution
of <code>*</code> does not recurse infinitely, we end up with data of type <code>i32</code>, which
matches the <code>5</code> in <code>assert_eq!</code> in Listing 15-9.</p>
<a class="header" href="print.html#implicit-deref-coercions-with-functions-and-methods" id="implicit-deref-coercions-with-functions-and-methods"><h3>Implicit Deref Coercions with Functions and Methods</h3></a>
<p><em>Deref coercion</em> is a convenience that Rust performs on arguments to functions
and methods. Deref coercion converts a reference to a type that implements
<code>Deref</code> into a reference to a type that <code>Deref</code> can convert the original type
into. Deref coercion happens automatically when we pass a reference to a
particular type’s value as an argument to a function or method that doesn’t
match the parameter type in the function or method definition. A sequence of
calls to the <code>deref</code> method converts the type we provided into the type the
parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.</p>
<p>To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in
Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-11: A <code>hello</code> function that has the parameter
<code>name</code> of type <code>&amp;str</code></span></p>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as
<code>hello(&quot;Rust&quot;);</code> for example. Deref coercion makes it possible to call <code>hello</code>
with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Listing 15-12: Calling <code>hello</code> with a reference to a
<code>MyBox&lt;String&gt;</code> value, which works because of deref coercion</span></p>
<p>Here we’re calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a
reference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait
on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code>
by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code>
on <code>String</code> that returns a string slice, which is in the API documentation for
<code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which
matches the <code>hello</code> function’s definition.</p>
<p>If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value
of type <code>&amp;MyBox&lt;String&gt;</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Listing 15-13: The code we would have to write if Rust
didn’t have deref coercion</span></p>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and
<code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to
match the signature of <code>hello</code>. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the
types and use <code>Deref::deref</code> as many times as necessary to get a reference to
match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!</p>
<a class="header" href="print.html#how-deref-coercion-interacts-with-mutability" id="how-deref-coercion-interacts-with-mutability"><h3>How Deref Coercion Interacts with Mutability</h3></a>
<p>Similar to how we use the <code>Deref</code> trait to override <code>*</code> on immutable
references, Rust provides a <code>DerefMut</code> trait for overriding <code>*</code> on mutable
references.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three
cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>The first two cases are the same except for mutability. The first case states
that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can
get a <code>&amp;U</code> transparently. The second case states that the same deref coercion
happens for mutable references.</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is <em>not</em> possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that
there is only one immutable reference to that data, and the borrowing rules
don’t guarantee that. Therefore, Rust can’t make the assumption that converting
an immutable reference to a mutable reference is possible.</p>
<a class="header" href="print.html#the-drop-trait-runs-code-on-cleanup" id="the-drop-trait-runs-code-on-cleanup"><h2>The <code>Drop</code> Trait Runs Code on Cleanup</h2></a>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets
us customize what happens when a value is about to go out of scope. We can
provide an implementation for the <code>Drop</code> trait on any type, and the code we
specify can be used to release resources like files or network connections.
We’re introducing <code>Drop</code> in the context of smart pointers because the
functionality of the <code>Drop</code> trait is almost always used when implementing a
smart pointer. For example, <code>Box&lt;T&gt;</code> customizes <code>Drop</code> to deallocate the space
on the heap that the box points to.</p>
<p>In some languages, the programmer must call code to free memory or resources
every time they finish using an instance of a smart pointer. If they forget,
the system might become overloaded and crash. In Rust, we can specify that a
particular bit of code should be run whenever a value goes out of scope, and
the compiler will insert this code automatically. As a result, we don’t need to
be careful about placing cleanup code everywhere in a program that an instance
of a particular type is finished with, but we still won’t leak resources!</p>
<p>We specify the code to run when a value goes out of scope by implementing the
<code>Drop</code> trait. The <code>Drop</code> trait requires us to implement one method named <code>drop</code>
that takes a mutable reference to <code>self</code>. To see when Rust calls <code>drop</code>, let’s
implement <code>drop</code> with <code>println!</code> statements for now.</p>
<p>Listing 15-14 shows a <code>CustomSmartPointer</code> struct whose only custom
functionality is that it will print <code>Dropping CustomSmartPointer!</code> when the
instance goes out of scope. This example demonstrates when Rust runs the <code>drop</code>
function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;my stuff&quot;) };
    let d = CustomSmartPointer { data: String::from(&quot;other stuff&quot;) };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 15-14: A <code>CustomSmartPointer</code> struct that
implements the <code>Drop</code> trait where we would put our cleanup code</span></p>
<p>The <code>Drop</code> trait is included in the prelude, so we don’t need to import it. We
implement the <code>Drop</code> trait on <code>CustomSmartPointer</code> and provide an
implementation for the <code>drop</code> method that calls <code>println!</code>. The body of the
<code>drop</code> function is where you would place any logic that you wanted to run when
an instance of your type goes out of scope. We’re printing some text here to
demonstrate when Rust will call <code>drop</code>.</p>
<p>In <code>main</code>, we create two instances of <code>CustomSmartPointer</code> and then print
<code>CustomSmartPointers created.</code>. At the end of <code>main</code>, our instances of
<code>CustomSmartPointer</code> will go out of scope, and Rust will call the code we put
in the <code>drop</code> method, printing our final message. Note that we didn’t need to
call the <code>drop</code> method explicitly.</p>
<p>When we run this program, we’ll see the following output:</p>
<pre><code class="language-text">CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automatically called <code>drop</code> for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
the order in which they were created, so <code>d</code> was dropped before <code>c</code>. This
example just gives you a visual guide to how the <code>drop</code> method works, but
usually you would specify the cleanup code that your type needs to run rather
than a print message.</p>
<a class="header" href="print.html#dropping-a-value-early-with-stdmemdrop" id="dropping-a-value-early-with-stdmemdrop"><h3>Dropping a Value Early with <code>std::mem::drop</code></h3></a>
<p>Unfortunately, it’s not straightforward to disable the automatic <code>drop</code>
functionality. Disabling <code>drop</code> isn’t usually necessary; the whole point of the
<code>Drop</code> trait is that it’s taken care of automatically. Occasionally, you might
want to clean up a value early. One example is when using smart pointers that
manage locks: you might want to force the <code>drop</code> method that releases the lock
to run so other code in the same scope can acquire the lock. Rust doesn’t let
us call the <code>Drop</code> trait’s <code>drop</code> method manually; instead we have to call the
<code>std::mem::drop</code> function provided by the standard library if we want to force
a value to be dropped before the end of its scope.</p>
<p>Let’s see what happens when we try to call the <code>Drop</code> trait’s <code>drop</code> method
manually by modifying the <code>main</code> function in Listing 15-14, as shown in Listing
15-15:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">Listing 15-15: Attempting to call the <code>drop</code> method from
the <code>Drop</code> trait manually to clean up early</span></p>
<p>When we try to compile this code, we’ll get this error:</p>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
</code></pre>
<p>This error message states that we’re not allowed to explicitly call <code>drop</code>. The
error message uses the term <em>destructor</em>, which is the general programming term
for a function that cleans up an instance. A <em>destructor</em> is analogous to a
<em>constructor</em> that creates an instance. The <code>drop</code> function in Rust is one
particular destructor.</p>
<p>Rust doesn’t let us call <code>drop</code> explicitly because Rust would still
automatically call <code>drop</code> on the value at the end of <code>main</code>. This would be a
<em>double free</em> error because Rust would be trying to clean up the same value
twice.</p>
<p>We can’t disable the automatic insertion of <code>drop</code> when a value goes out of
scope, and we can’t call the <code>drop</code> method explicitly. So, if we need to force
a value to be cleaned up early, we can use the <code>std::mem::drop</code> function.</p>
<p>The <code>std::mem::drop</code> function is different than the <code>drop</code> method in the <code>Drop</code>
trait. We call it by passing the value we want to force to be dropped early as
an argument. The function is in the prelude, so we can modify <code>main</code> in Listing
15-15 to call the <code>drop</code> function, as shown in Listing 15-16:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct CustomSmartPointer {
#     data: String,
# }
#
# impl Drop for CustomSmartPointer {
#     fn drop(&amp;mut self) {
#         println!(&quot;Dropping CustomSmartPointer!&quot;);
#     }
# }
#
fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 15-16: Calling <code>std::mem::drop</code> to explicitly
drop a value before it goes out of scope</span></p>
<p>Running this code will print the following:</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>The text <code>Dropping CustomSmartPointer with data `some data`!</code> is printed
between the <code>CustomSmartPointer created.</code> and <code>CustomSmartPointer dropped before the end of main.</code> text, showing that the <code>drop</code> method code is called to
drop <code>c</code> at that point.</p>
<p>We can use code specified in a <code>Drop</code> trait implementation in many ways to make
cleanup convenient and safe: for instance, we could use it to create our own
memory allocator! With the <code>Drop</code> trait and Rust’s ownership system, we don’t
have to remember to clean up because Rust does it automatically.</p>
<p>We also don’t have to worry about accidentally cleaning up values still in use
because that would cause a compiler error: the ownership system that makes sure
references are always valid also ensures that <code>drop</code> gets called only once when
the value is no longer being used.</p>
<p>Now that we’ve examined <code>Box&lt;T&gt;</code> and some of the characteristics of smart
pointers, let’s look at a few other smart pointers defined in the standard
library.</p>
<a class="header" href="print.html#rct-the-reference-counted-smart-pointer" id="rct-the-reference-counted-smart-pointer"><h2><code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</h2></a>
<p>In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it.</p>
<p>To enable multiple ownership, Rust has a type called <code>Rc&lt;T&gt;</code>. Its name is an
abbreviation for <em>reference counting</em>, which keeps track of the number of
references to a value to know whether or not a value is still in use. If there
are zero references to a value, the value can be cleaned up without any
references becoming invalid.</p>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for
multiple parts of our program to read, and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner and the normal ownership
rules enforced at compile time would take effect.</p>
<p>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.</p>
<a class="header" href="print.html#using-rct-to-share-data" id="using-rct-to-share-data"><h3>Using <code>Rc&lt;T&gt;</code> to Share Data</h3></a>
<p>Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using <code>Box&lt;T&gt;</code>. This time, we’ll create two lists that both share ownership
of a third list, which conceptually will look similar to Figure 15-3:</p>
<p><img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Figure 15-3: Two lists, <code>b</code> and <code>c</code>, sharing ownership of
a third list, <code>a</code></span></p>
<p>We’ll create list <code>a</code> that contains 5 and then 10. Then we’ll make two more
lists: <code>b</code> that starts with 3 and <code>c</code> that starts with 4. Both <code>b</code> and <code>c</code>
lists will then continue on to the first <code>a</code> list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.</p>
<p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code>
won’t work, as shown in Listing 15-17:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Listing 15-17: Demonstrating we’re not allowed to have
two lists using <code>Box&lt;T&gt;</code> that try to share ownership of a third list</span></p>
<p>When we compile this code, we get this error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code>
is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when
creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldn’t let us compile
<code>let a = Cons(10, &amp;Nil);</code> for example, because the temporary <code>Nil</code> value would
be dropped before <code>a</code> could take a reference to it.</p>
<p>Instead, we’ll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of
<code>Box&lt;T&gt;</code>, as shown in Listing 15-18. Each <code>Cons</code> variant will now hold a value
and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code>. When we create <code>b</code>, instead of taking
ownership of <code>a</code>, we’ll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, which
increases the number of references from one to two and lets <code>a</code> and <code>b</code> share
ownership of the data in that <code>Rc&lt;List&gt;</code>. We’ll also clone <code>a</code> when creating
<code>c</code>, which increases the number of references from two to three. Every time we
call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List&gt;</code> will
increase, and the data won’t be cleaned up unless there are zero references to
it:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listing 15-18: A definition of <code>List</code> that uses
<code>Rc&lt;T&gt;</code></span></p>
<p>We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it’s not
in the prelude. In <code>main</code>, we create the list holding 5 and 10 and store it in
a new <code>Rc&lt;List&gt;</code> in <code>a</code>. Then when we create <code>b</code> and <code>c</code>, we call the
<code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an
argument.</p>
<p>We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s
convention is to use <code>Rc::clone</code> in this case. The implementation of
<code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’
implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using <code>Rc::clone</code> for reference counting, we can visually
distinguish between the deep copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep copy clones and can disregard calls to
<code>Rc::clone</code>.</p>
<a class="header" href="print.html#cloning-an-rct-increases-the-reference-count" id="cloning-an-rct-increases-the-reference-count"><h3>Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</h3></a>
<p>Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the <code>Rc&lt;List&gt;</code> in <code>a</code>.</p>
<p>In Listing 15-19, we’ll change <code>main</code> so it has an inner scope around list <code>c</code>;
then we can see how the reference count changes when <code>c</code> goes out of scope. At
each point in the program where the reference count changes, we’ll print the
reference count, which we can get by calling the <code>Rc::strong_count</code> function.
This function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code>
type also has a <code>weak_count</code>; we’ll see what <code>weak_count</code> is used for in the
“Preventing Reference Cycles” section.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listing 15-19: Printing the reference count</span></p>
<p>This code prints the following:</p>
<pre><code class="language-text">count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>We can see that the <code>Rc&lt;List&gt;</code> in <code>a</code> has an initial reference count of one;
then each time we call <code>clone</code>, the count goes up by one. When <code>c</code> goes out of
scope, the count goes down by one. We don’t have to call a function to decrease
the reference count like we have to call <code>Rc::clone</code> to increase the reference
count: the implementation of the <code>Drop</code> trait decreases the reference count
automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</p>
<p>What we can’t see in this example is that when <code>b</code> and then <code>a</code> go out of scope
at the end of <code>main</code>, the count is then 0, and the <code>Rc&lt;List&gt;</code> is cleaned up
completely at that point. Using <code>Rc&lt;T&gt;</code> allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.</p>
<p>Via immutable references, <code>Rc&lt;T&gt;</code> allows us to share data between multiple
parts of our program for reading only. If <code>Rc&lt;T&gt;</code> allowed us to have multiple
mutable references too, we might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code>
type that we can use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this
immutability restriction.</p>
<a class="header" href="print.html#refcellt-and-the-interior-mutability-pattern" id="refcellt-and-the-interior-mutability-pattern"><h2><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</h2></a>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data: normally, this
action is disallowed by the borrowing rules. To do so, the pattern uses
<code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern
mutation and borrowing. We haven’t yet covered unsafe code; we will in
Chapter 19. We can use types that use the interior mutability pattern when we
can ensure that the borrowing rules will be followed at runtime, even though
the compiler can’t guarantee that. The <code>unsafe</code> code involved is then wrapped
in a safe API, and the outer type is still immutable.</p>
<p>Let’s explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the
interior mutability pattern.</p>
<a class="header" href="print.html#enforcing-borrowing-rules-at-runtime-with-refcellt" id="enforcing-borrowing-rules-at-runtime-with-refcellt"><h3>Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></h3></a>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data
it holds. So, what makes <code>RefCell&lt;T&gt;</code> different than a type like <code>Box&lt;T&gt;</code>?
Recall the borrowing rules you learned in Chapter 4:</p>
<ol>
<li>At any given time, you can have <em>either</em> but not both of:</li>
</ol>
<ul>
<li>One mutable reference.</li>
<li>Any number of immutable references.</li>
</ul>
<ol start="2">
<li>References must always be valid.</li>
</ol>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced at
compile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>.
With references, if you break these rules, you’ll get a compiler error. With
<code>RefCell&lt;T&gt;</code>, if you break these rules, your program will <code>panic!</code> and exit.</p>
<p>The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust’s default.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that
certain memory safe scenarios are then allowed, whereas they are disallowed by
the compile time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.</p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it’s conservative. If Rust accepted an incorrect program, users
wouldn’t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you’re sure your
code follows the borrowing rules, but the compiler is unable to understand and
guarantee that.</p>
<p>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios
and will give you a compile time error if you try using it in a multithreaded
context. We’ll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a
multithreaded program in Chapter 16.</p>
<p>Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>
have single owners.</li>
<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code>
only allows immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows
immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, we can mutate
the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is immutable.</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em>
pattern. Let’s look at a situation in which interior mutability is useful and
examine how it’s possible.</p>
<a class="header" href="print.html#interior-mutability-a-mutable-borrow-to-an-immutable-value" id="interior-mutability-a-mutable-borrow-to-an-immutable-value"><h3>Interior Mutability: A Mutable Borrow to an Immutable Value</h3></a>
<p>A consequence of the borrowing rules is that when we have an immutable value,
we can’t borrow it mutably. For example, this code won’t compile:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>When we try to compile this code, we’ll get the following error:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<p>However, there are situations in which it would be useful for a value to mutate
itself in its methods, but to other code, the value would appear immutable.
Code outside the value’s methods would not be able to mutate the value. Using
<code>RefCell&lt;T&gt;</code> is one way to get the ability to have interior mutability. But
<code>RefCell&lt;T&gt;</code> doesn’t get around the borrowing rules completely: the borrow
checker in the compiler allows this interior mutability, and the borrowing
rules are checked at runtime instead. If we violate the rules, we’ll get a
<code>panic!</code> instead of a compiler error.</p>
<p>Let’s work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate
an immutable value and see why that is useful.</p>
<a class="header" href="print.html#a-use-case-for-interior-mutability-mock-objects" id="a-use-case-for-interior-mutability-mock-objects"><h4>A Use Case for Interior Mutability: Mock Objects</h4></a>
<p>A <em>test double</em> is the general programming concept for a type used in place of
another type during testing. <em>Mock objects</em> are specific types of test doubles
that record what happens during a test so we can assert that the correct
actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects,
and Rust doesn’t have mock object functionality built into the standard library
like some other languages do. However, we can definitely create a struct that
will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used for keeping track of a
user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesn’t need to know
that detail. All it needs is something that implements a trait we’ll provide
called <code>Messenger</code>. Listing 15-20 shows the library code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-20: A library to keep track of how close to a
maximum value a value is and warn when the value is at certain levels</span></p>
<p>One important part of this code is that the <code>Messenger</code> trait has one method
called <code>send</code> that takes an immutable reference to <code>self</code> and text of the
message. This is the interface our mock object needs to have. The other
important part is that we want to test the behavior of the <code>set_value</code> method
on the <code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter,
but <code>set_value</code> doesn’t return anything for us to make assertions on. We want
to be able to say that if we create a <code>LimitTracker</code> with something that
implements the <code>Messenger</code> trait and a particular value for <code>max</code>, when we pass
different numbers for <code>value</code>, the messenger is told to send the appropriate
messages.</p>
<p>We need a mock object that instead of sending an email or text message when we
call <code>send</code> will only keep track of the messages it’s told to send. We can
create a new instance of the mock object, create a <code>LimitTracker</code> that uses the
mock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt of
implementing a mock object to do just that but that the borrow checker won’t
allow:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-21: An attempt to implement a <code>MockMessenger</code>
that isn’t allowed by the borrow checker</span></p>
<p>This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code>
field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it’s told
to send. We also define an associated function <code>new</code> to make it convenient to
create new <code>MockMessenger</code> values that start with an empty list of messages. We
then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a
<code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we
take the message passed in as a parameter and store it in the <code>MockMessenger</code>
list of <code>sent_messages</code>.</p>
<p>In the test, we’re testing what happens when the <code>LimitTracker</code> is told to set
<code>value</code> to something that is more than 75 percent of the <code>max</code> value. First, we
create a new <code>MockMessenger</code>, which will start with an empty list of messages.
Then we create a new <code>LimitTracker</code> and give it a reference to the new
<code>MockMessenger</code> and a <code>max</code> value of 100. We call the <code>set_value</code> method on the
<code>LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the <code>MockMessenger</code> is keeping track
of should now have one message in it.</p>
<p>However, there’s one problem with this test, as shown here:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages because the
<code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the
suggestion from the error text to use <code>&amp;mut self</code> instead because then the
signature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait
definition (feel free to try and see what error message you get).</p>
<p>This is a situation in which interior mutability can help! We’ll store the
<code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> message will be
able to modify <code>sent_messages</code> to store the messages we’ve seen. Listing 15-22
shows what that looks like:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
#         limit_tracker.set_value(75);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 15-22: Using <code>RefCell&lt;T&gt;</code> to mutate an inner
value while the outer value is considered immutable</span></p>
<p>The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of
<code>Vec&lt;String&gt;</code>. In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
instance around the empty vector.</p>
<p>For the implementation of the <code>send</code> method, the first parameter is still an
immutable borrow of <code>self</code>, which matches the trait definition. We call
<code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a
mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is
the vector. Then we can call <code>push</code> on the mutable reference to the vector to
keep track of the messages sent during the test.</p>
<p>The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an
immutable reference to the vector.</p>
<p>Now that you’ve seen how to use <code>RefCell&lt;T&gt;</code>, let’s dig into how it works!</p>
<a class="header" href="print.html#refcellt-keeps-track-of-borrows-at-runtime" id="refcellt-keeps-track-of-borrows-at-runtime"><h4><code>RefCell&lt;T&gt;</code> Keeps Track of Borrows at Runtime</h4></a>
<p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code>
syntax, respectively. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code>
methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The
<code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code>
returns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code> so
we can treat them like regular references.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart
pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code>
increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code>
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable
borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error like we
would with references, the implementation of <code>RefCell&lt;T&gt;</code> will <code>panic!</code> at
runtime. Listing 15-23 shows a modification of the implementation of <code>send</code> in
Listing 15-22. We’re deliberately trying to create two mutable borrows active
for the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this
at runtime:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre>
<p><span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that <code>RefCell&lt;T&gt;</code> will panic</span></p>
<p>We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned
from <code>borrow_mut</code>. Then we create another mutable borrow in the same way in the
variable <code>two_borrow</code>. This makes two mutable references in the same scope,
which isn’t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
    thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
    'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Notice that the code panicked with the message <code>already borrowed: BorrowMutError</code>. This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing
rules at runtime.</p>
<p>Catching borrowing errors at runtime rather than compile time means that we
would find a mistake in our code later in the development process and possibly
not even until our code was deployed to production. Also, our code will incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using <code>RefCell&lt;T&gt;</code> makes it
possible for us to write a mock object that can modify itself to keep track of
the messages it has seen while we’re using it in a context where only immutable
values are allowed. We can use <code>RefCell&lt;T&gt;</code> despite its trade-offs to get more
functionality than regular references give us.</p>
<a class="header" href="print.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt" id="having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><h3>Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></h3></a>
<p>A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code>. Recall that
<code>Rc&lt;T&gt;</code> lets us have multiple owners of some data, but it only gives us
immutable access to that data. If we have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code>,
we can get a value that can have multiple owners <em>and</em> that we can mutate!</p>
<p>For example, recall the cons list example in Listing 15-18 where we used
<code>Rc&lt;T&gt;</code> to let us have multiple lists share ownership of another list. Because
<code>Rc&lt;T&gt;</code> only holds immutable values, we can’t change any of the values in the
list once we’ve created them. Let’s add in <code>RefCell&lt;T&gt;</code> to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
<code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all
the lists:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listing 15-24: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a
<code>List</code> that we can mutate</span></p>
<p>We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;</code> and store it in a
variable named <code>value</code> so we can access it directly later. Then we create a
<code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone
<code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather
than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from
<code>value</code>.</p>
<p>We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so when we create lists <code>b</code> and <code>c</code>, they
can both refer to <code>a</code>, which is what we did in Listing 15-18.</p>
<p>After we’ve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we add 10 to the value in
<code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
“Where’s the <code>-&gt;</code> Operator?”) to dereference the <code>Rc&lt;T&gt;</code> to the inner
<code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code> method returns a <code>RefMut&lt;T&gt;</code> smart
pointer, and we use the dereference operator on it and change the inner value.</p>
<p>When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified
value of 15 rather than 5:</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly
immutable <code>List</code>. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it’s
sometimes worth trading a bit of speed for this flexibility in our data
structures.</p>
<p>The standard library has other types that provide interior mutability, such as
<code>Cell&lt;T&gt;</code>, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the <code>Cell&lt;T&gt;</code>. There’s also
<code>Mutex&lt;T&gt;</code>, which offers interior mutability that’s safe to use across threads;
we’ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.</p>
<a class="header" href="print.html#reference-cycles-can-leak-memory" id="reference-cycles-can-leak-memory"><h2>Reference Cycles Can Leak Memory</h2></a>
<p>Rust’s memory safety guarantees make it <em>difficult</em> but not impossible to
accidentally create memory that is never cleaned up (known as a <em>memory leak</em>).
Preventing memory leaks entirely is not one of Rust’s guarantees in the same
way that disallowing data races at compile time is, meaning memory leaks are
memory safe in Rust. We can see that Rust allows memory leaks by using <code>Rc&lt;T&gt;</code>
and <code>RefCell&lt;T&gt;</code>: it’s possible to create references where items refer to each
other in a cycle. This creates memory leaks because the reference count of each
item in the cycle will never reach 0, and the values will never be dropped.</p>
<a class="header" href="print.html#creating-a-reference-cycle" id="creating-a-reference-cycle"><h3>Creating a Reference Cycle</h3></a>
<p>Let’s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing
15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main -->
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 15-25: A cons list definition that holds a
<code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to</span></p>
<p>We’re using another variation of the <code>List</code> definition in Listing 15-5. The
second element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that
instead of having the ability to modify the <code>i32</code> value like we did in Listing
15-24, we want to modify which <code>List</code> a <code>Cons</code> variant is pointing to. We’re
also adding a <code>tail</code> method to make it convenient for us to access the second
item if we have a <code>Cons</code> variant.</p>
<p>In Listing 15-26, we’re adding a <code>main</code> function that uses the definitions in
Listing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to
the list in <code>a</code>, and then modifies the list in <code>a</code> to point to <code>b</code>, which
creates a reference cycle. There are <code>println!</code> statements along the way to
show what the reference counts are at various points in this process:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use List::{Cons, Nil};
# use std::rc::Rc;
# use std::cell::RefCell;
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match *self {
#             Cons(_, ref item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle; it will
    // overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listing 15-26: Creating a reference cycle of two <code>List</code>
values pointing to each other</span></p>
<p>We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code>
with an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance
holding another <code>List</code> value in the variable <code>b</code> that contains the value 10 and
then points to the list in <code>a</code>.</p>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, which creates a cycle. We
do that by using the <code>tail</code> method to get a reference to the
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code>, which we put in the variable <code>link</code>. Then we use
the <code>borrow_mut</code> method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside
from an <code>Rc&lt;List&gt;</code> that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>
<p>When we run this code, keeping the last <code>println!</code> commented out for the
moment, we’ll get this output:</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> are 2
after we change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust
will try to drop <code>b</code> first, which will decrease the count in each of the
<code>Rc&lt;List&gt;</code> instances in <code>a</code> and <code>b</code> by one.</p>
<p>However, because <code>a</code> is still referencing the <code>Rc&lt;List&gt;</code> that was in <code>b</code>,
that <code>Rc&lt;List&gt;</code> has a count of 1 rather than 0, so the memory the
<code>Rc&lt;List&gt;</code> has on the heap won’t be dropped. The memory will just sit there
with a count of one, forever. To visualize this reference cycle, we’ve created
a diagram in Figure 15-4:</p>
<p><img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" /></p>
<p><span class="caption">Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other</span></p>
<p>If you uncomment the last <code>println!</code> and run the program, Rust will try to
print this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it
overflows the stack.</p>
<p>In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle aren’t very dire. If a more complex program
allocates lots of memory in a cycle and holds onto it for a long time, the
program would use more memory than it needs and might overwhelm the system,
causing it to run out of available memory.</p>
<p>Creating reference cycles is not easily done, but it’s not impossible either.
If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don’t create cycles; you can’t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.</p>
<p>Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don’t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want <code>Cons</code>
variants to own their list, so reorganizing the data structure isn’t possible.
Let’s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.</p>
<a class="header" href="print.html#preventing-reference-cycles-turn-an-rct-into-a-weakt" id="preventing-reference-cycles-turn-an-rct-into-a-weakt"><h3>Preventing Reference Cycles: Turn an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></h3></a>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the
<code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only
cleaned up if its <code>strong_count</code> is 0. We can also create a <em>weak reference</em> to
the value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a
reference to the <code>Rc&lt;T&gt;</code>. When we call <code>Rc::downgrade</code>, we get a smart
pointer of type <code>Weak&lt;T&gt;</code>. Instead of increasing the <code>strong_count</code> in the
<code>Rc&lt;T&gt;</code> instance by one, calling <code>Rc::downgrade</code> increases the <code>weak_count</code>
by one. The <code>Rc&lt;T&gt;</code> type uses <code>weak_count</code> to keep track of how many
<code>Weak&lt;T&gt;</code> references exist, similar to <code>strong_count</code>. The difference is the
<code>weak_count</code> doesn’t need to be 0 for the <code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>
<p>Strong references are how we can share ownership of an <code>Rc&lt;T&gt;</code> instance. Weak
references don’t express an ownership relationship. They won’t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do
anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, we must make sure the
value still exists. We do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code>
instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. We’ll get a result of <code>Some</code> if
the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the
<code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;T&gt;</code>, Rust
will ensure that we handle the <code>Some</code> case and the <code>None</code> case, and there won’t
be an invalid pointer.</p>
<p>As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their children items <em>and</em>
their parent items.</p>
<a class="header" href="print.html#creating-a-tree-data-structure-a-node-with-child-nodes" id="creating-a-tree-data-structure-a-node-with-child-nodes"><h4>Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</h4></a>
<p>To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as
references to its children <code>Node</code> values:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with
variables so we can access each <code>Node</code> in the tree directly. To do this, we
define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to
modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in
<code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Next, we’ll use our struct definition and create one <code>Node</code> instance named
<code>leaf</code> with the value 3 and no children, and another instance named <code>branch</code>
with the value 5 and <code>leaf</code> as one of its children, as shown in Listing 15-27:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::Rc;
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">Listing 15-27: Creating a <code>leaf</code> node with no children
and a <code>branch</code> node with <code>leaf</code> as one of its children</span></p>
<p>We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the
<code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from
<code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there’s no way to get from
<code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and
doesn’t know they’re related. We want <code>leaf</code> to know that <code>branch</code> is its
parent. We’ll do that next.</p>
<a class="header" href="print.html#adding-a-reference-from-a-child-to-its-parent" id="adding-a-reference-from-a-child-to-its-parent"><h4>Adding a Reference from a Child to Its Parent</h4></a>
<p>To make the child node aware of its parent, we need to add a <code>parent</code> field to
our <code>Node</code> struct definition. The trouble is in deciding what the type of
<code>parent</code> should be. We know it can’t contain an <code>Rc&lt;T&gt;</code> because that would
create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and
<code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code>
values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!</p>
<p>So instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks
like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>Now a node will be able to refer to its parent node but doesn’t own its parent.
In Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code>
node will have a way to refer to its parent, <code>branch</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Listing 15-28: A <code>leaf</code> node with a <code>Weak</code> reference to
its parent node <code>branch</code></span></p>
<p>Creating the <code>leaf</code> node looks similar to how creating the <code>leaf</code> node looked
in Listing 15-27 with the exception of the <code>parent</code> field: <code>leaf</code> starts out
without a parent, so we create a new, empty <code>Weak&lt;Node&gt;</code> reference instance.</p>
<p>At this point, when we try to get a reference to the parent of <code>leaf</code> by using
the <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the
first <code>println!</code> statement:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code>
reference in the <code>parent</code> field, because <code>branch</code> doesn’t have a parent node.
We still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the
<code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code>
reference to its parent. We use the <code>borrow_mut</code> method on the
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the
<code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from
the <code>Rc&lt;Node&gt;</code> in <code>branch.</code></p>
<p>When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant
holding <code>branch</code>: now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26: the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<a class="header" href="print.html#visualizing-changes-to-strong_count-and-weak_count" id="visualizing-changes-to-strong_count-and-weak_count"><h4>Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></h4></a>
<p>Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code>
instances change by creating a new inner scope and moving the creation of
<code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">Listing 15-29: Creating <code>branch</code> in an inner scope and
examining strong and weak reference counts</span></p>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak
count of 0. In the inner scope, we create <code>branch</code> and associate it with
<code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code>
will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing
to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see
it will have a strong count of 2, because <code>branch</code> now has a clone of the
<code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code>, but will still have a weak
count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope and the strong count of
the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1
from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we
don’t get any memory leaks!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get
<code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong
count of 1 and a weak count of 0, because the variable <code>leaf</code> is now the only
reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>All of the logic that manages the counts and value dropping is built into
<code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By
specifying that the relationship from a child to its parent should be a
<code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, we’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<a class="header" href="print.html#summary-10" id="summary-10"><h2>Summary</h2></a>
<p>This chapter covered how to use smart pointers to make different guarantees and
trade-offs than those Rust makes by default with regular references. The
<code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The
<code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap, so
that data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.</p>
<p>Also discussed were the <code>Deref</code> and <code>Drop</code> traits that enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>
<p>If this chapter has piqued your interest and you want to implement your own
smart pointers, check out “The Rustonomicon” at
<em>https://doc.rust-lang.org/stable/nomicon/</em> for more useful information.</p>
<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.</p>
<a class="header" href="print.html#fearless-concurrency" id="fearless-concurrency"><h1>Fearless Concurrency</h1></a>
<p>Handling concurrent programming safely and efficiently is another of Rust’s
major goals. <em>Concurrent programming</em>, where different parts of a program
execute independently, and <em>parallel programming</em>, where different parts of a
program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone: Rust hopes to
change that.</p>
<p>Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety <em>and</em> concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are <em>compile time</em> errors in Rust rather than runtime errors. Therefore, rather
than you spending lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while you’re working on it rather than potentially after it has been
shipped to production. We’ve nicknamed this aspect of Rust <em>fearless</em>
<em>concurrency</em>. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.</p>
<blockquote>
<p>Note: For simplicity’s sake, we’ll refer to many of the problems as
concurrent rather than being more precise by saying concurrent and/or
parallel. If this book was specifically about concurrency and/or parallelism,
we’d be more. specific. For this chapter, please mentally substitute
concurrent and/or parallel whenever we use concurrent.</p>
</blockquote>
<p>Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for message
passing concurrency but has only obscure ways to share state between threads.
Supporting only a subset of possible solutions is a reasonable strategy for
higher-level languages, because a higher-level language promises benefits from
giving up some control to gain abstractions. However, lower-level languages are
expected to provide the solution with the best performance in any given
situation and have fewer abstractions over the hardware. Therefore, Rust offers
a variety of tools for modeling problems in whatever way is appropriate for
your situation and requirements.</p>
<p>Here are the topics we’ll cover in this chapter:</p>
<ul>
<li>How to create threads to run multiple pieces of code at the same time</li>
<li><em>Message passing</em> concurrency, where channels send messages between threads</li>
<li><em>Shared state</em> concurrency, where multiple threads have access to some piece
of data</li>
<li>The <code>Sync</code> and <code>Send</code> traits, which extend Rust’s concurrency guarantees to
user-defined types as well as types provided by the standard library</li>
</ul>
<a class="header" href="print.html#using-threads-to-run-code-simultaneously" id="using-threads-to-run-code-simultaneously"><h2>Using Threads to Run Code Simultaneously</h2></a>
<p>In most current operating systems, an executed program’s code is run in a
<em>process</em>, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
feature that runs these independent parts is called <em>threads</em>.</p>
<p>Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, there’s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:</p>
<ul>
<li>Race conditions, where threads are accessing data or resources in an
inconsistent order</li>
<li>Deadlocks, where two threads are waiting for each other to finish using a
resource the other thread has, preventing both threads from continuing</li>
<li>Bugs that only happen in certain situations and are hard to reproduce and fix
reliably</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads. Programming in
a multithreaded context still takes careful thought and requires a code
structure that is different from programs that run in a single thread.</p>
<p>Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called <em>1:1</em>,
one operating system thread per one language thread.</p>
<p>Many programming languages provide their own special implementation of threads.
Programming language-provided threads are known as <em>green</em> threads, and
languages that use these green threads will execute them in the context of a
different number of operating system threads. For this reason, the green
threaded model is called the <em>M:N</em> model: <code>M</code> green threads per <code>N</code> operating
system threads, where <code>M</code> and <code>N</code> are not necessarily the same number.</p>
<p>Each model has its own advantages and trade-offs, and the trade-off most
important to Rust is runtime support. Runtime is a confusing term and can have
different meanings in different contexts.</p>
<p>In this context, by <em>runtime</em> we mean code that is included by the language in
every binary. This code can be large or small depending on the language, but
every non-assembly language will have some amount of runtime code. For that
reason, colloquially when people say a language has “no runtime,” they often
mean “small runtime.” Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries, which make it easier to combine the
language with other languages in more contexts. Although many languages are
okay with increasing the runtime size in exchange for more features, Rust needs
to have nearly no runtime and cannot compromise on being able to call into C to
maintain performance.</p>
<p>The green threading M:N model requires a larger language runtime to manage
threads. As such, the Rust standard library only provides an implementation of
1:1 threading. Because Rust is such a low-level language, there are crates that
implement M:N threading if you would rather trade overhead for aspects such as
more control over which threads run when and lower costs of context switching,
for example.</p>
<p>Now that we’ve defined threads in Rust, let’s explore how to use the
thread-related API provided by the standard library.</p>
<a class="header" href="print.html#creating-a-new-thread-with-spawn" id="creating-a-new-thread-with-spawn"><h3>Creating a New Thread with <code>spawn</code></h3></a>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span></p>
<p>Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short
duration, which allows a different thread to run. The threads will probably
take turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until <code>i</code> is 9, it only got to 5
before the main thread shut down.</p>
<p>If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.</p>
<a class="header" href="print.html#waiting-for-all-threads-to-finish-using-join-handles" id="waiting-for-all-threads-to-finish-using-join-handles"><h3>Waiting for All Threads to Finish Using <code>join</code> Handles</h3></a>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but there is no guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!</p>
<p>We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of <code>thread::spawn</code> in a variable.
The return type of <code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned
value that, when we call the <code>join</code> method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the <code>JoinHandle</code> of the thread we created
in Listing 16-1 and call <code>join</code> to make sure the spawned thread finishes before
<code>main</code> exits:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-2: Saving a <code>JoinHandle</code> from <code>thread::spawn</code>
to guarantee the thread is run to completion</span></p>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the
thread represented by the handle terminates. <em>Blocking</em> a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to <code>join</code> after the main thread’s <code>for</code> loop, running Listing 16-2 should
produce output similar to this:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>But let’s see what happens when we instead move <code>handle.join()</code> before the
<code>for</code> loop in <code>main</code>, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>The main thread will wait for the spawned thread to finish and then run its
<code>for</code> loop, so the output won’t be interleaved anymore, as shown here:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Thinking about such a small detail as where to call <code>join</code> can affect whether
or not your threads run at the same time.</p>
<a class="header" href="print.html#using-move-closures-with-threads" id="using-move-closures-with-threads"><h3>Using <code>move</code> Closures with Threads</h3></a>
<p>The <code>move</code> closure, which we mentioned briefly in Chapter 13, is often used
alongside <code>thread::spawn</code> because it allows us to use data from one thread in
another thread.</p>
<p>In Chapter 13, we said that “If we want to force the closure to take ownership
of the values it uses in the environment, we can use the <code>move</code> keyword before
the parameter list. This technique is mostly useful when passing a closure to a
new thread to move the data so it’s owned by the new thread.”</p>
<p>Now that we’re creating new threads, we’ll talk about capturing values in
closures.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To do so, the spawned thread’s closure must capture the values
it needs. Listing 16-3 shows an attempt to create a vector in the main thread
and use it in the spawned thread. However, this won’t yet work, as you’ll see
in a moment:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span></p>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure’s
environment. Because <code>thread::spawn</code> runs this closure in a new thread, we
should be able to access <code>v</code> inside that new thread. But when we compile this
example, we get the following error:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know if the reference
to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to <code>v</code> from a main thread that drops <code>v</code></span></p>
<p>If we were allowed to run this code, there’s a possibility the spawned thread
will be immediately put in the background without running at all. The spawned
thread has a reference to <code>v</code> inside, but the main thread immediately drops
<code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it
is also invalid. Oh no!</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message’s
advice:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-5: Using the <code>move</code> keyword to force a closure
to take ownership of the values it uses</span></p>
<p>What would happen to the code in Listing 16-4 where the main thread called
<code>drop</code> if we use a <code>move</code> closure? Would <code>move</code> fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isn’t allowed for a different reason. If we add <code>move</code> to the closure, we would
move <code>v</code> into the closure’s environment, and we could no longer call <code>drop</code> on
it in the main thread. We would get this compiler error instead:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing Rust that the main thread won’t use <code>v</code> anymore. If
we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>With a basic understanding of threads and the thread API, let’s look at what we
can <em>do</em> with threads.</p>
<a class="header" href="print.html#message-passing-to-transfer-data-between-threads" id="message-passing-to-transfer-data-between-threads"><h2>Message Passing to Transfer Data Between Threads</h2></a>
<p>One increasingly popular approach to ensuring safe concurrency is <em>message
passing</em>, where threads or actors communicate by sending each other messages
containing data. Here’s the idea in a slogan from the Go language documentation:</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
<p>--<a href="http://golang.org/doc/effective_go.html">Effective Go</a></p>
</blockquote>
<p>One major tool Rust has for accomplishing message sending concurrency is the
<em>channel</em>, a programming concept that Rust’s standard library provides an
implementation of. You can imagine a channel in programming like a channel of
water, such as a stream or a river. If you put something like a rubber duck or
a boat into a stream, it will travel downstream to the end of the river.</p>
<p>A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where we put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of our code calls methods on the transmitter with the data we want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be <em>closed</em> if either the transmitter or receiver half is
dropped.</p>
<p>Here, we’ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We’ll be sending simple values between threads using a channel
to illustrate the feature. Once you’re familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.</p>
<p>First, in Listing 16-6, we’ll create a channel but not do anything with it.
Note that this won’t compile yet because Rust can’t tell what type of values we
want to send over the channel:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
#     tx.send(()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to <code>tx</code> and <code>rx</code></span></p>
<p>We create a new channel using the <code>mpsc::channel</code> function; <code>mpsc</code> stands for
<em>multiple producer, single consumer</em>. In short, the way Rust’s standard library
implements channels means a channel can have multiple <em>sending</em> ends that
produce values but only one <em>receiving</em> end that consumes those values. Imagine
multiple rivers and streams flowing together into one big river: everything
sent down any of the streams will end up in one river at the end. We’ll start
with a single producer for now, but we’ll add multiple producers when we get
this example working.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>The <code>mpsc::channel</code> function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations <code>tx</code>
and <code>rx</code> are traditionally used in many fields for <em>transmitter</em> and <em>receiver</em>
respectively, so we name our variables as such to indicate each end. We’re
using a <code>let</code> statement with a pattern that destructures the tuples; we’ll
discuss the use of patterns in <code>let</code> statements and destructuring in
Chapter 18. Using a <code>let</code> statement this way is a convenient approach to
extract the pieces of the tuple returned by <code>mpsc::channel</code>.</p>
<p>Let’s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Listing 16-7: Moving <code>tx</code> to a spawned thread and sending
“hi”</span></p>
<p>Again, we’re using <code>thread::spawn</code> to create a new thread and then using <code>move</code>
to move <code>tx</code> into the closure so the spawned thread owns <code>tx</code>. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.</p>
<p>The transmitting end has a <code>send</code> method that takes the value we want to send.
The <code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiving end has
already been dropped and there’s nowhere to send a value, the send operation
will return an error. In this example, we’re calling <code>unwrap</code> to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.</p>
<p>In Listing 16-8, we’ll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Listing 16-8: Receiving the value “hi” in the main thread
and printing it</span></p>
<p>The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code>.
We’re using <code>recv</code>, short for <em>receive</em>, which will block the main thread’s
execution and wait until a value is sent down the channel. Once a value is
sent, <code>recv</code> will return it in a <code>Result&lt;T, E&gt;</code>. When the sending end of the
channel closes, <code>recv</code> will return an error to signal that no more values will
be coming.</p>
<p>The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result&lt;T, E&gt;</code>
immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code>
value if there aren’t any messages this time. Using <code>try_recv</code> is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls <code>try_recv</code> every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.</p>
<p>We’ve used <code>recv</code> in this example for simplicity; we don’t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.</p>
<p>When we run the code in Listing 16-8, we’ll see the value printed from the main
thread:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>Perfect!</p>
<a class="header" href="print.html#channels-and-ownership-transference" id="channels-and-ownership-transference"><h3>Channels and Ownership Transference</h3></a>
<p>The ownership rules play a vital role in message sending because they help us
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage we get by making the trade-off of having to think about ownership
throughout our Rust programs. Let’s do an experiment to show how channels and
ownership work together to prevent problems: we’ll try to use a <code>val</code> value in
the spawned thread <em>after</em> we’ve sent it down the channel. Try compiling the
code in Listing 16-9:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Listing 16-9: Attempting to use <code>val</code> after we’ve sent it
down the channel</span></p>
<p>Here, we try to print <code>val</code> after we’ve sent it down the channel via <code>tx.send</code>.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread's modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<p>Our concurrency mistake has caused a compile time error. The <code>send</code> function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.</p>
<a class="header" href="print.html#sending-multiple-values-and-seeing-the-receiver-waiting" id="sending-multiple-values-and-seeing-the-receiver-waiting"><h3>Sending Multiple Values and Seeing the Receiver Waiting</h3></a>
<p>The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 we’ve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-10: Sending multiple messages and pausing
between each one</span></p>
<p>This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of
one second.</p>
<p>In the main thread, we’re not calling the <code>recv</code> function explicitly anymore:
instead, we’re treating <code>rx</code> as an iterator. For each value received, we’re
printing it. When the channel is closed, iteration will end.</p>
<p>When running the code in Listing 16-10, you should see the following output
with a one second pause in between each line:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Because we don’t have any code that pauses or delays in the <code>for</code> loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.</p>
<a class="header" href="print.html#creating-multiple-producers-by-cloning-the-transmitter" id="creating-multiple-producers-by-cloning-the-transmitter"><h3>Creating Multiple Producers by Cloning the Transmitter</h3></a>
<p>Earlier we mentioned that <code>mpsc</code> was an acronym for <em>multiple</em> <em>producer,
single consumer</em>. Let’s put <code>mpsc</code> to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::thread;
# use std::sync::mpsc;
# use std::time::Duration;
#
# fn main() {
// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
# }
</code></pre></pre>
<p><span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span></p>
<p>This time, before we create the first spawned thread, we call <code>clone</code> on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.</p>
<p>When you run the code, you’ll <em>probably</em> see output like this:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
<code>thread::sleep</code>, giving it various values in the different threads, each run
will be more non-deterministic and create different output each time.</p>
<p>Now that we’ve looked at how channels work, let’s look at a different method of
concurrency.</p>
<a class="header" href="print.html#shared-state-concurrency" id="shared-state-concurrency"><h2>Shared State Concurrency</h2></a>
<p>Message passing is a fine way of handling concurrency, but it’s not the only
one. Consider this part of the slogan from the Go language documentation again:
“communicate by sharing memory.”</p>
<p>What would communicating by sharing memory look like? In addition, why would
message passing enthusiasts not use it and do the opposite instead?</p>
<p>In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15
where smart pointers made multiple ownership possible, multiple ownership can
add additional complexity because these different owners need managing. Rust’s
type system and ownership rules greatly assist in getting this management
correct. For an example, let’s look at mutexes, one of the more common
concurrency primitives for shared memory.</p>
<a class="header" href="print.html#mutexes-allow-access-to-data-from-one-thread-at-a-time" id="mutexes-allow-access-to-data-from-one-thread-at-a-time"><h3>Mutexes Allow Access to Data from One Thread at a Time</h3></a>
<p>A <em>mutex</em> is an abbreviation for “mutual exclusion,” as in, it only allows one
thread to access some data at any given time. To access the data in a mutex, a
thread must first signal that it wants access by asking to acquire the mutex’s
<em>lock</em>. The lock is a data structure that is part of the mutex that keeps track
of who currently has exclusive access to the data. Therefore, we describe the
mutex as <em>guarding</em> the data it holds via the locking system.</p>
<p>Mutexes have a reputation for being difficult to use because you have to
remember two rules:</p>
<ol>
<li>You must attempt to acquire the lock before using the data.</li>
<li>When you’re done with the data that the mutex guards, you must unlock the
data so other threads can acquire the lock.</li>
</ol>
<p>For a real-world metaphor of a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel wouldn’t
work as planned!</p>
<p>Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, we can’t get locking and unlocking wrong.</p>
<a class="header" href="print.html#the-api-of-mutext" id="the-api-of-mutext"><h4>The API of <code>Mutex&lt;T&gt;</code></h4></a>
<p>As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Listing 16-12: Exploring the API of <code>Mutex&lt;T&gt;</code> in a
single-threaded context for simplicity</span></p>
<p>As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code>.
To access the data inside the mutex, we use the <code>lock</code> method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.</p>
<p>The call to <code>lock</code> would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
<code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p>After we’ve acquired the lock, we can treat the return value, named <code>num</code> in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in <code>m</code>: <code>Mutex&lt;i32&gt;</code> is not an
<code>i32</code>, so we <em>must</em> acquire the lock to be able to use the <code>i32</code> value. We
can’t forget; the type system won’t let us access the inner <code>i32</code> otherwise.</p>
<p>As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call
to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>. This smart pointer
implements <code>Deref</code> to point at our inner data; the smart pointer also has a
<code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code>
goes out of scope, which happens at the end of the inner scope in Listing
16-12. As a result, we don’t risk forgetting to release the lock and blocking
the mutex from being used by other threads because the lock release happens
automatically.</p>
<p>After dropping the lock, we can print the mutex value and see that we were able
to change the inner <code>i32</code> to 6.</p>
<a class="header" href="print.html#sharing-a-mutext-between-multiple-threads" id="sharing-a-mutext-between-multiple-threads"><h4>Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</h4></a>
<p>Now, let’s try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>.
We’ll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. Note that the next few examples will have
compiler errors, and we’ll use those errors to learn more about using
<code>Mutex&lt;T&gt;</code> and how Rust helps us use it correctly. Listing 16-13 has our
starting example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a <code>Mutex&lt;T&gt;</code></span></p>
<p>We’re creating a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we
did in Listing 16-12. Next, we’re creating 10 threads by mapping over a range
of numbers. We use <code>thread::spawn</code> and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code>
by calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, <code>num</code> will go out of scope and release the
lock so another thread can acquire it.</p>
<p>In the main thread, we collect all the join handles, as we did in Listing 16-2,
and then call <code>join</code> on each to make sure all the threads finish. At that
point, the main thread will acquire the lock and print the result of this
program.</p>
<p>We hinted that this example won’t compile, now let’s find out why!</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:10:27
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>The error message states that the <code>counter</code> value is moved into the closure and
then is captured when we call <code>lock</code>. That description sounds like what we
wanted, but it’s not allowed!</p>
<p>Let’s figure this out by simplifying the program. Instead of making 10 threads
in a <code>for</code> loop, let’s just make two threads without a loop and see what
happens. Replace the first <code>for</code> loop in Listing 16-13 with this code instead:</p>
<pre><code class="language-rust ignore">let handle = thread::spawn(move || {
    let mut num = counter.lock().unwrap();

    *num += 1;
});
handles.push(handle);

let handle2 = thread::spawn(move || {
    let mut num2 = counter.lock().unwrap();

    *num2 += 1;
});
handles.push(handle2);
</code></pre>
<p>We make two threads and change the variable names used with the second thread
to <code>handle2</code> and <code>num2</code>. When we run the code this time, compiling gives us the
following:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:16:24
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:26:29
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>Aha! The first error message indicates that <code>counter</code> is moved into the closure
for the thread associated with <code>handle</code>. That move is preventing us from
capturing <code>counter</code> when we try to call <code>lock</code> on it and store the result in
<code>num2</code> in the second thread! So Rust is telling us that we can’t move ownership
of <code>counter</code> into multiple threads. This was hard to see earlier because our
threads were in a loop, and Rust can’t point to different threads in different
iterations of the loop. Let’s fix the compiler error with a multiple-ownership
method we discussed in Chapter 15.</p>
<a class="header" href="print.html#multiple-ownership-with-multiple-threads" id="multiple-ownership-with-multiple-threads"><h4>Multiple Ownership with Multiple Threads</h4></a>
<p>In Chapter 15, we gave a value multiple owners by using the smart pointer
<code>Rc&lt;T&gt;</code> to create a reference-counted value. Let’s do the same here and see
what happens. We’ll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone
the <code>Rc&lt;T&gt;</code> before moving ownership to the thread. Now that we’ve seen the
errors, we’ll also switch back to using the <code>for</code> loop, and we’ll keep the
<code>move</code> keyword with the closure:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-14: Attempting to use <code>Rc&lt;T&gt;</code> to allow
multiple threads to own the <code>Mutex&lt;T&gt;</code></span></p>
<p>Once again, we compile and get... different errors! The compiler is teaching us
a lot.</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:
15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
  --&gt; src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is
not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
   = note: required by `std::thread::spawn`
</code></pre>
<p>Wow, that error message is very wordy! Here are some important parts to focus
on: the first inline error says <code>`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. The reason for this is in the next important
part to focus on, the error message. The distilled error message says <code>the trait bound `Send` is not satisfied</code>. We’ll talk about <code>Send</code> in the next
section: it’s one of the traits that ensures the types we use with threads are
meant for use in concurrent situations.</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code>
manages the reference count, it adds to the count for each call to <code>clone</code> and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type exactly like <code>Rc&lt;T&gt;</code> but one that makes changes
to the reference count in a thread-safe way.</p>
<a class="header" href="print.html#atomic-reference-counting-with-arct" id="atomic-reference-counting-with-arct"><h4>Atomic Reference Counting with <code>Arc&lt;T&gt;</code></h4></a>
<p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in
concurrent situations. The ‘a’ stands for <em>atomic</em>, meaning it’s an <em>atomically
reference counted</em> type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for <code>std::sync::atomic</code> for more details. At this point, you just
need to know that atomics work like primitive types but are safe to share
across threads.</p>
<p>You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use <code>Arc&lt;T&gt;</code> by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.</p>
<p>Let’s return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix
our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to
<code>clone</code>. The code in Listing 16-15 will finally compile and run:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Listing 16-15: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code>
to be able to share ownership across multiple threads</span></p>
<p>This code will print the following:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, then use a <code>Mutex&lt;T&gt;</code> to have each
thread update the final result with its part.</p>
<a class="header" href="print.html#similarities-between-refcelltrct-and-mutextarct" id="similarities-between-refcelltrct-and-mutextarct"><h3>Similarities Between <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></h3></a>
<p>You might have noticed that <code>counter</code> is immutable, but we could get a mutable
reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior
mutability, like the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code>
in Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use
<code>Mutex&lt;T&gt;</code> to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>Another detail to note is that Rust can’t protect us from all kinds of logic
errors when we use <code>Mutex&lt;T&gt;</code>. Recall in Chapter 15 that using <code>Rc&lt;T&gt;</code> came
with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to
each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of
creating <em>deadlocks</em>. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers
useful information.</p>
<p>We’ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits, and
how we can use them with custom types.</p>
<a class="header" href="print.html#extensible-concurrency-with-the-sync-and-send-traits" id="extensible-concurrency-with-the-sync-and-send-traits"><h2>Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</h2></a>
<p>Interestingly, the Rust language has <em>very</em> few concurrency features. Almost
every concurrency feature we’ve talked about so far in this chapter has been
part of the standard library, not the language. Our options for handling
concurrency are not limited to the language or the standard library; we can
write our own concurrency features or use those written by others.</p>
<p>However, two concurrency concepts are embedded in the language: the
<code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<a class="header" href="print.html#allowing-transference-of-ownership-between-threads-with-send" id="allowing-transference-of-ownership-between-threads-with-send"><h3>Allowing Transference of Ownership Between Threads with <code>Send</code></h3></a>
<p>The <code>Send</code> marker trait indicates that ownership of the type implementing
<code>Send</code> can be transferred between threads. Almost every Rust type is <code>Send</code>,
but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this cannot be <code>Send</code> because
if we cloned an <code>Rc&lt;T&gt;</code> value and tried to transfer ownership of the clone to
another thread, both threads might update the reference count at the same time.
For this reason, <code>Rc&lt;T&gt;</code> is implemented for use in single-threaded situations
where you don’t want to pay the thread-safe performance penalty.</p>
<p>Therefore, Rust’s type system and trait bounds ensure that we can never
accidentally send an <code>Rc&lt;T&gt;</code> value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. When we switched to <code>Arc&lt;T&gt;</code>, which is <code>Send</code>, the code
compiled.</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as
well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which
we’ll discuss in Chapter 19.</p>
<a class="header" href="print.html#allowing-access-from-multiple-threads-with-sync" id="allowing-access-from-multiple-threads-with-sync"><h3>Allowing Access from Multiple Threads with <code>Sync</code></h3></a>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing
<code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is
<code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code>, meaning the reference can be
sent safely to another thread. Similar to <code>Send</code>, primitive types are <code>Sync</code>
and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> is also not <code>Sync</code> for the same reasons that it’s not
<code>Send</code>. The <code>RefCell&lt;T&gt;</code> type (which we talked about in Chapter 15) and the
family of related <code>Cell&lt;T&gt;</code> types are not <code>Sync</code>. The implementation of borrow
checking that <code>RefCell&lt;T&gt;</code> does at runtime is not thread-safe. The smart
pointer <code>Mutex&lt;T&gt;</code> is <code>Sync</code> and can be used to share access with multiple
threads, as you saw in the “Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads”
section.</p>
<a class="header" href="print.html#implementing-send-and-sync-manually-is-unsafe" id="implementing-send-and-sync-manually-is-unsafe"><h3>Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</h3></a>
<p>Because types that are made up of <code>Send</code> and <code>Sync</code> traits are automatically
also <code>Send</code> and <code>Sync</code>, we don’t have to implement those traits manually. As
marker traits, they don’t even have any methods to implement. They’re just
useful for enforcing invariants related to concurrency.</p>
<p>Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of <code>Send</code> and
<code>Sync</code> parts requires careful thought to uphold the safety guarantees.
<a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon</a> has more information about these guarantees and how to
uphold them.</p>
<a class="header" href="print.html#summary-11" id="summary-11"><h2>Summary</h2></a>
<p>This isn’t the last you’ll see of concurrency in this book: the project in
Chapter 20 will use the concepts examined in this chapter in a more realistic
situation than the smaller examples discussed here.</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.</p>
<p>The Rust standard library provides channels for message passing and smart
pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once we get our code to compile, we can rest assured that it will happily run
on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!</p>
<p>Next, we’ll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms
relate to those you might be familiar with from object-oriented programming.</p>
<a class="header" href="print.html#is-rust-an-object-oriented-programming-language" id="is-rust-an-object-oriented-programming-language"><h1>Is Rust an Object-Oriented Programming Language?</h1></a>
<p>Object-Oriented Programming is a way of modeling programs that originated with
Simula in the 1960s and became popular with C++ in the 1990s. There are many
competing definitions for what counts as OOP, and under some definitions, Rust
is object-oriented; under other definitions, it is not. In this chapter, we’ll
explore some characteristics that are commonly considered to be object-oriented
and how those characteristics translate to idiomatic Rust. We’ll then show you
how to implement an object-oriented design pattern in Rust and discuss the
tradeoffs of doing so versus implementing a solution using some of Rust’s
strengths instead.</p>
<a class="header" href="print.html#what-does-object-oriented-mean" id="what-does-object-oriented-mean"><h2>What Does Object-Oriented Mean?</h2></a>
<p>There’s no consensus in the programming community about what features a
language needs in order to be called object-oriented. Rust is influenced by
many different programming paradigms including OOP; we explored, for example,
the features that came from functional programming in Chapter 13. Arguably,
object-oriented programming languages do tend to share certain common
characteristics, namely objects, encapsulation, and inheritance. Let’s take a
look at what each of those mean and whether Rust supports them.</p>
<a class="header" href="print.html#objects-contain-data-and-behavior" id="objects-contain-data-and-behavior"><h3>Objects Contain Data and Behavior</h3></a>
<!-- Is there a reason we're using this book as the reference, is it generally
accepted as an authority? -->
<!-- Yes, it is. For example, Martin Fowler (himself regarded as an authority)
had this to say about it https://www.martinfowler.com/bliki/GangOfFour.html:
> In my view the Gang of Four is the best book ever written on object-oriented
> design - possibly of any style of design.
/Carol -->
<p>The book “Design Patterns: Elements of Reusable Object-Oriented Software,”
colloquially referred to as “The Gang of Four book,” is a catalog of
object-oriented design patterns. It defines object-oriented programming in this
way:</p>
<blockquote>
<p>Object-oriented programs are made up of objects. An <em>object</em> packages both
data and the procedures that operate on that data. The procedures are
typically called <em>methods</em> or <em>operations</em>.</p>
</blockquote>
<p>Under this definition, then, Rust is object-oriented: structs and enums have
data and <code>impl</code> blocks provide methods on structs and enums. Even though
structs and enums with methods aren’t <em>called</em> objects, they provide the same
functionality, under the Gang of Four’s definition of objects.</p>
<a class="header" href="print.html#encapsulation-that-hides-implementation-details" id="encapsulation-that-hides-implementation-details"><h3>Encapsulation that Hides Implementation Details</h3></a>
<p>Another aspect commonly associated with object-oriented programming is the idea
of <em>encapsulation</em>: that the implementation details of an object aren’t
accessible to code using that object. The only way to interact with an object
therefore is through its public API; code using the object should not be able
to reach into the object’s internals and change data or behavior directly. This
enables the programmer to change and refactor an object’s internals without
needing to change the code that uses the object.</p>
<p>We discussed an example of this in Chapter 7: We can use the <code>pub</code> keyword to
decide what modules, types, functions, and methods in our code should be
public, and by default everything else is private. For example, we can define a
struct <code>AveragedCollection</code> that has a field containing a vector of <code>i32</code>
values. The struct can also have a field that contains the average of the
values in the vector, meaning the average doesn’t have to be computed on-demand
whenever anyone needs it. In other words, <code>AveragedCollection</code> will cache the
calculated average for us. Listing 17-1 has the definition of the
<code>AveragedCollection</code> struct:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-1: An <code>AveragedCollection</code> struct that
maintains a list of integers and the average of the items in the
collection.</span></p>
<p>The struct itself is marked <code>pub</code> so that other code may use it, but the fields
within the struct remain private. This is important in this case because we
want to ensure that whenever a value is added or removed from the list, the
average is also updated. We do this by implementing <code>add</code>, <code>remove</code>, and
<code>average</code> methods on the struct as shown in Listing 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct AveragedCollection {
#     list: Vec&lt;i32&gt;,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-2: Implementations of the public methods
<code>add</code>, <code>remove</code>, and <code>average</code> on <code>AveragedCollection</code></span></p>
<p>The public methods <code>add</code>, <code>remove</code>, and <code>average</code> are the only way to modify an
instance of <code>AveragedCollection</code>. When an item is added to <code>list</code> using the
<code>add</code> method or removed using the <code>remove</code> method, the implementations of each
call the private <code>update_average</code> method that takes care of updating the
<code>average</code> field as well.</p>
<p>We leave the <code>list</code> and <code>average</code> fields private so that there’s no way for
external code to add or remove items to the <code>list</code> field directly, otherwise
the <code>average</code> field might become out of sync when the <code>list</code> changes. The
<code>average</code> method returns the value in the <code>average</code> field, allowing external
code to read the <code>average</code> but not modify it.</p>
<p>Because we’ve encapsulated the implementation details of <code>AveragedCollection</code>,
we can easily change aspects like the data structure in the future. For
instance, we could use a <code>HashSet</code> instead of a <code>Vec</code> for the <code>list</code> field. As
long as the signatures of the <code>add</code>, <code>remove</code>, and <code>average</code> public methods
stay the same, code using <code>AveragedCollection</code> wouldn’t need to change. If we
made <code>list</code> public instead, this wouldn’t necessarily be the case: <code>HashSet</code>
and <code>Vec</code> have different methods for adding and removing items, so the external
code would likely have to change if it was modifying <code>list</code> directly.</p>
<p>If encapsulation is a required aspect for a language to be considered
object-oriented, then Rust meets that requirement. The option to use <code>pub</code> or
not for different parts of code enables encapsulation of implementation details.</p>
<a class="header" href="print.html#inheritance-as-a-type-system-and-as-code-sharing" id="inheritance-as-a-type-system-and-as-code-sharing"><h3>Inheritance as a Type System and as Code Sharing</h3></a>
<p><em>Inheritance</em> is a mechanism whereby an object can inherit from another
object’s definition, thus gaining the parent object’s data and behavior without
you having to define them again.</p>
<p>If a language must have inheritance to be an object-oriented language, then
Rust is not. There is no way to define a struct that inherits the parent
struct’s fields and method implementations. However, if you’re used to having
inheritance in your programming toolbox, there are other solutions in Rust
depending on your reason for reaching for inheritance in the first place.</p>
<p>There are two main reasons to choose inheritance. The first is for re-use of
code: you can implement particular behavior for one type, and inheritance
enables you to re-use that implementation for a different type. Rust code can
be shared using default trait method implementations instead, which we saw in
Listing 10-15 when we added a default implementation of the <code>summarize</code> method
on the <code>Summary</code> trait. Any type implementing the <code>Summary</code> trait would have
the <code>summarize</code> method available on it without any further code. This is
similar to a parent class having an implementation of a method, and an
inheriting child class then also having the implementation of the method. We
can also choose to override the default implementation of the <code>summarize</code>
method when we implement the <code>Summary</code> trait, similar to a child class
overriding the implementation of a method inherited from a parent class.</p>
<p>The second reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called <em>polymorphism</em>, which means that multiple objects can be substituted for
each other at runtime if they share certain characteristics.</p>
<!-- What does it mean for objects to have the same shape? -->
<!-- The use of "shape" in this context has to do with the roots of "morph" in
"polymorphism", but it's not very well defined so I've reworded. /Carol -->
<!-- PROD: START BOX -->
<blockquote>
<p>Polymorphism</p>
<p>To many people, polymorphism is synonymous with inheritance. But it’s
actually a more general concept that refers to code that can work with data
of multiple types. For inheritance, those types are generally subclasses.
Rust instead uses generics to abstract over different possible types, and
trait bounds to impose constraints on what those types must provide. This is
sometimes called <em>bounded parametric polymorphism</em>.</p>
</blockquote>
<!-- PROD: END BOX -->
<p>Inheritance has recently fallen out of favor as a programming design solution
in many programming languages because it’s often at risk of sharing more code
than needs be. Subclasses shouldn’t always share all characteristics of their
parent class, but will do so with inheritance. This can make a program’s design
less flexible, and introduces the possibility of calling methods on subclasses
that don’t make sense or that cause errors because the methods don’t actually
apply to the subclass. Some languages will also only allow a subclass to
inherit from one class, further restricting the flexibility of a program’s
design.</p>
<p>For these reasons, Rust chose to take a different approach, using trait objects
instead of inheritance. Let’s take a look at how trait objects enable
polymorphism in Rust.</p>
<a class="header" href="print.html#using-trait-objects-that-allow-for-values-of-different-types" id="using-trait-objects-that-allow-for-values-of-different-types"><h2>Using Trait Objects that Allow for Values of Different Types</h2></a>
<p>In Chapter 8, we mentioned that one limitation of vectors is that they can only
store elements of one type. We created a workaround in Listing 8-10 where we
defined a <code>SpreadsheetCell</code> enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code gets compiled.</p>
<p>Sometimes, however, we want the user of our library to be able to extend the
set of types that are valid in a particular situation. To show how we might
achieve this, we’ll create an example Graphical User Interface tool that
iterates through a list of items, calling a <code>draw</code> method on each one to drawn
it to the screen; a common technique for GUI tools. We’re going to create a
library crate containing the structure of a GUI library called <code>rust_gui</code>. This
crate might include some types for people to use, such as <code>Button</code> or
<code>TextField</code>. On top of these, users of <code>rust_gui</code> will want to create their own
types that can be drawn on the screen: for instance, one programmer might add
an <code>Image</code>, another might add a <code>SelectBox</code>.</p>
<p>We won’t implement a fully-fledged GUI library for this example, but will show
how the pieces would fit together. At the time of writing the library, we can’t
know and define all the types other programmers will want to create. What we do
know is that <code>rust_gui</code> needs to keep track of a bunch of values that are of
different types, and it needs to be able to call a <code>draw</code> method on each of
these differently-typed values. It doesn’t need to know exactly what will
happen when we call the <code>draw</code> method, just that the value will have that
method available for us to call.</p>
<p>To do this in a language with inheritance, we might define a class named
<code>Component</code> that has a method named <code>draw</code> on it. The other classes like
<code>Button</code>, <code>Image</code>, and <code>SelectBox</code> would inherit from <code>Component</code> and thus
inherit the <code>draw</code> method. They could each override the <code>draw</code> method to define
their custom behavior, but the framework could treat all of the types as if
they were <code>Component</code> instances and call <code>draw</code> on them. But Rust doesn’t have
inheritance, so we need another way.</p>
<a class="header" href="print.html#defining-a-trait-for-common-behavior" id="defining-a-trait-for-common-behavior"><h3>Defining a Trait for Common Behavior</h3></a>
<p>To implement the behavior we want <code>rust_gui</code> to have, we’ll define a trait
named <code>Draw</code> that will have one method named <code>draw</code>. Then we can define a
vector that takes a <em>trait object</em>. A trait object points to an instance of a
type that implements the trait we specify. We create a trait object by
specifying some sort of pointer, such as a <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart
pointer, and then specifying the relevant trait (we’ll talk about the reason
trait objects have to use a pointer in Chapter 19 in the section on Dynamically
Sized Types). We can use trait objects in place of a generic or concrete type.
Wherever we use a trait object, Rust’s type system will ensure at compile-time
that any value used in that context will implement the trait object’s trait.
This way we don’t need to know all the possible types at compile time.</p>
<!-- What will the trait object do in this case? I've taken this last part of
the line from below, but I'm not 100% on that -->
<!-- I've moved up more and reworded a bit, hope that clarifies /Carol -->
<p>We’ve mentioned that in Rust we refrain from calling structs and enums
“objects” to distinguish them from other languages’ objects. In a struct or
enum, the data in the struct fields and the behavior in <code>impl</code> blocks is
separated, whereas in other languages the data and behavior combined into one
concept is often labeled an object. Trait objects, though, <em>are</em> more like
objects in other languages, in the sense that they combine both data and
behavior. However, trait objects differ from traditional objects in that we
can’t add data to a trait object. Trait objects aren’t as generally useful as
objects in other languages: their specific purpose is to allow abstraction
across common behavior.</p>
<p>Listing 17-3 shows how to define a trait named <code>Draw</code> with one method named
<code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn draw(&amp;self);
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-3: Definition of the <code>Draw</code> trait</span></p>
<p>This should look familiar from our discussions on how to define traits in
Chapter 10. Next comes something new: Listing 17-4 defines a struct named
<code>Screen</code> that holds a vector named <code>components</code>. This vector is of type
<code>Box&lt;Draw&gt;</code>, which is a trait object: it’s a stand-in for any type inside a
<code>Box</code> that implements the <code>Draw</code> trait.</p>
<!-- Would it be useful to let the reader know why we need a box here, or will
that be clear at this point? -->
<!-- We get into this in chapter 19; I've added a reference to the start of
this section where we talk about needing a `&` or a `Box` to be a trait object.
/Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-4: Definition of the <code>Screen</code> struct with a
<code>components</code> field holding a vector of trait objects that implement the <code>Draw</code>
trait</span></p>
<p>On the <code>Screen</code> struct, we’ll define a method named <code>run</code> that will call the
<code>draw</code> method on each of its <code>components</code>, as shown in Listing 17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
# pub struct Screen {
#     pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-5: Implementing a <code>run</code> method on <code>Screen</code>
that calls the <code>draw</code> method on each component</span></p>
<p>This works differently to defining a struct that uses a generic type parameter
with trait bounds. A generic type parameter can only be substituted with one
concrete type at a time, while trait objects allow for multiple concrete types
to fill in for the trait object at runtime. For example, we could have defined
the <code>Screen</code> struct using a generic type and a trait bound as in Listing 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-6: An alternate implementation of the <code>Screen</code>
struct and its <code>run</code> method using generics and trait bounds</span></p>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of
type <code>Button</code> or all of type <code>TextField</code>. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable since the
definitions will be monomorphized at compile time to use the concrete types.</p>
<p>With the method using trait objects, on the other hand, one <code>Screen</code>
instance can hold a <code>Vec</code> that contains a <code>Box&lt;Button&gt;</code> as well as a
<code>Box&lt;TextField&gt;</code>. Let’s see how that works, and then talk about the runtime
performance implications.</p>
<a class="header" href="print.html#implementing-the-trait" id="implementing-the-trait"><h3>Implementing the Trait</h3></a>
<p>Now we’ll add some types that implement the <code>Draw</code> trait. We’re going to
provide the <code>Button</code> type. Again, actually implementing a GUI library is out of
scope of this book, so the <code>draw</code> method won’t have any useful implementation
in its body. To imagine what the implementation might look like, a <code>Button</code>
struct might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in
Listing 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code to actually draw a button
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-7: A <code>Button</code> struct that implements the
<code>Draw</code> trait</span></p>
<p>The <code>width</code>, <code>height</code>, and <code>label</code> fields on <code>Button</code> will differ from the
fields on other components, such as a <code>TextField</code> type that might have those
plus a <code>placeholder</code> field instead. Each of the types we want to draw on the
screen will implement the <code>Draw</code> trait, with different code in the <code>draw</code>
method to define how to draw that particular type, like <code>Button</code> has here
(without the actual GUI code that’s out of scope of this chapter). <code>Button</code>,
for instance, might have an additional <code>impl</code> block containing methods related
to what happens if the button is clicked. These kinds of methods won’t apply to
types like <code>TextField</code>.</p>
<p>Someone using our library has decided to implement a <code>SelectBox</code> struct that
has <code>width</code>, <code>height</code>, and <code>options</code> fields. They implement the <code>Draw</code> trait on
the <code>SelectBox</code> type as well, as shown in Listing 17-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">Listing 17-8: Another crate using <code>rust_gui</code> and
implementing the <code>Draw</code> trait on a <code>SelectBox</code> struct</span></p>
<p>The user of our library can now write their <code>main</code> function to create a
<code>Screen</code> instance. To this they can add a <code>SelectBox</code> and a <code>Button</code> by putting
each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the <code>run</code>
method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the
components. Listing 17-9 shows this implementation:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rust_gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span></p>
<p>When we wrote the library, we didn’t know that someone would add the
<code>SelectBox</code> type someday, but our <code>Screen</code> implementation was able to operate
on the new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> type,
which means it implements the <code>draw</code> method.</p>
<p>This concept---of being concerned only with the messages a value responds to,
rather than the value’s concrete type---is similar to a concept in dynamically
typed languages called <em>duck typing</em>: if it walks like a duck, and quacks like
a duck, then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code> in
Listing 17-5, <code>run</code> doesn’t need to know what the concrete type of each
component is. It doesn’t check to see if a component is an instance of a
<code>Button</code> or a <code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By
specifying <code>Box&lt;Draw&gt;</code> as the type of the values in the <code>components</code> vector,
we’ve defined <code>Screen</code> to need values that we can call the <code>draw</code> method on.</p>
<!-- I may be slow on the uptake here, but it seems like we're saying that
responsibility for how the type trait object behaves with the draw method is
called on it belongs to the trait object, and not to the draw method itself. Is
that an accurate summary? I want to make sure I'm clearly following the
argument! -->
<!-- Each type (like `Button` or `SelectBox`) that implements the `Draw` trait
can customize what happens in the body of the `draw` method. The trait object
is just responsible for making sure that the only things that are usable in
that context are things that implement the `Draw` trait. Does this clear it up
at all? Is there something we should clarify in the text? /Carol -->
<p>The advantage of using trait objects and Rust’s type system to do something
similar to duck typing is that we never have to check that a value implements a
particular method at runtime or worry about getting errors if a value doesn’t
implement a method but we call it anyway. Rust won’t compile our code if the
values don’t implement the traits that the trait objects need.</p>
<p>For example, Listing 17-10 shows what happens if we try to create a <code>Screen</code>
with a <code>String</code> as a component:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-10: Attempting to use a type that doesn’t
implement the trait object’s trait</span></p>
<p>We’ll get this error because <code>String</code> doesn’t implement the <code>rust_gui::Draw</code> trait:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: rust_gui::Draw` is not satisfied
  --&gt;
   |
 4 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `rust_gui::Draw` is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `rust_gui::Draw`
</code></pre>
<p>This lets us know that either we’re passing something to <code>Screen</code> we didn’t
mean to pass, and we should pass a different type, or implement <code>Draw</code> on
<code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<a class="header" href="print.html#trait-objects-perform-dynamic-dispatch" id="trait-objects-perform-dynamic-dispatch"><h3>Trait Objects Perform Dynamic Dispatch</h3></a>
<p>Recall from Chapter 10 our discussion on the monomorphization process performed
by the compiler when we use trait bounds on generics: the compiler generates
non-generic implementations of functions and methods for each concrete type
that we use in place of a generic type parameter. The code that results from
monomorphization is doing <em>static dispatch</em>. Static dispatch is when the
compiler knows what method you’re calling at compile time. This is opposed to
<em>dynamic dispatch</em>, when the compiler can’t tell at compile time which method
you’re calling. In these cases, the compiler emits code that will figure out at
runtime which method to call.</p>
<!--I'm struggling to follow the static dispatch definition, can you expand
that a little? Which part of that is the static dispatch, pre-determining the
code called with a method and storing it? -->
<!-- Yes, in a way. We've expanded and moved the definitions of static and
dynamic dispatch together to better contrast, hopefully this helps? /Carol -->
<p>When we use trait objects, Rust has to use dynamic dispatch. The compiler
doesn’t know all the types that might be used with the code using trait
objects, so it doesn’t know which method implemented on which type to call.
Instead, Rust uses the pointers inside of the trait object at runtime to know
which specific method to call. There’s a runtime cost when this lookup happens,
compared to static dispatch. Dynamic dispatch also prevents the compiler from
choosing to inline a method’s code which in turn prevents some optimizations.
We did get extra flexibility in the code that we wrote and were able to
support, though, so it’s a tradeoff to consider.</p>
<a class="header" href="print.html#object-safety-is-required-for-trait-objects" id="object-safety-is-required-for-trait-objects"><h3>Object Safety is Required for Trait Objects</h3></a>
<!-- Liz: we're conflicted on including this section. Not being able to use a
trait as a trait object because of object safety is something that
beginner/intermediate Rust developers run into sometimes, but explaining it
fully is long and complicated. Should we just cut this whole section? Leave it
(and finish the explanation of how to fix the error at the end)? Shorten it to
a quick caveat, that just says something like "Some traits can't be trait
objects. Clone is an example of one. You'll get errors that will let you know
if a trait can't be a trait object, look up object safety if you're interested
in the details"? Thanks! /Carol -->
<!-- That sounds like a good solution, since the compiler will warn them in any
case. I read through, editing a little, and I agree we could afford to cut it,
I'm not sure it brings practical skills to the user -->
<!-- Ok, I've cut section way down to the practical pieces, but still explained
a little bit /Carol -->
<p>Only <em>object safe</em> traits can be made into trait objects. There are some
complex rules around all the properties that make a trait object safe, but in
practice, there are only two rules that are relevant. A trait is object safe if
all of the methods defined in the trait have the following properties:</p>
<ul>
<li>The return type isn’t <code>Self</code></li>
<li>There aren’t any generic type parameters</li>
</ul>
<p>The <code>Self</code> keyword is an alias for the type we’re implementing traits or
methods on. Object safety is required for trait objects because once you have a
trait object, you no longer know what the concrete type implementing that trait
is. If a trait method returns the concrete <code>Self</code> type, but a trait object
forgets the exact type that it is, there’s no way that the method can use the
original concrete type that it’s forgotten. Same with generic type parameters
that are filled in with concrete type parameters when the trait is used: the
concrete types become part of the type that implements the trait. When the type
is erased by the use of a trait object, there’s no way to know what types to
fill in the generic type parameters with.</p>
<p>An example of a trait whose methods are not object safe is the standard
library’s <code>Clone</code> trait. The signature for the <code>clone</code> method in the <code>Clone</code>
trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<p><code>String</code> implements the <code>Clone</code> trait, and when we call the <code>clone</code> method on
an instance of <code>String</code> we get back an instance of <code>String</code>. Similarly, if we
call <code>clone</code> on an instance of <code>Vec</code>, we get back an instance of <code>Vec</code>. The
signature of <code>clone</code> needs to know what type will stand in for <code>Self</code>, since
that’s the return type.</p>
<p>The compiler will tell you if you’re trying to do something that violates the
rules of object safety in regards to trait objects. For example, if we had
tried to implement the <code>Screen</code> struct in Listing 17-4 to hold types that
implement the <code>Clone</code> trait instead of the <code>Draw</code> trait, like this:</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>We’ll get this error:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt;
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
  made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>This means you can’t use this trait as a trait object in this way. If you’re
interested in more details on object safety, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>
<a class="header" href="print.html#implementing-an-object-oriented-design-pattern" id="implementing-an-object-oriented-design-pattern"><h2>Implementing an Object-Oriented Design Pattern</h2></a>
<p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, represented by a set of <em>state
objects</em>, and the value’s behavior changes based on the internal state. The
state objects share functionality--in Rust, of course, we use structs and
traits rather than objects and inheritance. Each state object representing the
state is responsible for its own behavior and for governing when it should
change into another state. The value that holds a state object knows nothing
about the different behavior of the states or when to transition between states.</p>
<!-- Below -- requirements for what, for what we need the value for? -->
<!-- I've clarified /Carol -->
<p>Using the state pattern means when the business requirements of the program
change, we won’t need to change the code of the value holding the state or the
code that uses the value. We’ll only need to update the code inside one of the
state objects to change its rules, or perhaps add more state objects. Let’s
look at an example of the state design pattern and how to use it in Rust.</p>
<p>To explore this idea, we’ll implement a blog post workflow in an incremental
way. The blog’s final functionality will look like this:</p>
<ol>
<li>A blog post starts as an empty draft.</li>
<li>Once the draft is done, a review of the post is requested.</li>
<li>Once the post is approved, it gets published.</li>
<li>Only published blog posts return content to print, so unapproved posts can’t
accidentally be published.</li>
</ol>
<p>Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should stay an unpublished draft.</p>
<p>Listing 17-11 shows this workflow in code form. This is an example usage of the
API we’re going to implement in a library crate named <code>blog</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our <code>blog</code> crate to have</span></p>
<p>We want to allow the user to create a new draft blog post with <code>Post::new</code>.
Then, we want to allow text to be added to the blog post while it’s in the
draft state. If we try to get the post’s content immediately, before
approval, nothing should happen because the post is still a draft. We’ve added
an <code>assert_eq!</code> here for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
<code>content</code> method, but we’re not going to write tests for this example.</p>
<p>Next, we want to enable a request for a review of the post, and we want
<code>content</code> to return an empty string while waiting for the review. Lastly, when
the post receives approval, it should get published, meaning the text of the
post will be returned when <code>content</code> is called.</p>
<!-- Below -- so this is where we'll implement the state pattern? If so, can
you make that explicit, just to be clear! I've added some text to the second
line, not sure if that's accurate though -->
<!-- Yes, the state pattern will be implemented within the `Post` type. I've
tweaked the wording a bit but you've pretty much got it! /Carol-->
<p>Notice that the only type we’re interacting with from the crate is the <code>Post</code>
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in---draft, waiting for review, or published. Changing from one state to
another will be managed internally within the <code>Post</code> type. The states change in
response to the methods users of our library call on the <code>Post</code> instance, but
they don’t have to manage the state changes directly. This also means users
can’t make a mistake with the states, like publishing a post before it is
reviewed.</p>
<a class="header" href="print.html#defining-post-and-creating-a-new-instance-in-the-draft-state" id="defining-post-and-creating-a-new-instance-in-the-draft-state"><h3>Defining <code>Post</code> and Creating a New Instance in the Draft State</h3></a>
<p>Let’s get started on the implementation of the library! We know we need a
public <code>Post</code> struct that holds some content, so let’s start with the
definition of the struct and an associated public <code>new</code> function to create an
instance of <code>Post</code>, as shown in Listing 17-12. We’ll also make a private
<code>State</code> trait. Then <code>Post</code> will hold a trait object of <code>Box&lt;State&gt;</code> inside an
<code>Option</code> in a private field named <code>state</code>. We’ll see why the <code>Option</code> is
necessary in a bit.</p>
<p>The <code>State</code> trait defines the behavior shared by different post states, and the
<code>Draft</code>, <code>PendingReview</code>, and <code>Published</code> states will all implement the <code>State</code>
trait. For now, the trait does not have any methods, and we’re going to start
by defining just the <code>Draft</code> state since that’s the state we want a post to
start in:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
#}</code></pre></pre>
<p><span class="caption">Listing 17-12: Definition of a <code>Post</code> struct and a <code>new</code>
function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code>
struct</span></p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that
holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct. This
ensures whenever we create a new instance of <code>Post</code>, it’ll start out as a
draft. Because the <code>state</code> field of <code>Post</code> is private, there’s no way to create
a <code>Post</code> in any other state!</p>
<a class="header" href="print.html#storing-the-text-of-the-post-content" id="storing-the-text-of-the-post-content"><h3>Storing the Text of the Post Content</h3></a>
<p>In the <code>Post::new</code> function, we set the <code>content</code> field to a new, empty
<code>String</code>. Listing 17-11 showed that we want to be able to call a method named
<code>add_text</code> and pass it a <code>&amp;str</code> that’s then added to the text content of the
blog post. We implement this as a method rather than exposing the <code>content</code>
field as <code>pub</code>. This means we can implement a method later that will control
how the <code>content</code> field’s data is read. The <code>add_text</code> method is pretty
straightforward, so let’s add the implementation in Listing 17-13 to the <code>impl Post</code> block:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-13: Implementing the <code>add_text</code> method to add
text to a post’s <code>content</code></span></p>
<p><code>add_text</code> takes a mutable reference to <code>self</code>, since we’re changing the <code>Post</code>
instance that we’re calling <code>add_text</code> on. We then call <code>push_str</code> on the
<code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to the saved
<code>content</code>. This behavior doesn’t depend on the state the post is in so it’s not
part of the state pattern. The <code>add_text</code> method doesn’t interact with the
<code>state</code> field at all, but it is part of the behavior we want to support.</p>
<a class="header" href="print.html#ensuring-the-content-of-a-draft-post-is-empty" id="ensuring-the-content-of-a-draft-post-is-empty"><h3>Ensuring the Content of a Draft Post is Empty</h3></a>
<p>Even after we’ve called <code>add_text</code> and added some content to our post, we still
want the <code>content</code> method to return an empty string slice since the post is
still in the draft state, as shown on line 8 of Listing 17-11. For now, let’s
implement the <code>content</code> method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We’re going to change this
later once we implement the ability to change a post’s state so it can be
published. So far, though, posts can only be in the draft state, so the post
content should always be empty. Listing 17-14 shows this placeholder
implementation:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-14: Adding a placeholder implementation for
the <code>content</code> method on <code>Post</code> that always returns an empty string slice</span></p>
<p>With this added <code>content</code> method, everything in Listing 17-11 up to line 8
works as we intend.</p>
<a class="header" href="print.html#requesting-a-review-of-the-post-changes-its-state" id="requesting-a-review-of-the-post-changes-its-state"><h3>Requesting a Review of the Post Changes its State</h3></a>
<p>Next up we need to add functionality to request a review of a post, which
should change its state from <code>Draft</code> to <code>PendingReview</code>. We want to give <code>Post</code>
a public method named <code>request_review</code> that will take a mutable reference to
<code>self</code>. Then we’re going to call an internal <code>request_review</code> method on the
current state of <code>Post</code>, and this second <code>request_review</code> method will consume
the current state and return a new state. Listing 17-15 shows this code:</p>
<!-- NOTE TO DE/AU: We might want to move this explanation to after the code if
you want to add wingdings, we can see once we transfer it to Word -->
<!-- I decided to move some of this explanation after the code for this reason
and because we got some questions about this example that I wanted to expand
upon /Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-15: Implementing <code>request_review</code> methods on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We’ve added the <code>request_review</code> method to the <code>State</code> trait; all types that
implement the trait will now need to implement the <code>request_review</code> method.
Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first
parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the
method is only valid when called on a <code>Box</code> holding the type. This syntax takes
ownership of <code>Box&lt;Self&gt;</code>, invalidating the old state so that the state value of
the <code>Post</code> can transform itself into a new state.</p>
<!-- Above -- so Post can transform, or so Draft can transform? -->
<!-- Technically it's so the Draft value can transform into another value,
which changes the state of Post-- I've tried to clarify. /Carol -->
<p>To consume the old state, the <code>request_review</code> method needs to take ownership
of the state value. This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code>
comes in: we call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code>
field and leave a <code>None</code> in its place, since Rust doesn’t let us have
unpopulated fields in structs. This lets us move the <code>state</code> value out of
<code>Post</code> rather than borrowing it. Then we’ll set the post’s <code>state</code> value to the
result of this operation.</p>
<p>We need to set <code>state</code> to <code>None</code> temporarily, rather than code like <code>self.state = self.state.request_review();</code> that would set the <code>state</code> field directly, to
get ownership of the <code>state</code> value. This ensures <code>Post</code> can’t use the old
<code>state</code> value after we’ve transformed it into a new state.</p>
<p>The <code>request_review</code> method on <code>Draft</code> needs to return a new, boxed instance of
a new <code>PendingReview</code> struct, which represents the state when a post is waiting
for a review. The <code>PendingReview</code> struct also implements the <code>request_review</code>
method, but doesn’t do any transformations. Rather, it returns itself, since
when we request a review on a post already in the <code>PendingReview</code> state, it
should stay in the <code>PendingReview</code> state.</p>
<p>Now we can start seeing the advantages of the state pattern: the
<code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value. Each
state is responsible for its own rules.</p>
<p>We’re going to leave the <code>content</code> method on <code>Post</code> as it is, returning an
empty string slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state as
well as the <code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code>
state. Listing 17-11 now works up until line 11!</p>
<a class="header" href="print.html#adding-the-approve-method-that-changes-the-behavior-of-content" id="adding-the-approve-method-that-changes-the-behavior-of-content"><h3>Adding the <code>approve</code> Method that Changes the Behavior of <code>content</code></h3></a>
<p>The <code>approve</code> method will be similar to the <code>request_review</code> method: it will
set <code>state</code> to the value that the current state says it should have when that
state is approved, shown in Listing 17-16.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         Box::new(PendingReview {})
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         self
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-16: Implementing the <code>approve</code> method on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We add the <code>approve</code> method to the <code>State</code> trait, and add a new struct that
implements <code>State</code>, the <code>Published</code> state.</p>
<p>Similar to <code>request_review</code>, if we call the <code>approve</code> method on a <code>Draft</code>, it
will have no effect since it will return <code>self</code>. When we call <code>approve</code> on
<code>PendingReview</code>, it returns a new, boxed instance of the <code>Published</code> struct.
The <code>Published</code> struct implements the <code>State</code> trait, and for both the
<code>request_review</code> method and the <code>approve</code> method, it returns itself, since the
post should stay in the <code>Published</code> state in those cases.</p>
<p>Now to update the <code>content</code> method on <code>Post</code>: if the state is <code>Published</code> we
want to return the value in the post’s <code>content</code> field; otherwise we want to
return an empty string slice, as shown in Listing 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait State {
#     fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
# }
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-17: Updating the <code>content</code> method on <code>Post</code> to
delegate to a <code>content</code> method on <code>State</code></span></p>
<p>Because the goal is to keep all these rules inside the structs that implement
<code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass the post
instance (that is, <code>self</code>) as an argument. Then we return the value that’s
returned from using the <code>content</code> method on the <code>state</code> value.</p>
<p>We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the
value inside the <code>Option</code> rather than ownership of it. Because <code>state</code> is an
<code>Option&lt;Box&lt;State&gt;&gt;</code>, calling <code>as_ref</code> returns an <code>Option&lt;&amp;Box&lt;State&gt;&gt;</code>. If we
didn’t call <code>as_ref</code>, we’d get an error because we can’t move <code>state</code> out of
the borrowed <code>&amp;self</code> of the function parameter.</p>
<p>We’re then calling the <code>unwrap</code> method, which we know will never panic, because
we know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code>
value when those methods are done. This is one of the cases we talked about in
Chapter 12 when we know that a <code>None</code> value is never possible, even though the
compiler isn’t able to understand that.</p>
<p>So then we have a <code>&amp;Box&lt;State&gt;</code>, and when we call the <code>content</code> on it, deref
coercion will take effect on the <code>&amp;</code> and the <code>Box</code> so that the <code>content</code> method
will ultimately be called on the type that implements the <code>State</code> trait.</p>
<p>That means we need to add <code>content</code> to the <code>State</code> trait definition, and that’s
where we’ll put the logic for what content to return depending on which state
we have, as shown in Listing 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String
# }
trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-18: Adding the <code>content</code> method to the <code>State</code>
trait</span></p>
<p>We add a default implementation for the <code>content</code> method that returns an empty
string slice. That means we don’t need to implement <code>content</code> on the <code>Draft</code>
and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code>
method and return the value in <code>post.content</code>.</p>
<p>Note that we need lifetime annotations on this method, like we discussed in
Chapter 10. We’re taking a reference to a <code>post</code> as an argument, and returning
a reference to part of that <code>post</code>, so the lifetime of the returned reference
is related to the lifetime of the <code>post</code> argument.</p>
<!-- Is this it finished, without the touch up we make to get rid of the empty
string? That's pretty awesome coding, maybe give it some ceremony here. Does
all of 17-11 now work? -->
<!-- Yep! Good point, so added! /Carol -->
<p>And we’re done-- all of Listing 17-11 now works! We’ve implemented the state
pattern with the rules of the blog post workflow. The logic around the rules
lives in the state objects rather than scattered throughout <code>Post</code>.</p>
<a class="header" href="print.html#tradeoffs-of-the-state-pattern" id="tradeoffs-of-the-state-pattern"><h3>Tradeoffs of the State Pattern</h3></a>
<p>We’ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on <code>Post</code> know nothing about the different kinds of
behavior. The way this code is organized, we only have to look in one place to
know the different ways a published post can behave: the implementation of the
<code>State</code> trait on the <code>Published</code> struct.</p>
<p>If we were to create an alternative implementation that didn’t use the state
pattern we might use <code>match</code> statements in the methods on <code>Post</code>, or even in
the <code>main</code> code that checks the state of the post and changes behavior in those
places instead. That would mean we’d have to look in a lot of places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those <code>match</code> statements
would need another arm.</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don’t
need <code>match</code> statements, and to add a new state we would only need to add a new
<code>struct</code> and implement the trait methods on that one struct.</p>
<p>This implementation is easy to extend to add more functionality. To see the
simplicity of maintaining code that uses this patterns, try out a few of these
suggestions:</p>
<ul>
<li>Allow users to add text content only when a post is in the <code>Draft</code> state</li>
<li>Add a <code>reject</code> method that changes the post’s state from <code>PendingReview</code> back
to <code>Draft</code></li>
<li>Require two calls to <code>approve</code> before the state can be changed to <code>Published</code></li>
</ul>
<p>One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between <code>PendingReview</code> and <code>Published</code>, such as <code>Scheduled</code>,
we would have to change the code in <code>PendingReview</code> to transition to
<code>Scheduled</code> instead. It would be less work if <code>PendingReview</code> wouldn’t need to
change with the addition of a new state, but that would mean switching to
another design pattern.</p>
<p>Another downside is that we find ourselves with a few bits of duplicated logic.
To eliminate this, we might try to make default implementations for the
<code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>,
but this would violate object safety, since the trait doesn’t know what the
concrete <code>self</code> will be exactly. We want to be able to use <code>State</code> as a trait
object, so we need its methods to be object safe.</p>
<p>The other duplication is the similar implementations of the <code>request_review</code>
and <code>approve</code> methods on <code>Post</code>. Both methods delegate to the implementation of
the same method on the value in the <code>state</code> field of <code>Option</code>, and set the new
value of the <code>state</code> field to the result. If we had a lot of methods on <code>Post</code>
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see Appendix D on macros).</p>
<p>By implementing this pattern exactly as it’s defined for object-oriented
languages, we’re not taking full advantage of Rust’s strengths as much as we
could. Let’s take a look at some changes we can make to this code that can make
invalid states and transitions into compile time errors.</p>
<a class="header" href="print.html#encoding-states-and-behavior-as-types" id="encoding-states-and-behavior-as-types"><h4>Encoding States and Behavior as Types</h4></a>
<p>We’re going to show how to rethink the state pattern to get a different set of
tradeoffs. Rather than encapsulating the states and transitions completely so
that outside code has no knowledge of them, we’re going to encode the states
into different types. Like this, Rust’s type checking system will make attempts
to use draft posts where only published posts are allowed into a compiler error.</p>
<p>Let’s consider the first part of <code>main</code> from Listing 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<p>We still enable the creation of new posts in the draft state using <code>Post::new</code>,
and the ability to add text to the post’s content. But instead of having a
<code>content</code> method on a draft post that returns an empty string, we’ll make it so
that draft posts don’t have the <code>content</code> method at all. That way, if we try to
get a draft post’s content, we’ll get a compiler error telling us the method
doesn’t exist. This will make it impossible for us to accidentally display
draft post content in production, since that code won’t even compile. Listing
17-19 shows the definition of a <code>Post</code> struct, a <code>DraftPost</code> struct, and
methods on each:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
       &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-19: A <code>Post</code> with a <code>content</code> method and a
<code>DraftPost</code> without a <code>content</code> method</span></p>
<p>Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that
stores the blog post text. The structs no longer have the <code>state</code> field since
we’re moving the encoding of the state to the types of the structs. <code>Post</code> will
represent a published post, and it has a <code>content</code> method that returns the
<code>content</code>.</p>
<p>We still have a <code>Post::new</code> function, but instead of returning an instance of
<code>Post</code>, it returns an instance of <code>DraftPost</code>. Because <code>content</code> is private,
and there aren’t any functions that return <code>Post</code>, it’s not possible to create
an instance of <code>Post</code> right now.</p>
<p><code>DraftPost</code> has an <code>add_text</code> method so we can add text to <code>content</code> as before,
but note that <code>DraftPost</code> does not have a <code>content</code> method defined! So now the
program ensures all posts start as draft posts, and draft posts don’t have
their content available for display. Any attempt to get around these
constraints will result in a compiler error.</p>
<a class="header" href="print.html#implementing-transitions-as-transformations-into-different-types" id="implementing-transitions-as-transformations-into-different-types"><h4>Implementing Transitions as Transformations into Different Types</h4></a>
<p>So how do we get a published post then? We want to enforce the rule that a
draft post has to be reviewed and approved before it can be published. A post
in the pending review state should still not display any content. Let’s
implement these constraints by adding another struct, <code>PendingReviewPost</code>,
defining the <code>request_review</code> method on <code>DraftPost</code> to return a
<code>PendingReviewPost</code>, and defining an <code>approve</code> method on <code>PendingReviewPost</code> to
return a <code>Post</code> as shown in Listing 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
# pub struct DraftPost {
#     content: String,
# }
#
impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-20: A <code>PendingReviewPost</code> that gets created by
calling <code>request_review</code> on <code>DraftPost</code>, and an <code>approve</code> method that turns a
<code>PendingReviewPost</code> into a published <code>Post</code></span></p>
<p>The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code>, thus
consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming
them into a <code>PendingReviewPost</code> and a published <code>Post</code>, respectively. This way,
we won’t have any <code>DraftPost</code> instances lingering around after we’ve called
<code>request_review</code> on them, and so forth. <code>PendingReviewPost</code> doesn’t have a
<code>content</code> method defined on it, so attempting to read its content results in a
compiler error, as with <code>DraftPost</code>. Because the only way to get a published
<code>Post</code> instance that does have a <code>content</code> method defined is to call the
<code>approve</code> method on a <code>PendingReviewPost</code>, and the only way to get a
<code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code>,
we’ve now encoded the blog post workflow into the type system.</p>
<p>This does mean we have to make some small changes to <code>main</code>. The
<code>request_review</code> and <code>approve</code> methods return new instances rather than
modifying the struct they’re called on, so we need to add more <code>let post =</code>
shadowing assignments to save the returned instances. We also can’t have the
assertions about the draft and pending review post’s contents being empty
strings, nor do we need them: we can’t compile code that tries to use the
content of posts in those states any longer. The updated code in <code>main</code> is
shown in Listing 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-21: Modifications to <code>main</code> to use the new
implementation of the blog post workflow</span></p>
<p>These changes we need to make to <code>main</code> to reassign <code>post</code> means this
implementation doesn’t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the <code>Post</code> implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as the content of an
unpublished post being displayed, will be discovered before they make it to
production.</p>
<p>Try the tasks suggested for additional requirements that we mentioned at the
start of this section on this code, to see how working with this version of the
code feels.</p>
<p>We’ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns like encoding state into the type system are
also available in Rust. These patterns have different tradeoffs. While you may
be very familiar with object-oriented patterns, rethinking the problem in order
to take advantage of Rust’s features can provide benefits like preventing some
bugs at compile-time. Object-oriented patterns won’t always be the best
solution in Rust, because of the features like ownership that object-oriented
languages don’t have.</p>
<a class="header" href="print.html#summary-12" id="summary-12"><h2>Summary</h2></a>
<p>No matter whether you think Rust is an object-oriented language or not after
reading this chapter, you’ve now seen that trait objects are a way to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. This flexibility can
be used to implement object-oriented patterns that can help with the
maintainability of your code. Rust also has other different features, like
ownership, that object-oriented languages don’t have. An object-oriented
pattern won’t always be the best way to take advantage of Rust’s strengths, but
is an available option.</p>
<p>Next, let’s look at another feature of Rust that enables lots of flexibility:
patterns. We’ve looked at them briefly throughout the book, but haven’t seen
everything they’re capable of yet. Let’s go!</p>
<a class="header" href="print.html#patterns-and-matching" id="patterns-and-matching"><h1>Patterns and Matching</h1></a>
<p>Patterns are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with <code>match</code>
expressions and other constructs gives you more control over the control flow
of a program. A pattern is made up of some combination of:</p>
<ul>
<li>literals</li>
<li>destructured arrays, enums, structs, or tuples</li>
<li>variables</li>
<li>wildcards</li>
<li>placeholders</li>
</ul>
<p>These pieces describe the shape of the data we’re working with, which we then
match against values to determine whether our program has the correct data to
continue running a particular bit of code.</p>
<!-- I think we need a concise description of what we use patterns for here,
what they provide the programmer. Hopefully you can see what I've trying to do,
above! But I think you'll agree it's not quite right, can you have a whack, try
to give the reader that explanation? -->
<!-- We tweaked the wording a bit, how's this? /Carol -->
<p>To use a pattern we compare it to some value. If the pattern matches our value,
we use the value parts in our code. Recall our <code>match</code> expressions from Chapter
6 that used patterns like a coin sorting machine. If the value fits the shape
of the pattern, we can use the named pieces. If it doesn’t, the code associated
with the pattern won’t run.</p>
<p>This chapter is a reference on all things related to patterns. We’ll cover the
valid places to use patterns, the difference between <em>refutable</em> and
<em>irrefutable</em> patterns, and the different kinds of pattern syntax that you
might see. By the end, you’ll see how to use patterns to create powerful and
clear code.</p>
<a class="header" href="print.html#all-the-places-patterns-may-be-used" id="all-the-places-patterns-may-be-used"><h2>All the Places Patterns May be Used</h2></a>
<p>Patterns pop up in a number of places in Rust, and you’ve been using them a lot
without realizing it! This section is a reference to all the places where
patterns are valid.</p>
<a class="header" href="print.html#match-arms" id="match-arms"><h3><code>match</code> Arms</h3></a>
<p>As we discussed in Chapter 6, patterns are used in the arms of <code>match</code>
expressions. Formally, <code>match</code> expressions are defined as the keyword <code>match</code>,
a value to match on, and one or more match arms that consist of a pattern and
an expression to run if the value matches that arm’s pattern:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p><code>match</code> expressions are required to be <em>exhaustive</em>, in the sense that all
possibilities for the value in the <code>match</code> expression must be accounted for.
One way to ensure you have every possibility covered is to have a catch-all
pattern for the last arm---for example, a variable name matching any value can
never fail and thus covers every case remaining.</p>
<p>There’s a particular pattern <code>_</code> that will match anything, but never binds to a
variable, and so is often used in the last match arm. This can be useful when
you want to ignore any value not specified, for example. We’ll cover this in
more detail later in this chapter.</p>
<a class="header" href="print.html#conditional-if-let-expressions" id="conditional-if-let-expressions"><h3>Conditional <code>if let</code> Expressions</h3></a>
<p>In Chapter 6 we discussed how <code>if let</code> expressions are used mainly as a shorter
way to write the equivalent of a <code>match</code> that only cares about matching one
case. Optionally,<code>if let</code> can have a corresponding <code>else</code> with code to run if
the pattern in the <code>if let</code> doesn’t match.</p>
<!-- Can you say up front why we'd use this, and not just a match? I've just
added something here, not sure if it's right -->
<!-- The first sentence says why-- it's a shorter way to write a `match` when
there's only one case we care about. Can you elaborate on why that's not clear
or up front? /Carol -->
<p>Listing 18-1 shows that it’s also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. This gives us more flexibility than a
<code>match</code> expression where we can only express one value to compare with the
patterns; the conditions in a series of <code>if let</code>/<code>else if</code>/<code>else if let</code> arms
aren’t required to have any relation to each other.</p>
<p>The code in Listing 18-1 shows a series of checks for a bunch of different
conditions that decide what the background color should be. For the purposes of
the example, we’ve created variables with hardcoded values that a real program
might get by asking the user.</p>
<p>If the user has specified a favorite color, that is used as the background
color. If today is Tuesday, the background color will be green. If the user has
specified their age as a string and we can parse it as a number successfully,
we’ll use either purple or orange depending on the value of the parsed number.
Finally, if none of these conditions apply, the background color will be blue:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-1: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>,
and <code>else</code></span></p>
<p>This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>We can see that <code>if let</code> can also introduce shadowed variables, in the same way
that <code>match</code> arms can: <code>if let Ok(age) = age</code> introduces a new shadowed <code>age</code>
variable that contains the value inside the <code>Ok</code> variant. This means we need to
place the <code>if age &gt; 30</code> condition within that block; we can’t combine these two
conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> because the shadowed <code>age</code>
we want to compare to 30 isn’t valid until the new scope starts with the curly
brace.</p>
<p>The downside of using <code>if let</code> expressions in this way is that exhaustiveness
is not checked by the compiler, whereas with <code>match</code> expressions it is. If we
left off the last <code>else</code> block and so missed handling some cases, the compiler
would not alert us of the possible logic bug.</p>
<!-- So what would happen, we'd just end up with a program that wasn't correct,
in the Rust sense? -->
<!-- Yes, we would have a logic bug. /Carol -->
<a class="header" href="print.html#while-let-conditional-loops" id="while-let-conditional-loops"><h3><code>while let</code> Conditional Loops</h3></a>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows
your <code>while</code> loop to run for as long as a pattern continues to match. The
example in Listing 18-2 shows a <code>while let</code> loop that uses a vector as a stack
and prints out the values in the vector in the opposite order they were pushed
in:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-2: Using a <code>while let</code> loop to print out
values for as long as <code>stack.pop()</code> returns <code>Some</code></span></p>
<!-- Some lovely simple, but edifying, examples in this chapter!-->
<p>This example will print 3, 2, then 1. The <code>pop</code> method takes the last element
out of the vector and returns <code>Some(value)</code>. If the vector is empty, it returns
<code>None</code>. The <code>while</code> loop will continue running the code in its block as long as
<code>pop</code> is returning <code>Some</code>. Once it returns <code>None</code>, the loop stops. We can use
<code>while let</code> to pop every element off our stack.</p>
<a class="header" href="print.html#for-loops" id="for-loops"><h3><code>for</code> Loops</h3></a>
<p>In Chapter 3 we mentioned that the <code>for</code> loop is the most common loop
construction in Rust code, but we haven’t yet discussed the pattern that <code>for</code>
takes. In a <code>for</code> loop, the pattern is the value that directly follows the
keyword <code>for</code>, so the <code>x</code> in <code>for x in y</code>.</p>
<!-- Can you check the line I added above? I think it'd help to point out the
pattern section of a for loop straight away -->
<!-- Yep, looks good! /Carol -->
<p>Listing 18-3 demonstrates how to use a pattern in a <code>for</code> loop to destructure,
or break apart, a tuple as part of the <code>for</code> loop:</p>
<!-- Liz: We've been using the word "destructure" throughout the book in
chapters 3, 4, 5, and 16. In chapter 3, in the "Grouping Values into Tuples"
section, we said "This is called *destructuring*, because it breaks the single
tuple into three parts.". So I don't think we need to define destructure again
in this chapter, but I've added a small parenthetical here in case the reader
forgets. /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-3: Using a pattern in a <code>for</code> loop to
destructure a tuple</span></p>
<p>This will print:</p>
<pre><code class="language-text">a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>We use the <code>enumerate</code> method to adapt an iterator to produce a value and that
value’s index in the iterator, placed into a tuple. The first call to
<code>enumerate</code> produces the tuple <code>(0, 'a')</code>. When this value is matched to the
pattern <code>(index, value)</code>, <code>index</code> will be 0 and <code>value</code> will be 'a', printing our
first line of output.</p>
<a class="header" href="print.html#let-statements" id="let-statements"><h3><code>let</code> Statements</h3></a>
<p>Before this chapter, we’d only explicitly discussed using patterns with <code>match</code>
and <code>if let</code>, but in fact we’ve used patterns in other places too, including
<code>let</code> statements. For example, consider this straightforward variable
assignment with <code>let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>We’ve done this hundreds of times throughout this book, and though you may not
have realized it, you were using patterns! A <code>let</code> statement looks like this,
more formally:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the <code>PATTERN</code> slot, the
variable name is just a particularly humble form of pattern. We compare the
expression against the pattern, and assign any names we find. So for our <code>let x = 5;</code> example, <code>x</code> is a pattern that says “bind what matches here to the
variable <code>x</code>.” And since the name <code>x</code> is the whole pattern, this pattern
effectively means “bind everything to the variable <code>x</code>, whatever the value is.”</p>
<p>To see the pattern matching aspect of <code>let</code> a bit more clearly, consider
Listing 18-4 where we’re using a pattern with <code>let</code> to destructure a tuple:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);
#}</code></pre></pre>
<p><span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span></p>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code>
to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, so will
bind <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple
pattern as nesting three individual variable patterns inside of it.</p>
<!-- so if we have a pattern of four elements, say (w, x, y, z), but only three
values, would the values would not bind at all? -->
<!-- Either too many or too few elements in the pattern is a type error. I've
added a small example below to illustrate. /Carol -->
<p>If the number of elements in the pattern don’t match the number of elements in
the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure into two variables a
tuple with three elements that won’t work:</p>
<pre><code class="language-rust ignore">let (x, y) = (1, 2, 3);
</code></pre>
<p><span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don’t match the number of elements in the tuple</span></p>
<p>Attempting to compile this code gives us this type error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`
</code></pre>
<p>If we wanted to ignore one or more of the values in the tuple, we could use <code>_</code>
or <code>..</code> as we’ll see in the “Ignoring Values in a Pattern” section. If the
problem was that we had too many variables in the pattern, the solution would
be to make the types match by removing variables so that the number of
variables is equal to the number of elements in the tuple.</p>
<a class="header" href="print.html#function-parameters" id="function-parameters"><h3>Function Parameters</h3></a>
<p>Function parameters can also be patterns. The code in Listing 18-6, declaring a
function named <code>foo</code> that takes one parameter named <code>x</code> of type <code>i32</code>, should
by now look familiar:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) {
    // code goes here
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span></p>
<p>The <code>x</code> part is a pattern! Like we did with <code>let</code>, we could match a tuple in a
function’s arguments to the pattern. Listing 18-7 splits apart the values in a
tuple as we pass it to a function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span></p>
<p>This will print <code>Current location: (3, 5)</code>. The values <code>&amp;(3, 5)</code> match the
pattern <code>&amp;(x, y)</code>, so <code>x</code> gets the value 3, and <code>y</code> gets the value 5.</p>
<p>We can use patterns in closure parameter lists in the same way, too, because
closures are similar to functions, as we discussed in Chapter 13.</p>
<p>We’ve seen several ways of using patterns now, but patterns do not work the
same in every place we can use them; in some places, the patterns must be
<em>irrefutable</em>, meaning they must match any value provided. In other
circumstances, they may be refutable. Let’s discuss that next.</p>
<a class="header" href="print.html#refutability-whether-a-pattern-might-fail-to-match" id="refutability-whether-a-pattern-might-fail-to-match"><h2>Refutability: Whether a Pattern Might Fail to Match</h2></a>
<p>Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are said to be <em>irrefutable</em>. An example would be
<code>x</code> in the statement <code>let x = 5;</code> because <code>x</code> matches anything and so cannot
fail to match. Patterns that may fail to match for some possible value are said
to be <em>refutable</em>. An example of this would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code>; if the value in the <code>a_value</code> variable is <code>None</code> rather
than <code>Some</code>, then the <code>Some(x)</code> pattern would not match.</p>
<p><code>let</code> statements, function parameters, and <code>for</code> loops can only accept
irrefutable patterns, because the program cannot do anything
meaningful with values that don’t match. The <code>if let</code> and <code>while let</code>
expressions are restricted to only accept refutable patterns, because by
definition they’re intended to handle possible failure---the functionality of a
conditional is in its ability to perform differently upon success and failure.</p>
<p>In general, you shouldn’t have to worry about the distinction between refutable
and irrefutable patterns, but you do need to be familiar with the concept of
refutability so you can respond when you see it in an error message. In those
cases, you’ll need to change either the pattern or the construct you’re using
the pattern with, depending on your intentions for the behavior of the code.</p>
<p>Let’s look at an example of what happens if we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. In Listing 18-8, we
have a <code>let</code> statement, but for the pattern we’ve specified <code>Some(x)</code>, a
refutable pattern. As you might expect, this will error:</p>
<pre><code class="language-rust ignore">let Some(x) = some_option_value;
</code></pre>
<p><span class="caption">Listing 18-8: Attempting to use a refutable pattern with
<code>let</code></span></p>
<p>If <code>some_option_value</code> was a <code>None</code> value, it would fail to match the pattern
<code>Some(x)</code>, meaning the pattern is refutable. The <code>let</code> statement, however, can
only accept an irrefutable patterns because there’s nothing valid the code
could do with a <code>None</code> value. At compile time, Rust will complain that we’ve
tried to use a refutable pattern where an irrefutable pattern is required:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; &lt;anon&gt;:3:5
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<p>We didn’t cover (and couldn’t cover!) every valid value with the pattern
<code>Some(x)</code>, so Rust will rightfully complain.</p>
<p>To fix the case where we have a refutable pattern in a place where an
irrefutable pattern is needed, we can change the code that uses the pattern:
instead of using <code>let</code>, we can use <code>if let</code>. That way, if the pattern doesn’t
match, the code will just skip the code in the curly brackets, giving it a way
to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_option_value: Option&lt;i32&gt; = None;
if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-9: Using <code>if let</code> and a block with refutable
patterns instead of <code>let</code></span></p>
<!-- Whats the first commented out line here, I had though this was copied from
8-7 but it isn't quite the same -->
<!-- Sorry, that line has to do with the way we test our code examples and I
missed removing it before sending this chapter to you. Sorry about that! /Carol
-->
<p>We’ve given the code an out! This code is perfectly valid, though does now of
course mean we cannot use an irrefutable pattern without receiving an error. If
we give <code>if let</code> a pattern that will always match, such as <code>x</code> as shown in
Listing 18-10, it will error:</p>
<pre><code class="language-rust ignore">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<p><span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with <code>if let</code></span></p>
<p>Rust complains that it doesn’t make sense to use <code>if let</code> with an irrefutable
pattern:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<p>For this reason, match arms must use refutable patterns, except for the last
arm that should match any remaining values with an irrefutable pattern. Using
an irrefutable pattern in a <code>match</code> with only one arm is allowed, but isn’t
particularly useful and could be replaced with a simpler <code>let</code> statement.</p>
<p>Now that we’ve discussed where patterns can be used and the difference between
refutable and irrefutable patterns, let’s go over all the syntax we can use to
create patterns.</p>
<a class="header" href="print.html#all-the-pattern-syntax" id="all-the-pattern-syntax"><h2>All the Pattern Syntax</h2></a>
<p>We’ve seen examples of many different kinds of patterns throughout the book, so
we’ll gather all the syntax valid in patterns in one place here, and why you
might want to use each of them.</p>
<!-- We don't always go over why we might want to use them for each section
here, presumably because it's clear why it's useful. I might recommend you do
just add a line to each, since we've promised it, and just to really hammer the
point home. Definitely keep it short and sweet though, where it's pretty clear.
-->
<a class="header" href="print.html#matching-literals" id="matching-literals"><h3>Matching Literals</h3></a>
<p>As we saw in Chapter 6, you can match patterns against literals directly. This
following code gives some examples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>This prints <code>one</code> since the value in <code>x</code> is 1. This is useful when you want to
take some action if you get a concrete value in particular.</p>
<a class="header" href="print.html#matching-named-variables" id="matching-named-variables"><h3>Matching Named Variables</h3></a>
<!-- I found this next bit a little tougher to follow, I've tried to clarify in
this opening paragraph, connect it all up, can you please check it? -->
<!-- Yep! Looks good! /Carol -->
<p>Named variables are irrefutable patterns that match any value, which we have
used many times before. There is a complication, however, when used in <code>match</code>
expressions. Because <code>match</code> starts a new scope, variables declared as part of
a pattern inside the <code>match</code> expression will shadow those with the same name
outside the <code>match</code> construct---as is the case with all variables. In Listing
18-11, we declare a variable named <code>x</code> with the value <code>Some(5)</code> and a variable
<code>y</code> with the value <code>10</code>. We then create a <code>match</code> expression on the value <code>x</code>.
Take a look at the patterns in the match arms and <code>println!</code> at the end, and
try to figure out what will be printed before running this code or reading
further:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-11: A <code>match</code> statement with an arm that
introduces a shadowed variable <code>y</code></span></p>
<p>Let’s walk through what happens when the <code>match</code> statement runs. The pattern in
the first match arm does not match the defined value of <code>x</code>, so we continue.</p>
<p>The pattern in the second match arm introduces a new variable name <code>y</code> that
will match any value inside a <code>Some</code> value. Because we’re in a new scope inside
the <code>match</code> expression, this is a new variable, and not the <code>y</code> we declared at
the beginning with the value 10. This new <code>y</code> binding will match any value
inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore this <code>y</code> binds to the
inner value of the <code>Some</code> in <code>x</code>. That value is 5, and so the expression for
that arm executes and prints <code>Matched, y = 5</code>.</p>
<!-- Below -- We haven't fully introduced the underscore yet, is there anything
else we could use for that final arm? -->
<!-- We have *used* the underscore briefly before, though-- we actually
introduced the underscore in chapter 6. There really isn't anything else that
we can put that will still have this example illustrating what we want to
illustrate. /Carol -->
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first
two arms would not have matched, so we would have matched to the underscore. We
did not introduce the <code>x</code> variable in the pattern of that arm, so the <code>x</code> in
the expression is still the outer <code>x</code> that has not been shadowed. In this
hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>Once the <code>match</code> expression is over, its scope ends, and so does the scope of
the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and
<code>y</code>, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We’ll be talking about match guards later in this
section.</p>
<a class="header" href="print.html#multiple-patterns" id="multiple-patterns"><h3>Multiple Patterns</h3></a>
<p>In <code>match</code> expressions you can match multiple patterns using the <code>|</code> syntax,
which means <em>or</em>. For example, the following code matches the value of <code>x</code>
against the match arms, the first of which has an <em>or</em> option, meaning if the
value of <code>x</code> matches either of the values in that arm, it will run:</p>
<!-- I've tried to flesh this out a bit, can you check? -->
<!-- Yep, it's fine! /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>This code will print <code>one or two</code>.</p>
<!-- Is there a corresponding "and" operator? Is that worth tacking on here? -->
<!-- No, there is not-- how could one value match, say, 1 AND 2? Does it make
sense why there isn't an "and" operator? /Carol -->
<a class="header" href="print.html#matching-ranges-of-values-with-" id="matching-ranges-of-values-with-"><h3>Matching Ranges of Values with <code>...</code></h3></a>
<p>The <code>...</code> syntax allows you to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range,
that arm will execute:</p>
<!-- Above--this seems like it's true, that the range allows you to match to
just one of the values? If so, can you say how this differs to using the or
operator? -->
<!-- I'm not sure what you mean by "match to just one of the values". `...`
matches any value between the two specified endpoints, which I thought would be
clear by the text below the code, and I changed "just one of" to "any of the
values within" above, and mentioned what the equivalent "or" pattern would look
like below. Does that clear it up? /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match. This is more convenient
than using the <code>|</code> operator to express the same idea; instead of <code>1 ... 5</code> we
would have to specify <code>1 | 2 | 3 | 4 | 5</code> using <code>|</code>. Specifying a range instead
is much shorter, especially if we wanted to match, say, any number between 1
and 1,000!</p>
<p>Ranges are only allowed with numeric values or <code>char</code> values, because the
compiler checks that the range isn’t empty at compile time. <code>char</code> and numeric
values are the only types that Rust knows how to tell if a range is empty or
not.</p>
<!-- why, because they are the only types with inherent order? -->
<!-- Nope, I've added the explanation /Carol -->
<p>Here’s an example using ranges of <code>char</code> values:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 'c';

match x {
    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>Rust can tell that <code>c</code> is within the first pattern’s range, and this will print
<code>early ASCII letter</code>.</p>
<a class="header" href="print.html#destructuring-to-break-apart-values" id="destructuring-to-break-apart-values"><h3>Destructuring to Break Apart Values</h3></a>
<!-- I moved the definition of destructure earlier in the chapter, to when we
first use it -->
<!-- See my comment there; we first use destructure in chapter 3 /Carol -->
<p>We can also use patterns to destructure structs, enums, tuples, and references
in order to use different parts of these values. Let’s go through each of those!</p>
<!-- Above -- I think that's what we say later, that, we're skipping enums, but
please delete if not! You'll see my note where it comes up later -->
<!-- We actually had someone point out a detail we could cover regarding enums,
so we've added an enums section. /Carol -->
<a class="header" href="print.html#destructuring-structs" id="destructuring-structs"><h4>Destructuring Structs</h4></a>
<p>Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can
break apart using a pattern with a <code>let</code> statement:</p>
<p><span class="filename">Filename: src/main.rs</p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Listing 18-12: Destructuring a struct’s fields into
separate variables</span></p>
<!-- I'm not sure I follow which part of this is the shorthand, what is it
shorthand for, and which syntax here counts as the shorthand? Can you slow this
down, talk it through a little more. Is the point of this section that we have
a shorthand for destructuring, or that we are able to destructure these items
with patterns at all? -->
<!-- I've reorganized this section to start with the non-shorthand instead, is
this clearer? /Carol -->
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code>
and <code>y</code> fields of the <code>p</code> variable.</p>
<p>This example shows that the names of the variable names in the pattern don’t
have to match the field names of the struct, but it’s common to want the
variable names to match the field names to make it easier to remember which
variables came from which fields. Because having variable names match the
fields is common, and because writing <code>let Point { x: x, y: y } = p;</code> contains
a lot of duplication, there’s a shorthand for patterns that match struct
fields: you only need to list the name of the struct field, and the variables
created from the pattern will have the same names. Listing 18-13 shows code
that behaves in the same way as the code in Listing 18-12, but the variables
created in the <code>let</code> pattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span></p>
<p>This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> of the
<code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the values
from the <code>p</code> struct.</p>
<p>We can also destructure with literal values as part of the struct pattern
rather than creating variables for all of the fields. This allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.</p>
<p>Listing 18-14 shows a <code>match</code> statement that separates <code>Point</code> values into
three cases: points that lie directly on the <code>x</code> axis (which is true when <code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither:</p>
<!-- I'm not sure what you mean by "inner parts of a value" -- that we aren't
matching a whole value but part of it? -->
<!-- I've reworded, is this version clearer? /Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span></p>
<p>The first arm will match any point that lies on the <code>x</code> axis by specifying that
the <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still
creates an <code>x</code> variable that we can use in the code for this arm. Similarly,
the second arm matches any point on the <code>y</code> axis by specifying that the <code>x</code>
field matches if its value is <code>0</code>, and creates a variable <code>y</code> for the value of
the <code>y</code> field. The third arm doesn’t specify any literals, so it matches any
other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code>
containing a 0, so this will print <code>On the y axis at 7</code>.</p>
<a class="header" href="print.html#destructuring-enums" id="destructuring-enums"><h4>Destructuring Enums</h4></a>
<p>We’ve destructured enums before in this book, like in Listing 6-5 in Chapter 6
when we destructured an <code>Option&lt;i32&gt;</code>. One detail we haven’t mentioned
explicitly is that the pattern to destructure an enum should correspond to the
way the data stored within the enum is defined. For example, let’s take the
<code>Message</code> enum from Listing 6-2 and write a <code>match</code> with patterns that will
destructure each inner value in Listing 18-15:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        },
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span></p>
<p>This code will print <code>Change the color to red 0, green 160, and blue 255</code>. Try
changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p>For enum variants without any data like <code>Message::Quit</code>, we can’t destructure
the value any further. We can only match on the literal <code>Message::Quit</code> value,
and there are no variables in that pattern.</p>
<p>For struct-like enum variants such as <code>Message::Move</code>, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so that we break
apart the pieces to use in the code for this arm. Here we use the shorthand
form as shown in Listing 18-13.</p>
<p>For tuple-like enum variants like <code>Message::Write</code>, that holds a tuple with one
element, and <code>Message::ChangeColor</code> that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we’re
matching.</p>
<a class="header" href="print.html#destructuring-references" id="destructuring-references"><h4>Destructuring References</h4></a>
<p>When the value we’re matching to our pattern contains a reference, we need to
destructure the reference from the value, which we can do by specifying a
<code>&amp;</code> in the pattern. This lets us get a variable holding the value that the
reference points to rather than getting a variable that holds the reference.</p>
<!-- What does it mean, to separate the reference and the value, precisely? So
that we specify Rust use the value in place of the reference? And what does &
here do, tell Rust to follow the reference to the value itself, rather than
work on the reference?-->
<!-- Yes, pretty much. I've tried rewording, is this clearer? /Carol -->
<p>This is especially useful in closures where we have iterators that iterate over
references, but we want to use the values in the closure rather than the
references.</p>
<p>The example in Listing 18-16 iterates over references to <code>Point</code> instances in a
vector, and destructures both the reference and the struct so we can perform
calculations on the <code>x</code> and <code>y</code> values easily:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];

let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point { x, y }| x * x + y * y)
    .sum();
#}</code></pre></pre>
<p><span class="caption">Listing 18-16: Destructuring a reference to a struct into
the struct field values</span></p>
<!-- and what do we actually get, instead of the error? -->
<!-- Added explanation text below /Carol -->
<p>This code results in the value 135 in the variable <code>sum_of_squares</code>, which is
the result from squaring the <code>x</code> value and the <code>y</code> value, adding those
together, and then adding the result for each <code>Point</code> in the <code>points</code> vector to
get one number.</p>
<p>If we had not included the <code>&amp;</code> in <code>&amp;Point { x, y }</code> we’d get a type mismatch
error, because <code>iter</code> would then iterate over references to the items in the
vector rather than the values themselves. The error would look like this:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point { x, y }| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<p>This tells us that Rust was expecting our closure to match <code>&amp;Point</code>, but we
tried to match directly to a <code>Point</code> value, and not a reference to a <code>Point</code>.</p>
<a class="header" href="print.html#destructuring-structs-and-tuples" id="destructuring-structs-and-tuples"><h4>Destructuring Structs and Tuples</h4></a>
<p>We can mix, match, and nest destructuring patterns in even more complex way.
Here’s an example of a complicated destructure, where we nest structs and
tuples inside a tuple, and destructure all the primitive values out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
#}</code></pre></pre>
<p>This lets us break complex types into their component parts so that we can use
the values we’re interested in separately.</p>
<!-- Can you round up the destructuring section here before we move on. For
this bit, maybe say explicitly what this would be useful for -->
<!-- Done /Carol -->
<p>Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.</p>
<a class="header" href="print.html#ignoring-values-in-a-pattern" id="ignoring-values-in-a-pattern"><h3>Ignoring Values in a Pattern</h3></a>
<p>We’ve seen that it’s sometimes useful to ignore values in a pattern, such as in
the last arm of a <code>match</code> to give us a catch-all that doesn’t actually do
anything, but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the <code>_</code>
pattern (which we’ve seen), using the <code>_</code> pattern within another pattern, using
a name that starts with an underscore, or using <code>..</code> to ignore remaining parts
of a value. Let’s explore how and why to do each of these.</p>
<a class="header" href="print.html#ignoring-an-entire-value-with-_" id="ignoring-an-entire-value-with-_"><h4>Ignoring an Entire Value with <code>_</code></h4></a>
<p>We’ve used the underscore as a wildcard pattern that will match any value but
not bind to the value. While the underscore pattern is especially useful as the
last arm in a <code>match</code> expression, we can use it in any pattern, including
function parameters, as shown in Listing 18-17:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Listing 18-17: Using <code>_</code> in a function signature</span></p>
<!-- What is this doing exactly, can you help the reader out here? Are we
letting the function run without a parameter at all? I'm not sure the purpose
clear enough at the moment -->
<!-- Done /Carol -->
<p>This code will completely ignore the value passed as the first argument, 3, and
will print out <code>This code only uses the y parameter: 4</code>. In most cases when you
no longer need a particular function parameter, you would change the signature
so it doesn’t include the unused parameter.</p>
<p>Ignoring a function parameter can be especially useful in some cases, such as
when implementing a trait, when you need a certain type signature but the
function body in your implementation doesn’t need one of the parameters. The
compiler will then not warn about unused function parameters, as it would if we
used a name instead.</p>
<a class="header" href="print.html#ignoring-parts-of-a-value-with-a-nested-_" id="ignoring-parts-of-a-value-with-a-nested-_"><h4>Ignoring Parts of a Value with a Nested <code>_</code></h4></a>
<!-- When would we want to do this? -->
<!-- Done, moved the explanation up and made the example have a bit more
motivation /Carol -->
<p>We can also use <code>_</code> inside of another pattern to ignore just part of a value,
when we only want to test for part of a value but have no use for the other
parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for giving a setting a value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting, but can unset the setting and can give the setting a value if it is
currently unset.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
#}</code></pre></pre>
<p><span class="caption">Listing 18-18: Using an underscore within patterns that
match <code>Some</code> variants when we don’t need to use the value inside the
<code>Some</code></span></p>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then
<code>setting is Some(5)</code>. In the first match arm, we don’t need to match on or use
the values inside either <code>Some</code> variant; the important part we need to test for
is the case when both <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code>
variant. In that case, we want to print out why we’re not changing
<code>setting_value</code>, and we don’t change it.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are
<code>None</code>), which is expressed by the <code>_</code> pattern in the second arm, we do want to
allow <code>new_setting_value</code> to become <code>setting_value</code>.</p>
<!-- So when we need to match but don't actually need the value, is that what
we're saying? -->
<!-- Yes /Carol -->
<p>We can also use underscores in multiple places within one pattern to ignore
particular values, as shown in Listing 18-19 where we’re ignoring the second
and fourth values in a tuple of five items:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span></p>
<p>This will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be
ignored.</p>
<a class="header" href="print.html#ignoring-an-unused-variable-by-starting-its-name-with-an-underscore" id="ignoring-an-unused-variable-by-starting-its-name-with-an-underscore"><h4>Ignoring an Unused Variable by Starting its Name with an Underscore</h4></a>
<p>If you create a variable but don’t use it anywhere, Rust will usually issue a
warning, since that could be a bug. Sometimes, though, it’s useful to create a
variable you won’t use yet, like if you’re prototyping or just starting a
project. In this situation you’ll want to tell Rust not to warn you about the
unused variable, which you can do by starting the name of the variable with an
underscore. In Listing 18-20 we create two unused variables, but when we run
this code we should only get a warning about one of them.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Listing 18-20: Starting a variable name with an
underscore in order to not get unused variable warnings</span></p>
<p>Here we get a warning about not using the variable <code>y</code>, but not about not using
the variable preceded by the underscore.</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name
that starts with an underscore. Something like <code>_x</code> still binds the value to
the variable, whereas <code>_</code> doesn’t bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.</p>
<pre><code class="language-rust ignore">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which may take ownership of the value</span></p>
<p>We’ll receive an error because the <code>s</code> value will still be moved into <code>_s</code>,
which prevents us from using <code>s</code> again. Using the underscore by itself,
however, doesn’t ever bind to the value. Listing 18-22 will compile without any
errors since <code>s</code> does not get moved into <code>_</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
#}</code></pre></pre>
<p><span class="caption">Listing 18-22: Using underscore does not bind the
value</span></p>
<p>This works just fine; because we never bind <code>s</code> to anything, it isn’t moved.</p>
<a class="header" href="print.html#ignoring-remaining-parts-of-a-value-with-" id="ignoring-remaining-parts-of-a-value-with-"><h4>Ignoring Remaining Parts of a Value with <code>..</code></h4></a>
<p>With values that have many parts, we can use the <code>..</code> syntax to use only a few
parts and ignore the rest, while avoiding having to list underscores for each
ignored value. The <code>..</code> pattern will ignore any parts of a value that we
haven’t explicitly matched in the rest of the pattern. In Listing 18-23, we
have a <code>Point</code> struct that holds a coordinate in three dimensional space. In
the <code>match</code> expression, we want to operate only on the <code>x</code> coordinate and
ignore the values in the <code>y</code> and <code>z</code> fields:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-23: Ignoring all fields of a <code>Point</code> except
for <code>x</code> by using <code>..</code></span></p>
<p>We list the <code>x</code> value, and then just include the <code>..</code> pattern. This is quicker
than having to list out <code>y: _</code> and <code>z: _</code>, particularly when working with
structs that have lots of fields, in situations where only one or two fields
are relevant.</p>
<p><code>..</code> will expand to as many values as it needs to be. Listing 18-24 shows a use
of <code>..</code> with a tuple:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span></p>
<p>Here, we have the first and last value matched with <code>first</code> and <code>last</code>. The
<code>..</code> will match and ignore everything in the middle.</p>
<p>Using <code>..</code> must be unambiguous, however. If it is not clear which values are
intended for matching, and which to be ignored, Rust will error. Listing 18-25
shows an example of using <code>..</code> ambiguously that will not compile due to this
ambiguity:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Listing 18-25: An attempt to use <code>..</code> in a way that is
ambiguous</span></p>
<p>If we compile this example, we get this error:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>It’s not possible for Rust to determine how many values in the tuple to ignore
before matching a value with <code>second</code>, and then how many further values to
ignore after that. This code could mean that we intend to ignore 2, bind
<code>second</code> to 4, then ignore 8, 16, and 32; or we could mean that we want to
ignore 2 and 4, bind <code>second</code> to 8, then ignore 16 and 32, and so forth. The
variable name <code>second</code> doesn’t mean anything special to Rust, so we get a
compiler error since using <code>..</code> in two places like this is ambiguous.</p>
<a class="header" href="print.html#ref-and-ref-mut-to-create-references-in-patterns" id="ref-and-ref-mut-to-create-references-in-patterns"><h3><code>ref</code> and <code>ref mut</code> to Create References in Patterns</h3></a>
<p>Here we’ll look at using <code>ref</code> to make references so ownership of the values
isn’t moved to variables in the pattern. Usually, when you match against a
pattern, the variables introduced by the pattern are bound to a value. Rust’s
ownership rules mean the value will be moved into the <code>match</code>, or wherever
you’re using the pattern. Listing 18-26 shows an example of a <code>match</code> that has
a pattern with a variable, and then another usage of the entire value after the
<code>match</code>. This will fail to compile because ownership of part of the
<code>robot_name</code> value is transferred to the <code>name</code> variable in the pattern of the
first <code>match</code> arm:</p>
<!-- Can you lay out what is supposed to happen with this code, that doesn't
work? -->
<!-- Done /Carol -->
<pre><code class="language-rust ignore">let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<p><span class="caption">Listing 18-26: Creating a variable in a match arm pattern
takes ownership of the value</span></p>
<p>This example will fail because the value inside <code>Some</code> in <code>robot_name</code> is moved
to within the <code>match</code> when <code>name</code> binds to that value. Because ownership of
part of <code>robot_name</code> has been moved to <code>name</code>, we can no longer use
<code>robot_name</code> in the <code>println!</code> after the <code>match</code> because <code>robot_name</code> no longer
has ownership.</p>
<!-- Above -- why will that make it fail, because the bind is then invalid? -->
<!-- Yes, I've clarified a bit /Carol -->
<!--Below -- Is this then the solution, introducing &? I assume so, because we
don’t have & in the example above, but the connection isn't clear -->
<!-- No, the solution is introducing `ref`. I've clarified /Carol -->
<p>In order to fix this code, we want to have the <code>Some(name)</code> pattern borrow that
part of <code>robot_name</code> rather than taking ownership. Outside of patterns, we’ve
seen that the way to borrow a value is to create a reference using <code>&amp;</code>, so you
may think the solution is changing <code>Some(name)</code> to <code>Some(&amp;name)</code>.</p>
<p>However, we saw in the “Destructuring to Break Apart Values” section that <code>&amp;</code>
in patterns does not <em>create</em> a reference, it <em>matches</em> an existing reference
in the value. Because <code>&amp;</code> already has that meaning in patterns, we can’t use
<code>&amp;</code> to create a reference in a pattern.</p>
<p>Instead, to create a reference in a pattern, we do this by using the <code>ref</code>
keyword before the new variable, as shown in Listing 18-27:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">Listing 18-27: Creating a reference so that a pattern
variable does not take ownership of a value</span></p>
<p>This example will compile because the value in the <code>Some</code> variant in
<code>robot_name</code> is not moved into the <code>match</code>; the <code>match</code> only took a reference
to the data in <code>robot_name</code> rather than moving it.</p>
<p>To create a mutable reference in order to be able to mutate a value matched in
a pattern, use <code>ref mut</code> instead of <code>&amp;mut</code> for the same reason that we use
<code>ref</code> instead of <code>&amp;</code>: <code>&amp;mut</code> in patterns is for matching existing mutable
references, not creating new ones. Listing 18-28 shows an example of a pattern
creating a mutable reference:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">Listing 18-28: Creating a mutable reference to a value as
part of a pattern using <code>ref mut</code></span></p>
<p>This example will compile and print <code>robot_name is: Some(&quot;Another name&quot;)</code>.
Because <code>name</code> is a mutable reference, we need to dereference within the match
arm code using the <code>*</code> operator in order to be able to mutate the value.</p>
<a class="header" href="print.html#extra-conditionals-with-match-guards" id="extra-conditionals-with-match-guards"><h3>Extra Conditionals with Match Guards</h3></a>
<!-- Can you give a full definition of a match guard here, and what we use it
for, before covering how to do it? -->
<p>A <em>match guard</em> is an additional <code>if</code> condition specified after the pattern in
a <code>match</code> arm that also must match if the pattern matches in order for that arm
to be chosen. Match guards are useful for expressing more complex ideas than a
pattern alone allows.</p>
<p>The condition can use variables created in the pattern. Listing 18-29 shows a
<code>match</code> where the first arm has the pattern <code>Some(x)</code> and then also has a match
guard of <code>if x &lt; 5</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-29: Adding a match guard to a pattern</span></p>
<p>This example will print <code>less than five: 4</code>. When <code>num</code> is compared to the
pattern in the first arm, it matches since <code>Some(4)</code> matches <code>Some(x)</code>. Then
the match guard checks to see if the value in <code>x</code> is less than 5, and because 4
is less than 5, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(10)</code> instead, the match guard in the first arm would
have been false since 10 is not less than 5. Rust would then go to the second
arm, which would match because the second arm does not have a match guard and
therefore matches any <code>Some</code> variant.</p>
<p>There’s no way to express the <code>if x &lt; 5</code> condition within a pattern, so the
match guard has given us the ability to express this logic.</p>
<!-- I think we need this spelled out, can you say what it is the match guard
is doing here? I've had a guess above, but I think it needs your review! -->
<!-- Reviewed and tweaked a bit! /Carol -->
<p>In Listing 18-11, we mentioned that we could use match guards to solve our
pattern shadowing problem, where a new variable was created inside the pattern
in the <code>match</code> expression instead of using the variable outside the <code>match</code>.
That new variable meant we couldn’t test against the value that the outer
variable had. Listing 18-30 shows how we can use a match guard to fix this:</p>
<!-- Can you check this above -- I've tried to paraphrase the final paragraph
from that section. -->
<!-- Checked and reworded a bit /Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-30: Using a match guard to test for equality
with an outer variable</span></p>
<p>This will now print <code>Default case, x = Some(5)</code>. The pattern in the second
match arm is now not introducing a new variable <code>y</code> that would shadow the outer
<code>y</code>, meaning we can use the outer <code>y</code> in the match guard. Instead of specifying
the pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify
<code>Some(n)</code>. This creates a new variable <code>n</code> that does not shadow anything
because there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>In the match guard, <code>if n == y</code>, this is not a pattern and therefore does not
introduce new variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new shadowed
<code>y</code>, and we can express the idea that we’re looking for a value that has the
same value as the outer <code>y</code> by comparing <code>n</code> to <code>y</code>.</p>
<!-- Why is this one not introducing a new variable y but 18-10 was? Instead we
create a new variable n and then compare it to the outer y, is that it? In
which case, I'm not understanding how we get n from destructuring x, can you
lay this out?-->
<!-- I've elaborated a bit, does this clear it up? /Carol -->
<p>You can also use the or operator <code>|</code> in a match guard to specify multiple
patterns, and the match guard condition will apply to all of the patterns.
Listing 18-31 shows the precedence of combining a match guard with a pattern
that uses <code>|</code>. The important part of this example is that the <code>if y</code> match
guard applies to 4, 5, <em>and</em> 6, even though it might look like <code>if y</code> only
applies to 6:</p>
<!-- What's the match condition actually doing here, with y having a value of
`false`? Can you let us know how that's being applied to all the values in that
match arm? -->
<!-- The point of the example here is to illustrate operator precedence, that
this code might look like it's saying `4 | 5 | (6 if y)` but it's actually
saying `(4 | 5 | 6) if y`. I've tried to elaborate above and below, does that
make sense now? /Carol -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-31: Combining multiple patterns with a match
guard</span></p>
<p>The match condition states that the arm only matches if the value of <code>x</code> is
equal to 4, 5, or 6 <em>and</em> if <code>y</code> is <code>true</code>. What happens when this code runs is
that the pattern of the first arm matches because <code>x</code> is 4, but the match guard
<code>if y</code> is false, so the first arm is not chosen. The code moves on to the
second arm, which does match, and this program prints <code>no</code>.</p>
<!-- Is this what we mean, if 4 or 5 or 6 being equal to x is false, run the
first arm? And so, because it's applying that to all of the values (including
4), the second arm is run and not the first? -->
<!-- It seems like `if y` was confusing, I've tried to spell it out a bit more.
Does this make sense now? /Carol -->
<p>This is because the <code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code>,
and not only to the last value <code>6</code>. In other words, the precedence of a match
guard in relation to a pattern behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>We can tell this from what happened when we ran the code: if the match guard
was only applied to the final value in the list of values specified using the
<code>|</code> operator, the arm would have matched and the program would have printed
<code>yes</code>.</p>
<a class="header" href="print.html#-bindings" id="-bindings"><h3><code>@</code> Bindings</h3></a>
<!-- Below - use @ to what, can you say explicitly what it does. Also what the
name of the operator is? -->
<!-- I don't think it has a name other than "the at operator". And we tried to
say what it does-- it creates a variable at the same time as letting us test
it, I've tried rewording a bit but I'm not sure why that wasn't explicit
enough, can you clarify if this still doesn't make sense? /Carol -->
<p>The at operator, <code>@</code>, lets us create a variable that holds a value at the same
time we’re testing that value to see if it matches a pattern. Listing 18-32
shows an example where we want to test that a <code>Message::Hello</code> <code>id</code> field is
within the range <code>3...7</code> but also be able to bind the value to the variable
<code>id_variable</code> so that we can use it in the code associated with the arm. We
could have named <code>id_variable</code> <code>id</code>, the same as the field, but for the
purposes of this example we’ve chosen to give it a different name:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3...7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10...12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-32: Using <code>@</code> to bind to a value in a pattern
while also testing it</span></p>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3...7</code>, we’re capturing whatever value matched the range
while also testing that the value matched the range pattern.</p>
<p>In the second arm where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12 but the
code that goes with that pattern doesn’t know which one and isn’t able to use
the value from the <code>id</code> field, because we haven’t saved the <code>id</code> value in a
variable.</p>
<p>In the last arm where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named <code>id</code> because
we’ve used the struct field shorthand syntax. We haven’t applied any test to
the value in the <code>id</code> field in this arm, though, like the first two arms did:
any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<a class="header" href="print.html#summary-13" id="summary-13"><h2>Summary</h2></a>
<p>Patterns are a useful feature of Rust that help distinguish between different
kinds of data. When used in <code>match</code> statements, Rust makes sure your patterns
cover every possible value, or your program will not compile. Patterns in <code>let</code>
statements and function parameters make those constructs more powerful,
enabling the destructuring of values into smaller parts at the same time as
assigning to variables. We can create simple or complex patterns to suit our
needs.</p>
<p>Now, for the penultimate chapter of the book, let’s take a look at some
advanced parts of a variety of Rust’s features.</p>
<!-- This is a long chapter! I was trying to consider whether to split it, and
if so where --- the only solution I could come up with was to split it into the
five main subjects: Unsafe, Lifetimes, Traits, Types, and Functions and
Closures. However, I'm not convinced that's ideal, so I thought we might
include a ToC at the top of this chapter in print so the reader can use it as a
reference when they come across something they can't figure out. What do you
think? -->
<!-- A ToC to make this chapter more easily used as a reference sounds okay,
would it be redundant with the ToC at the beginning of the whole book though?
Or would this ToC be more detailed than the beginning of the book? Would it
just be adding page numbers to the bullet points after the first paragraph?
We're curious about implementation :) /Carol -->
<a class="header" href="print.html#advanced-features" id="advanced-features"><h1>Advanced Features</h1></a>
<p>We’ve come a long way! By now, you’ve learned 99% of the things you’ll need to
know when writing Rust. Before we do one more project in Chapter 20, let’s talk
about a few things you may run into that last 1% of the time. Feel free to use
this chapter as a reference for when you run into something unknown in the
wild; the features you’ll learn to use here are useful in very specific
situations. We don’t want to leave these features out, but you won’t find
yourself reaching for them often.</p>
<p>In this chapter, we’re going to cover:</p>
<ul>
<li>Unsafe Rust: for when you need to opt out of some of Rust’s guarantees and
make yourself responsible for upholding the guarantees instead</li>
<li>Advanced Lifetimes: syntax for complex lifetime situations</li>
<li>Advanced Traits: Associated Types, default type parameters, fully qualified
syntax, supertraits, and the newtype pattern in relation to traits</li>
<li>Advanced Types: some more about the newtype pattern, type aliases, the
“never” type, and dynamically sized types</li>
<li>Advanced Functions and Closures: function pointers and returning closures</li>
</ul>
<p>It’s a panoply of Rust features with something for everyone! Let’s dive in!</p>
<a class="header" href="print.html#unsafe-rust" id="unsafe-rust"><h2>Unsafe Rust</h2></a>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hiding inside of
it that does not enforce these memory safety guarantees: unsafe Rust. This
works just like regular Rust, but gives you extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler is trying to determine if code upholds the guarantees or not, it’s
better for it to reject some programs that are valid than accept some programs
that are invalid. That inevitably means there are some times when your code
might be okay, but Rust thinks it’s not! In these cases, you can use unsafe
code to tell the compiler, “trust me, I know what I’m doing.” The downside is
that you’re on your own; if you get unsafe code wrong, problems due to memory
unsafety, like null pointer dereferencing, can occur.</p>
<p>There’s another reason Rust has an unsafe alter ego: the underlying hardware of
computers is inherently not safe. If Rust didn’t let you do unsafe operations,
there would be some tasks that you simply could not do. Rust needs to allow you
to do low-level systems programming like directly interacting with your
operating system, or even writing your own operating system! That’s one of the
goals of the language. Let’s see what you can do with unsafe Rust, and how to
do it.</p>
<a class="header" href="print.html#unsafe-superpowers" id="unsafe-superpowers"><h3>Unsafe Superpowers</h3></a>
<p>To switch into unsafe Rust we use the <code>unsafe</code> keyword, and then we can start a
new block that holds the unsafe code. There are four actions that you can take
in unsafe Rust that you can’t in safe Rust that we call “unsafe superpowers.”
Those superpowers are the ability to:</p>
<ol>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
</ol>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these four features that are then not checked by the compiler for memory
safety. You still get some degree of safety inside of an unsafe block!</p>
<p>Furthermore, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that you as the programmer will ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>People are fallible, and mistakes will happen, but by requiring these four
unsafe operations to be inside blocks annotated with <code>unsafe</code>, you’ll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small and you’ll thank yourself later when you go to
investigate memory bugs.</p>
<p>To isolate unsafe code as much as possible, it’s a good idea to enclose unsafe
code within a safe abstraction and provide a safe API, which we’ll be
discussing once we get into unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. This technique prevents uses of <code>unsafe</code> from leaking out into all the
places that you or your users might want to make use of the functionality
implemented with <code>unsafe</code> code, because using a safe abstraction is safe.</p>
<p>Let’s talk about each of the four unsafe superpowers in turn, and along the way
we’ll look at some abstractions that provide a safe interface to unsafe code.</p>
<a class="header" href="print.html#dereferencing-a-raw-pointer" id="dereferencing-a-raw-pointer"><h3>Dereferencing a Raw Pointer</h3></a>
<p>Way back in Chapter 4, in the “Dangling References” section, we covered that
the compiler ensures references are always valid. Unsafe Rust has two new types
similar to references called <em>raw pointers</em>. Just like with references, raw
pointers can be immutable or mutable, written as <code>*const T</code> and <code>*mut T</code>,
respectively. The asterisk isn’t the dereference operator; it’s part of the
type name. In the context of raw pointers, “immutable” means that the pointer
can’t be directly assigned to after being dereferenced.</p>
<p>Different from references and smart pointers, keep in mind that raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules and have both immutable and
mutable pointers, or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic clean-up</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you are able to make the
tradeoff of giving up guaranteed safety to gain performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<!-- Can you say here what benefits these provide, over smart pointers and
references, and using the aspects in these bullets? -->
<!-- There aren't really benefits to each of these individually. These are the
caveats that the reader needs to be aware of when working with raw pointers.
You'd choose to use raw pointers to do something that you can't do with smart
pointers or references. I've tried to clarify above /Carol -->
<p>Listing 19-1 shows how to create both an immutable and a mutable raw pointer
from references.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
#}</code></pre></pre>
<p><span class="caption">Listing 19-1: Creating raw pointers from references</span></p>
<!--So we create a raw pointer using the dereference operator? Is that the same
operator? Is it worth touching on why? -->
<!-- It's not the dereference operator, the * is part of the type. Tried to
clarify above where the types are introduced /Carol -->
<p>Notice we don’t include the <code>unsafe</code> keyword here---you can <em>create</em> raw
pointers in safe code, you just can’t <em>dereference</em> raw pointers outside of an
unsafe block, as we’ll see in a bit.</p>
<p>We’ve created raw pointers by using <code>as</code> to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references that are guaranteed to be valid, we can know that
these particular raw pointers are valid, but we can’t make that assumption
about just any raw pointer.</p>
<p>Next we’ll create a raw pointer whose validity we can’t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there may be data at that
address or there may not, the compiler might optimize the code so that there is
no memory access, or your program might segfault. There’s not usually a good
reason to be writing code like this, but it is possible:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let address = 0x012345usize;
let r = address as *const i32;
#}</code></pre></pre>
<p><span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span></p>
<p>Remember that we said you can create raw pointers in safe code, but you can’t
<em>dereference</em> raw pointers and read the data being pointed to. We’ll do so now
using the dereference operator, <code>*</code>, on a raw pointer, which does require an
<code>unsafe</code> block, as shown in Listing 19-3:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-3: Dereferencing raw pointers within an
<code>unsafe</code> block</span></p>
<p>Creating a pointer can’t do any harm; it’s only when accessing the value that
it points at that you might end up dealing with an invalid value.</p>
<p>Note also that in Listing 19-1 and 19-3 we created <code>*const i32</code> and <code>*mut i32</code>
raw pointers that both pointed to the same memory location, that of <code>num</code>. If
instead we’d tried to create an immutable and a mutable reference to <code>num</code>,
this would not have compiled because Rust’s ownership rules don’t allow a
mutable reference at the same time as any immutable references. With raw
pointers, we are able to create a mutable pointer and an immutable pointer to
the same location, and change data through the mutable pointer, potentially
creating a data race. Be careful!</p>
<p>With all of these dangers, why would we ever use raw pointers? One major use
case is when interfacing with C code, as we’ll see in the next section on
unsafe functions. Another case is when building up safe abstractions that the
borrow checker doesn’t understand. Let’s introduce unsafe functions then look
at an example of a safe abstraction that uses unsafe code.</p>
<a class="header" href="print.html#calling-an-unsafe-function-or-method" id="calling-an-unsafe-function-or-method"><h3>Calling an Unsafe Function or Method</h3></a>
<p>The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra <code>unsafe</code> out front. That <code>unsafe</code> indicates the
function has requirements we as programmers need to uphold when we call this
function, because Rust can’t guarantee we’ve met these requirements. By calling
an unsafe function within an <code>unsafe</code> block, we are saying that we’ve read this
function’s documentations and take responsibility for upholding the function’s
contracts ourselves.</p>
<!-- Above -- so what is the difference, when and why would we ever use the
unsafe function? -->
<!-- Tried to clarify /Carol -->
<p>Here’s an unsafe function named <code>dangerous</code> that doesn’t do anything in its
body:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
#}</code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>By inserting the <code>unsafe</code> block around our call to <code>dangerous</code>, we’re asserting
to Rust that we’ve read the documentation for this function, we understand how
to use it properly, and we’ve verified that everything is correct.</p>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
<code>unsafe</code> block.</p>
<a class="header" href="print.html#creating-a-safe-abstraction-over-unsafe-code" id="creating-a-safe-abstraction-over-unsafe-code"><h4>Creating a Safe Abstraction Over Unsafe Code</h4></a>
<p>Just because a function contains unsafe code doesn’t mean the whole function
needs to be marked as unsafe. In fact, wrapping unsafe code in a safe function
is a common abstraction. As an example, let’s check out a function from the
standard library, <code>split_at_mut</code>, that requires some unsafe code and explore
how we might implement it. This safe method is defined on mutable slices: it
takes one slice and makes it into two by splitting the slice at the index given
as an argument. Using <code>split_at_mut</code> is demonstrated in Listing 19-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
#}</code></pre></pre>
<p><span class="caption">Listing 19-4: Using the safe <code>split_at_mut</code>
function</span></p>
<p>This function can’t be implemented using only safe Rust. An attempt might look
something like Listing 19-5, which will not compile. For simplicity, we’re
implementing <code>split_at_mut</code> as a function rather than a method, and only for
slices of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">Listing 19-5: An attempted implementation of
<code>split_at_mut</code> using only safe Rust</span></p>
<p>This function first gets the total length of the slice, then asserts that the
index given as a parameter is within the slice by checking that it’s less than
or equal to the length. The assertion means that if we pass an index that’s
greater than the index to split the slice at, the function will panic before it
attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index, and another from <code>mid</code> to the end of the
slice.</p>
<p>If we try to compile this, we’ll get an error:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because our two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know something is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-6: Using unsafe code in the implementation of
the <code>split_at_mut</code> function</span></p>
<p>Recall from the “Slices” section in Chapter 4 that slices are a pointer to some
data and the length of the slice. We use the <code>len</code> method to get the length of
a slice, and the <code>as_mut_ptr</code> method to access the raw pointer of a slice. In
this case, because we have a mutable slice to <code>i32</code> values, <code>as_mut_ptr</code>
returns a raw pointer with the type <code>*mut i32</code>, which we’ve stored in the
variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length and creates a slice. We use this function to create a slice that
starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>offset</code> method on
<code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at <code>mid</code>, and
we create a slice using that pointer and the remaining number of items after
<code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>offset</code> method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. We therefore had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>offset</code> to be allowed to call them. We can
tell, by looking at the code and by adding the assertion that <code>mid</code> must be
less than or equal to <code>len</code>, that all the raw pointers used within the <code>unsafe</code>
block will be valid pointers to data within the slice. This is an acceptable
and appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way because it creates only valid pointers from the
data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice ten thousand items long:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
#}</code></pre></pre>
<p><span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span></p>
<p>We don’t own the memory at this arbitrary location, and there’s no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>slice</code> as if it was a valid slice would result in undefined behavior.</p>
<a class="header" href="print.html#using-extern-functions-to-call-external-code" id="using-extern-functions-to-call-external-code"><h4>Using <code>extern</code> Functions to Call External Code</h4></a>
<p>Sometimes, your Rust code may need to interact with code written in another
language. For this, Rust has a keyword, <code>extern</code>, that facilitates the creation
and use of a <em>Foreign Function Interface</em> (FFI). A Foreign Function Interface
is a way for a programming language to define functions and enable a different
(foreign) programming language to call those functions.</p>
<!-- Can you give a definition for FFI? -->
<!-- Done /Carol -->
<p>Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
always unsafe to call from Rust code, because other languages don`t enforce
Rust's rules and guarantees and Rust can't check them, so responsibility falls
on the programmer to ensure safety:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-8: Declaring and calling an <code>extern</code> function
defined in another language</span></p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external
functions from another language we want to be able to call. The <code>&quot;C&quot;</code> part
defines which <em>application binary interface</em> (ABI) the external function
uses---the ABI defines how to call the function at the assembly level. The
<code>&quot;C&quot;</code> ABI is the most common, and follows the C programming language’s ABI.</p>
<!-- PROD: START BOX -->
<a class="header" href="print.html#calling-rust-functions-from-other-languages" id="calling-rust-functions-from-other-languages"><h5>Calling Rust Functions from Other Languages</h5></a>
<p>You can also use <code>extern</code> to create an interface that allows other languages to
call Rust functions. Instead of an <code>extern</code> block, we add the <code>extern</code> keyword
and specify the ABI to use just before the <code>fn</code> keyword. We also need to add a
<code>#[no_mangle]</code> annotation to tell the Rust compiler not to mangle the name of
this function. Mangling is when a compiler changes the name we’ve given a
function to a different name that contains more information for other parts of
the compilation process to consume but is less human readable. Every
programming language compiler mangles names slightly differently, so for a Rust
function to be nameable from other languages, we have to disable the Rust
compiler’s name mangling.</p>
<!-- have we discussed mangling before this? It doesn't ring a bell with me,
though it may have been in an early chapter that I forgot --- if not could you
give a quick explanation here? -->
<!-- I've tried, without going into too much detail! /Carol -->
<p>In this example we make the <code>call_from_c</code> function accessible from C code, once
it’s compiled to a shared library and linked from C:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
#}</code></pre></pre>
<p>This usage of <code>extern</code> does not require <code>unsafe</code>.</p>
<!-- PROD: END BOX -->
<a class="header" href="print.html#accessing-or-modifying-a-mutable-static-variable" id="accessing-or-modifying-a-mutable-static-variable"><h3>Accessing or Modifying a Mutable Static Variable</h3></a>
<p>We’ve managed to go this entire book without talking about <em>global variables</em>,
which Rust does support, but which can be problematic with Rust’s ownership
rules. If you have two threads accessing the same mutable global variable, it
can cause a data race.</p>
<p>Global variables are called <em>static</em> variables in Rust. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Listing 19-9: Defining and using an immutable static
variable</span></p>
<p><code>static</code> variables are similar to constants, which we discussed in the
“Differences Between Variables and Constants” section in Chapter 3. The names
of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention, and we <em>must</em>
annotate the variable’s type, which is <code>&amp;'static str</code> in this case. Static
variables may only store references with the <code>'static</code> lifetime, which means
the Rust compiler can figure out the lifetime by itself and we don’t need to
annotate it explicitly. Accessing an immutable static variable is safe.</p>
<p>Constants and immutable static variables may seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they are used.</p>
<p>Another difference between constants and static variables is that static
variables can be mutable. Both accessing and modifying mutable static variables
is <em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span></p>
<p>Just like with regular variables, we specify mutability using the <code>mut</code>
keyword. Any code that reads or writes from <code>COUNTER</code> must be within an
<code>unsafe</code> block. This code compiles and prints <code>COUNTER: 3</code> as we would expect
because it’s single threaded. Having multiple threads access <code>COUNTER</code> would
likely result in data races.</p>
<p>With mutable data that’s globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16, so the compiler checks
that data accessed from different threads is done safely.</p>
<a class="header" href="print.html#implementing-an-unsafe-trait" id="implementing-an-unsafe-trait"><h3>Implementing an Unsafe Trait</h3></a>
<p>Finally, the last action that only works with <code>unsafe</code> is implementing an
unsafe trait. A trait is unsafe when at least one of its methods has some
invariant that the compiler can’t verify. We can declare that a trait is
<code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code>, and then implementation
of the trait must be marked as <code>unsafe</code> too, as shown in Listing 19-11:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span></p>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits from the “Extensible
Concurrency with the <code>Sync</code> and <code>Send</code> Traits” section of Chapter 16, and that
the compiler implements these automatically if our types are composed entirely
of <code>Send</code> and <code>Sync</code> types. If we implement a type that contains something
that’s not <code>Send</code> or <code>Sync</code>, such as raw pointers, and we want to mark that
type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust can’t verify that our type
upholds the guarantees that it can be safely sent across threads or accessed
from multiple threads, so we need to do those checks ourselves and indicate as
such with <code>unsafe</code>.</p>
<a class="header" href="print.html#when-to-use-unsafe-code" id="when-to-use-unsafe-code"><h3>When to Use Unsafe Code</h3></a>
<p>Using <code>unsafe</code> to take one of these four actions isn’t wrong or even frowned
upon, but it is trickier to get <code>unsafe</code> code correct because the compiler isn’t
able to help uphold memory safety. When you have a reason to use <code>unsafe</code> code,
it is possible to do so, and having the explicit <code>unsafe</code> annotation makes it
easier to track down the source of problems if they occur.</p>
<a class="header" href="print.html#advanced-lifetimes" id="advanced-lifetimes"><h2>Advanced Lifetimes</h2></a>
<p>Back in Chapter 10 in the “Validating References with Lifetimes” section, we
learned how to annotate references with lifetime parameters to tell Rust how
lifetimes of different references relate. We saw how every reference has a
lifetime but, most of the time, Rust will let you elide lifetimes. Here we’ll
look at three advanced features of lifetimes that we haven’t covered yet:</p>
<ul>
<li>Lifetime subtyping, a way to ensure that one lifetime outlives another
lifetime</li>
<li>Lifetime bounds, to specify a lifetime for a reference to a generic type</li>
<li>Trait object lifetimes, how they’re inferred, and when they need to be
specified</li>
</ul>
<!-- maybe add a small summary of each here? That would let us launch straight
into examples in the next section -->
<!-- I've switched to bullets and added a small summary /Carol -->
<a class="header" href="print.html#lifetime-subtyping-ensures-one-lifetime-outlives-another" id="lifetime-subtyping-ensures-one-lifetime-outlives-another"><h3>Lifetime Subtyping Ensures One Lifetime Outlives Another</h3></a>
<p>Lifetime subtyping is a way to specify that one lifetime should outlive another
lifetime. To explore lifetime subtyping, imagine we want to write a parser.
We’ll have a structure called <code>Context</code> that holds a reference to the string
we’re parsing. We’ll write a parser that will parse this string and return
success or failure. The parser will need to borrow the context to do the
parsing. Implementing this would look like the code in Listing 19-12, except
this code doesn’t have the required lifetime annotations so it won’t compile:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<p><span class="caption">Listing 19-12: Defining a parser without lifetime
annotations</span></p>
<p>Compiling the code results in errors saying that Rust expected lifetime
parameters on the string slice in <code>Context</code> and the reference to a <code>Context</code> in
<code>Parser</code>.</p>
<!-- What will the compile time error be here? I think it'd be worth showing
that to the reader -->
<!-- The errors just say "expected lifetime parameter", they're pretty boring.
We've shown error messages like that before so I've explained in words instead.
/Carol -->
<p>For simplicity’s sake, our <code>parse</code> function returns a <code>Result&lt;(), &amp;str&gt;</code>. That
is, it will do nothing on success, and on failure will return the part of the
string slice that didn’t parse correctly. A real implementation would have more
error information than that, and would actually return something when parsing
succeeds, but we’ll leave those off because they aren’t relevant to the
lifetimes part of this example.</p>
<p>To keep this code simple, we’re not going to actually write any parsing logic.
It’s very likely that somewhere in parsing logic we’d handle invalid input by
returning an error that references the part of the input that’s invalid, and
this reference is what makes the code example interesting with regards to
lifetimes. So we’re going to pretend that the logic of our parser is that the
input is invalid after the first byte. Note that this code may panic if the
first byte is not on a valid character boundary; again, we’re simplifying the
example in order to concentrate on the lifetimes involved.</p>
<!-- why do we want to always error after the first byte? -->
<!-- For simplicity of the example to avoid cluttering up the code with actual
parsing logic, which isn't the point. I've explained a bit more above /Carol -->
<p>To get this code compiling, we need to fill in the lifetime parameters for the
string slice in <code>Context</code> and the reference to the <code>Context</code> in <code>Parser</code>. The
most straightforward way to do this is to use the same lifetime everywhere, as
shown in Listing 19-13:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-13: Annotating all references in <code>Context</code> and
<code>Parser</code> with the same lifetime parameter</span></p>
<p>This compiles fine, and tells Rust that a <code>Parser</code> holds a reference to a
<code>Context</code> with lifetime <code>'a</code>, and that <code>Context</code> holds a string slice that also
lives as long as the reference to the <code>Context</code> in <code>Parser</code>. Rust’s compiler
error message said lifetime parameters were required for these references, and
we have now added lifetime parameters.</p>
<!-- can you let the reader know they should be taking away from this previous
example? I'm not totally clear on why adding lifetimes here saved the code -->
<!-- Done -->
<p>Next, in Listing 19-14, let’s add a function that takes an instance of
<code>Context</code>, uses a <code>Parser</code> to parse that context, and returns what <code>parse</code>
returns. This won’t quite work:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-14: An attempt to add a <code>parse_context</code>
function that takes a <code>Context</code> and uses a <code>Parser</code></span></p>
<p>We get two quite verbose errors when we try to compile the code with the
addition of the <code>parse_context</code> function:</p>
<pre><code class="language-text">error[E0597]: borrowed value does not live long enough
  --&gt; src/lib.rs:14:5
   |
14 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
15 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^

error[E0597]: `context` does not live long enough
  --&gt; src/lib.rs:14:24
   |
14 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
15 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^
</code></pre>
<p>These errors are saying that both the <code>Parser</code> instance that’s created and the
<code>context</code> parameter live only from when the <code>Parser</code> is created until the end
of the <code>parse_context</code> function, but they both need to live for the entire
lifetime of the function.</p>
<p>In other words, <code>Parser</code> and <code>context</code> need to <em>outlive</em> the entire function
and be valid before the function starts as well as after it ends in order for
all the references in this code to always be valid. Both the <code>Parser</code> we’re
creating and the <code>context</code> parameter go out of scope at the end of the
function, though (because <code>parse_context</code> takes ownership of <code>context</code>).</p>
<!-- Oh interesting, why do they need to outlive the function, simply to
absolutely ensure they will live for as long as the function? -->
<!-- Yes, which is what I think we've said in the first sentence of the
previous paragraph. Is there something that's unclear? /Carol -->
<p>To figure out why we’re getting these errors, let’s look at the definitions in
Listing 19-13 again, specifically the references in the signature of the
<code>parse</code> method:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<!-- What exactly is it the reader should be looking at in this signature? -->
<!-- Added above /Carol -->
<p>Remember the elision rules? If we annotate the lifetimes of the references
rather than eliding, the signature would be:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<p>That is, the error part of the return value of <code>parse</code> has a lifetime that is
tied to the lifetime of the <code>Parser</code> instance (that of <code>&amp;self</code> in the <code>parse</code>
method signature). That makes sense: the returned string slice references the
string slice in the <code>Context</code> instance held by the <code>Parser</code>, and the definition
of the <code>Parser</code> struct specifies that the lifetime of the reference to
<code>Context</code> and the lifetime of the string slice that <code>Context</code> holds should be
the same.</p>
<p>The problem is that the <code>parse_context</code> function returns the value returned
from <code>parse</code>, so the lifetime of the return value of <code>parse_context</code> is tied to
the lifetime of the <code>Parser</code> as well. But the <code>Parser</code> instance created in the
<code>parse_context</code> function won’t live past the end of the function (it’s
temporary), and <code>context</code> will go out of scope at the end of the function
(<code>parse_context</code> takes ownership of it).</p>
<p>Rust thinks we’re trying to return a reference to a value that goes out of
scope at the end of the function, because we annotated all the lifetimes with
the same lifetime parameter. That told Rust the lifetime of the string slice
that <code>Context</code> holds is the same as that of the lifetime of the reference to
<code>Context</code> that <code>Parser</code> holds.</p>
<p>The <code>parse_context</code> function can’t see that within the <code>parse</code> function, the
string slice returned will outlive both <code>Context</code> and <code>Parser</code>, and that the
reference <code>parse_context</code> returns refers to the string slice, not to <code>Context</code>
or <code>Parser</code>.</p>
<p>By knowing what the implementation of <code>parse</code> does, we know that the only
reason the return value of <code>parse</code> is tied to the <code>Parser</code> is because it’s
referencing the <code>Parser</code>’s <code>Context</code>, which is referencing the string slice, so
it’s really the lifetime of the string slice that <code>parse_context</code> needs to care
about. We need a way to tell Rust that the string slice in <code>Context</code> and the
reference to the <code>Context</code> in <code>Parser</code> have different lifetimes and that the
return value of <code>parse_context</code> is tied to the lifetime of the string slice in
<code>Context</code>.</p>
<p>First we’ll try giving <code>Parser</code> and <code>Context</code> different lifetime parameters as
shown in Listing 19-15. We’ll use <code>'s</code> and <code>'c</code> as lifetime parameter names to
be clear about which lifetime goes with the string slice in <code>Context</code> and which
goes with the reference to <code>Context</code> in <code>Parser</code>. Note that this won’t
completely fix the problem, but it’s a start and we’ll look at why this isn’t
sufficient when we try to compile.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-15: Specifying different lifetime parameters
for the references to the string slice and to <code>Context</code></span></p>
<p>We’ve annotated the lifetimes of the references in all the same places that we
annotated them in Listing 19-13, but used different parameters depending on
whether the reference goes with the string slice or with <code>Context</code>. We’ve also
added an annotation to the string slice part of the return value of <code>parse</code> to
indicate that it goes with the lifetime of the string slice in <code>Context</code>.</p>
<p>The following is the error we get now when we try to compile:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/lib.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<p>Rust doesn’t know of any relationship between <code>'c</code> and <code>'s</code>. In order to be
valid, the referenced data in <code>Context</code> with lifetime <code>'s</code> needs to be
constrained, to guarantee that it lives longer than the reference with lifetime
<code>'c</code>. If <code>'s</code> is not longer than <code>'c</code>, the reference to <code>Context</code> might not be
valid.</p>
<p>Which gets us to the point of this section: the Rust feature <em>lifetime
subtyping</em> is a way to specify that one lifetime parameter lives at least as
long as another one. In the angle brackets where we declare lifetime
parameters, we can declare a lifetime <code>'a</code> as usual, and declare a lifetime
<code>'b</code> that lives at least as long as <code>'a</code> by declaring <code>'b</code> with the syntax <code>'b: 'a</code>.</p>
<p>In our definition of <code>Parser</code>, in order to say that <code>'s</code> (the lifetime of the
string slice) is guaranteed to live at least as long as <code>'c</code> (the lifetime of
the reference to <code>Context</code>), we change the lifetime declarations to look like
this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Context&lt;'a&gt;(&amp;'a str);
#
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
#}</code></pre></pre>
<p>Now, the reference to <code>Context</code> in the <code>Parser</code> and the reference to the string
slice in the <code>Context</code> have different lifetimes, and we’ve ensured that the
lifetime of the string slice is longer than the reference to the <code>Context</code>.</p>
<p>That was a very long-winded example, but as we mentioned at the start of this
chapter, these features are pretty niche. You won’t often need this syntax, but
it can come up in situations like this one, where you need to refer to
something you have a reference to.</p>
<a class="header" href="print.html#lifetime-bounds-on-references-to-generic-types" id="lifetime-bounds-on-references-to-generic-types"><h3>Lifetime Bounds on References to Generic Types</h3></a>
<p>In the “Trait Bounds” section of Chapter 10, we discussed using trait bounds on
generic types. We can also add lifetime parameters as constraints on generic
types, and these are called <em>lifetime bounds</em>. Lifetime bounds help Rust verify
that references in generic types won’t outlive the data they’re referencing.</p>
<!-- Can you say up front why/when we use these? -->
<!-- Done -->
<p>For an example, consider a type that is a wrapper over references. Recall the
<code>RefCell&lt;T&gt;</code> type from the “<code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern”
section of Chapter 15: its <code>borrow</code> and <code>borrow_mut</code> methods return the types
<code>Ref</code> and <code>RefMut</code>, respectively. These types are wrappers over references that
keep track of the borrowing rules at runtime. The definition of the <code>Ref</code>
struct is shown in Listing 19-16, without lifetime bounds for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Ref&lt;'a, T&gt;(&amp;'a T);
</code></pre>
<p><span class="caption">Listing 19-16: Defining a struct to wrap a reference to a
generic type; without lifetime bounds to start</span></p>
<p>Without explicitly constraining the lifetime <code>'a</code> in relation to the generic
parameter <code>T</code>, Rust will error because it doesn’t know how long the generic
type <code>T</code> will live:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p>Because <code>T</code> can be any type, <code>T</code> could itself be a reference or a type that
holds one or more references, each of which could have their own lifetimes.
Rust can’t be sure <code>T</code> will live as long as <code>'a</code>.</p>
<p>Fortunately, that error gave us helpful advice on how to specify the lifetime
bound in this case:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points at
</code></pre>
<p>Listing 19-17 shows how to apply this advice by specifying the lifetime bound
when we declare the generic type <code>T</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
#}</code></pre></pre>
<p><span class="caption">Listing 19-17: Adding lifetime bounds on <code>T</code> to specify
that any references in <code>T</code> live at least as long as <code>'a</code></span></p>
<p>This code now compiles because the <code>T: 'a</code> syntax specifies that <code>T</code> can be any
type, but if it contains any references, the references must live at least as
long as <code>'a</code>.</p>
<p>We could solve this in a different way, shown in the definition of a
<code>StaticRef</code> struct in Listing 19-18, by adding the <code>'static</code> lifetime bound on
<code>T</code>. This means if <code>T</code> contains any references, they must have the <code>'static</code>
lifetime:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
#}</code></pre></pre>
<p><span class="caption">Listing 19-18: Adding a <code>'static</code> lifetime bound to <code>T</code>
to constrain <code>T</code> to types that have only <code>'static</code> references or no
references</span></p>
<p>Because <code>'static</code> means the reference must live as long as the entire program,
a type that contains no references meets the criteria of all references living
as long as the entire program (because there are no references). For the borrow
checker concerned about references living long enough, there’s no real
distinction between a type that has no references and a type that has
references that live forever; both of them are the same for the purpose of
determining whether or not a reference has a shorter lifetime than what it
refers to.</p>
<a class="header" href="print.html#inference-of-trait-object-lifetimes" id="inference-of-trait-object-lifetimes"><h3>Inference of Trait Object Lifetimes</h3></a>
<p>In Chapter 17 in the “Using Trait Objects that Allow for Values of Different
Types” section, we discussed trait objects, consisting of a trait behind a
reference, that allow us to use dynamic dispatch. We haven’t yet discussed what
happens if the type implementing the trait in the trait object has a lifetime
of its own. Consider Listing 19-19, where we have a trait <code>Red</code> and a struct
<code>Ball</code>. <code>Ball</code> holds a reference (and thus has a lifetime parameter) and also
implements trait <code>Red</code>. We want to use an instance of <code>Ball</code> as the trait
object <code>Box&lt;Red&gt;</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Red { }

struct Ball&lt;'a&gt; {
    diameter: &amp;'a i32,
}

impl&lt;'a&gt; Red for Ball&lt;'a&gt; { }

fn main() {
    let num = 5;

    let obj = Box::new(Ball { diameter: &amp;num }) as Box&lt;Red&gt;;
}
</code></pre></pre>
<p><span class="caption">Listing 19-19: Using a type that has a lifetime parameter
with a trait object</span></p>
<p>This code compiles without any errors, even though we haven’t said anything
explicit about the lifetimes involved in <code>obj</code>. This works because there are
rules having to do with lifetimes and trait objects:</p>
<ul>
<li>The default lifetime of a trait object is <code>'static</code>.</li>
<li>With <code>&amp;'a Trait</code> or <code>&amp;'a mut Trait</code>, the default lifetime is <code>'a</code>.</li>
<li>With a single <code>T: 'a</code> clause, the default lifetime is <code>'a</code>.</li>
<li>With multiple <code>T: 'a</code>-like clauses, there is no default; we must
be explicit.</li>
</ul>
<p>When we must be explicit, we can add a lifetime bound on a trait object like
<code>Box&lt;Red&gt;</code> with the syntax <code>Box&lt;Red + 'a&gt;</code> or <code>Box&lt;Red + 'static&gt;</code>, depending
on what’s needed. Just as with the other bounds, this means that any
implementor of the <code>Red</code> trait that has references inside must have the
same lifetime specified in the trait object bounds as those references.</p>
<p>Next, let’s take a look at some other advanced features dealing with traits!</p>
<a class="header" href="print.html#advanced-traits" id="advanced-traits"><h2>Advanced Traits</h2></a>
<p>We first covered traits in the “Traits: Defining Shared Behavior” section of
Chapter 10 but, like lifetimes, we didn’t get to some of the more advanced
details. Now that we know more Rust, we can get into the nitty-gritty.</p>
<a class="header" href="print.html#associated-types-specify-placeholder-types-in-trait-definitions" id="associated-types-specify-placeholder-types-in-trait-definitions"><h3>Associated Types Specify Placeholder Types in Trait Definitions</h3></a>
<p><em>Associated types</em> are a way of associating a type placeholder with a trait
such that the trait method definitions can use these placeholder types in their
signatures. The implementor of a trait will specify the concrete type to be
used in this type’s place for the particular implementation. That way, we can
define a trait that uses some types without needing to know exactly what those
types are until the trait is implemented.</p>
<!-- Can you say what this is useful for -- it seems like a way to not to have
to specify a type prior to use, is that right? -->
<!-- Prior to trait implementation, yes. /Carol -->
<p>We’ve described most of the things in this chapter as being needed very rarely.
Associated types are somewhere in the middle; they’re used more rarely than the
rest of the book, but more commonly than many of the things in this chapter.</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait provided
by the standard library. This has an associated type named <code>Item</code> that stands
in for the type of the values it’s iterating over. In “The <code>Iterator</code> Trait and
the <code>next</code> Method” section of Chapter 13, we mentioned that the definition of
the <code>Iterator</code> trait is as shown in Listing 19-20:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-20: The definition of the <code>Iterator</code> trait
that has an associated type <code>Item</code></span></p>
<p>The <code>Iterator</code> trait has an associated type named <code>Item</code>. This is a placeholder
type, and the <code>next</code> method will return values of type <code>Option&lt;Self::Item&gt;</code>.
Implementors of this trait will specify the concrete type for <code>Item</code>, and the
<code>next</code> method will return an <code>Option</code> containing a value of that concrete type.</p>
<a class="header" href="print.html#associated-types-versus-generics" id="associated-types-versus-generics"><h4>Associated Types Versus Generics</h4></a>
<p>This may seem like a similar concept to generics, in that it allows us to
define a function without specifying what types it can deal with. So why use
associated types?</p>
<p>Let’s examine the difference with an example that implements the <code>Iterator</code>
trait on the <code>Counter</code> struct from Chapter 13. In Listing 13-21, we specified
that the <code>Item</code> type was <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
</code></pre>
<p>This feels similar to generics. So why not just define the <code>Iterator</code> trait
with generics as shown in Listing 19-21?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-21: A hypothetical definition of the
<code>Iterator</code> trait using generics</span></p>
<p>The difference lies in the fact that when using generics like in Listing 19-21,
we have to annotate the types in each implementation. This is because we can
also implement <code>Iterator&lt;String&gt; for Counter</code>, or any other type, which would
give us multiple implementations of <code>Iterator</code> for <code>Counter</code>. In other words,
when a trait has a generic parameter, it can be implemented for a type multiple
times, changing the concrete types of the generic type parameters each time.
When we use the <code>next</code> method on <code>Counter</code>, we’d then have to provide type
annotations to indicate which implementation of <code>Iterator</code> we wanted to use.</p>
<p>With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. With Listing 19-20, we can only
choose once what the type of <code>Item</code> will be, because there can only be one <code>impl Iterator for Counter</code>. We don’t have to specify that we want an iterator of
<code>u32</code> values everywhere that we call <code>next</code> on <code>Counter</code>.</p>
<a class="header" href="print.html#default-generic-type-parameters-and-operator-overloading" id="default-generic-type-parameters-and-operator-overloading"><h3>Default Generic Type Parameters and Operator Overloading</h3></a>
<p>When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. The syntax for specifying a
default type for a generic type is to put <code>&lt;PlaceholderType=ConcreteType&gt;</code> when
declaring the generic type.</p>
<p>A great example of a situation where this is useful is with operator
overloading. Operator overloading is customizing the behavior of an operator
(like <code>+</code>) in particular situations.</p>
<!-- Are we safe in assuming the reader is familiar with operator overloading
and why/when to use it, or is it worth giving a quick definition here? -->
<!-- Added /Carol -->
<p>Rust does not allow you to create your own operators or overload arbitrary
operators, but you <em>can</em> overload the operations and corresponding traits
listed in <code>std::ops</code> by implementing the traits associated with the operator.
For example, in Listing 19-22 we overload the <code>+</code> operator to add two <code>Point</code>
instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>
struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug,PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">Listing 19-22: Implementing the <code>Add</code> trait to overload
the <code>+</code> operator for <code>Point</code> instances</span></p>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances together and the
<code>y</code> values of two <code>Point</code> instances together to create a new <code>Point</code>. The <code>Add</code>
trait has an associated type named <code>Output</code> that determines the type returned
from the <code>add</code> method.</p>
<p>The default generic type here is within the <code>Add</code> trait. Here’s its definition:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
#}</code></pre></pre>
<p>This should look generally familiar, as a trait with one method and an
associated type. The new part here is the <code>RHS=Self</code> in the angle brackets:
this syntax is called <em>default type parameters</em>. The <code>RHS</code> generic type
parameter---short for “right hand side”---that’s used to define the type of the
<code>rhs</code> parameter in the <code>add</code> method. If we don’t specify a concrete type for
<code>RHS</code> when we implement the <code>Add</code> trait, the type of <code>RHS</code> will default to
<code>Self</code>, which will be the type we’re implementing <code>Add</code> on.</p>
<!-- Can you say what we're looking out for in this next trait -->
<!-- Done/reworked to be less repetitive with the Point example /Carol -->
<p>When we implemented <code>Add</code> for <code>Point</code>, we made use of the default for <code>RHS</code>
because we wanted to add two <code>Point</code> instances together. Let’s look at an
example of implementing the <code>Add</code> trait where we want to customize the <code>RHS</code>
type rather than using the default.</p>
<p>We have two structs holding values in different units, <code>Millimeters</code> and
<code>Meters</code>. We want to be able to add values in millimeters to values in meters,
and have the implementation of <code>Add</code> do the conversion correctly. We can
implement <code>Add</code> for <code>Millimeters</code> with <code>Meters</code> as the right hand side as shown
in Listing 19-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-23: Implementing the <code>Add</code> trait on
<code>Millimeters</code> to be able to add <code>Millimeters</code> to <code>Meters</code></span></p>
<p>To be able to add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to
set the value of the <code>RHS</code> type parameter instead of using the default of
<code>Self</code>.</p>
<p>Default type parameters are used in two main ways:</p>
<ol>
<li>To extend a type without breaking existing code.</li>
<li>To allow customization in specific cases most users won’t need.</li>
</ol>
<!-- Above, in 2., do you mean customization used in corner cases? -->
<!-- Yes, I'm not sure how that's different than what we've stated here or how
it could be clearer /Carol-->
<p>The standard library’s <code>Add</code> trait is an example of the second purpose: most of
the time, you’re adding two like types together, but it gives the ability for
customizing beyond that. Using a default type parameter in the <code>Add</code> trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a little bit of implementation boilerplate isn’t needed,
making it easier to use the trait.</p>
<p>The first purpose is similar, but in reverse: if we want to add a type
parameter to an existing trait, we can give it a default to let us extend the
functionality of the trait without breaking the existing implementation code.</p>
<a class="header" href="print.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name" id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><h3>Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</h3></a>
<p>Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor can it prevent us from implementing both of these
traits on one type. It’s also possible to have a method implemented directly on
the type with the same name as methods from traits as well!</p>
<!-- Same name as the type, you mean? -->
<!-- No, the same name as methods implemented from traits. I've tried to
clarify /Carol -->
<p>When calling methods with the same name, then, we need to tell Rust which one
we want to use. Consider the code in Listing 19-24 where we’ve defined two
traits, <code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then
implement both traits on a type <code>Human</code> that itself already has a method named
<code>fly</code> implemented on it. Each <code>fly</code> method does something different:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-24: Two traits defined to have a <code>fly</code> method,
and implementations of those traits on the <code>Human</code> type in addition to a <code>fly</code>
method on <code>Human</code> directly</span></p>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-25: Calling <code>fly</code> on an instance of
<code>Human</code></span></p>
<p>Running this will print out <code>*waving arms furiously*</code>, which shows that Rust
called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>In order to call the <code>fly</code> methods from either the <code>Pilot</code> trait or the
<code>Wizard</code> trait, we need to use more explicit syntax in order to specify which
<code>fly</code> method we mean. This syntax is demonstrated in Listing 19-26:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-26: Specifying which trait’s <code>fly</code> method we
want to call</span></p>
<p>Specifying the trait name before the method name clarifies to Rust which
implementation of <code>fly</code> we want to call. We could also choose to write
<code>Human::fly(&amp;person)</code>, which is equivalent to <code>person.fly()</code> that we had in
Listing 19-26, but is a bit longer to write if we don’t need to disambiguate.</p>
<p>Running this code will print:</p>
<pre><code class="language-text">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that
both implement one <em>trait</em>, Rust can figure out which implementation of a trait
to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are part of traits don’t have a <code>self</code>
parameter. When two types in the same scope implement that trait, Rust can’t
figure out which type we mean unless we use <em>fully qualified syntax</em>. For
example, take the <code>Animal</code> trait in Listing 19-27 that has the associated
function <code>baby_name</code>, the implementation of <code>Animal</code> for the struct <code>Dog</code>, and
the associated function <code>baby_name</code> defined on <code>Dog</code> directly:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-27: A trait with an associated function and a
type that has an associated function with the same name that also implements
the trait</span></p>
<p>This code is for an animal shelter where they want to give all puppies the name
Spot, which is implemented in the <code>baby_name</code> associated function that is
defined on <code>Dog</code>. The <code>Dog</code> type also implements the trait <code>Animal</code>, which
describes characteristics that all animals have. Baby dogs are called puppies,
and that is expressed in the implementation of the <code>Animal</code> trait on <code>Dog</code> in
the <code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>In <code>main</code>, we’re calling the <code>Dog::baby_name</code> function, which calls the
associated function defined on <code>Dog</code> directly. This code prints:</p>
<pre><code class="language-text">A baby dog is called a Spot
</code></pre>
<p>This isn’t what we wanted. We want to call the <code>baby_name</code> function that’s part
of the <code>Animal</code> trait that we implemented on <code>Dog</code> so that we print <code>A baby dog is called a puppy</code>. The technique we used in Listing 19-26 doesn’t help here;
if we change <code>main</code> to be the code in Listing 19-28, we’ll get a compilation
error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">Listing 19-28: Attempting to call the <code>baby_name</code>
function from the <code>Animal</code> trait, but Rust doesn’t know which implementation to
use</span></p>
<p>Because <code>Animal::baby_name</code> is an associated function rather than a method, and
thus doesn’t have a <code>self</code> parameter, Rust has no way to figure out which
implementation of <code>Animal::baby_name</code> we want. We’ll get this compiler error:</p>
<pre><code class="language-text">error[E0283]: type annotations required: cannot resolve `_: Animal`
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of
<code>Animal</code> for <code>Dog</code>, we need to use <em>fully qualified syntax</em>, which is the most
specific we can be when calling a function. Listing 19-29 demonstrates how to
use fully qualified syntax:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Animal {
#     fn baby_name() -&gt; String;
# }
#
# struct Dog;
#
# impl Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;Spot&quot;)
#     }
# }
#
# impl Animal for Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;puppy&quot;)
#     }
# }
#
fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-29: Using fully qualified syntax to specify
that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as
implemented on <code>Dog</code></span></p>
<p>We’re providing Rust with a type annotation within the angle brackets, and
we’re specifying that we want to call the <code>baby_name</code> method from the <code>Animal</code>
trait as implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as
an <code>Animal</code> for this function call. This code will now print what we want:</p>
<pre><code class="language-text">A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>For associated functions, there would not be a <code>receiver</code>, there would only be
the list of other arguments. We could choose to use fully qualified syntax
everywhere that we call functions or methods. However, we’re allowed to leave
out any part of this syntax that Rust is able to figure out from other
information in the program. We only need to use this more verbose syntax in
cases where there are multiple implementations that use the same name and Rust
needs help in order to know which implementation we want to call.</p>
<a class="header" href="print.html#using-supertraits-to-require-one-traits-functionality-within-another-trait" id="using-supertraits-to-require-one-traits-functionality-within-another-trait"><h3>Using Supertraits to Require One Trait’s Functionality Within Another Trait</h3></a>
<p>Sometimes, we may need one trait to use another trait’s functionality. In this
case, we need to be able to rely on the dependent trait also being implemented.
The trait we’re relying on is a <em>supertrait</em> of the trait we’re implementing.</p>
<p>For example, let’s say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print out a value framed in asterisks. That
is, given a <code>Point</code> struct that implements <code>Display</code> to result in <code>(x, y)</code>,
when we call <code>outline_print</code> on a <code>Point</code> instance that has 1 for <code>x</code> and 3 for
<code>y</code>, it should print the following:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of <code>outline_print</code>, we want to use the <code>Display</code> trait’s
functionality. We therefore need to specify that the <code>OutlinePrint</code> trait will
only work for types that also implement <code>Display</code> and therefore provide the
functionality that <code>OutlinePrint</code> needs. We can do that in the trait definition
by specifying <code>OutlinePrint: Display</code>. This is similar to adding a trait bound
to the trait. Listing 19-30 shows an implementation of the <code>OutlinePrint</code> trait:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-30: Implementing the <code>OutlinePrint</code> trait that
requires the functionality from <code>Display</code></span></p>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that’s automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding<code>: Display</code> after the trait name we’d get an error saying that no method named
<code>to_string</code> was found for the type <code>&amp;Self</code> in the current scope.</p>
<p>Let’s see what happens if we try to implement <code>OutlinePrint</code> on a type that
doesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
#}</code></pre></pre>
<p>We’ll get an error saying that <code>Display</code> is required but not implemented:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
   try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<p>Once we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
#}</code></pre></pre>
<p>Then, implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<a class="header" href="print.html#the-newtype-pattern-to-implement-external-traits-on-external-types" id="the-newtype-pattern-to-implement-external-traits-on-external-types"><h3>The Newtype Pattern to Implement External Traits on External Types</h3></a>
<p>In Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the
orphan rule that says we’re allowed to implement a trait on a type as long as
either the trait or the type are local to our crate. It is possible to get
around this restriction using the <em>newtype pattern</em>, which involves creating a
new type in a tuple struct (we covered tuple structs in the “Tuple Structs
without Named Fields to Create Different Types” section of Chapter 5). The
tuple struct will have one field and will be a thin wrapper around the type we
want to implement a trait for. Then the wrapper type is local to our crate, and
we can implement the trait on the wrapper. “Newtype” is a term originating from
the Haskell programming language. There’s no runtime performance penalty for
using this pattern, and the wrapper type is elided at compile time.</p>
<p>As an example, we want to implement <code>Display</code> on <code>Vec</code>, which the orphan rule
prevents us from doing directly because the <code>Display</code> trait and the <code>Vec</code> type
are both defined outside of our crate. We can make a <code>Wrapper</code> struct that
holds an instance of <code>Vec</code>, then we can implement <code>Display</code> on <code>Wrapper</code> and
use the <code>Vec</code> value as shown in Listing 19-31:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Listing 19-31: Creating a <code>Wrapper</code> type around
<code>Vec&lt;String&gt;</code> to be able to implement <code>Display</code></span></p>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec</code>,
because <code>Wrapper</code> is a tuple struct and the <code>Vec</code> is the item at index 0 in the
tuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<!-- What is self.0? I think the syntax here might need a bit more talking
through -->
<!-- `Wrapper` is a tuple struct; we covered those in chapter 5, added a back
reference to that section in the first paragraph of this section but we've used
the `.0` syntax in multiple places before here /Carol -->
<p>The downside of this method is that, because <code>Wrapper</code> is a new type, it
doesn’t have the methods of the value it’s holding; we’d have to implement all
the methods of <code>Vec</code> directly on <code>Wrapper</code>, so that it can delegate to
<code>self.0</code>--- this allows us to treat <code>Wrapper</code> exactly like a <code>Vec</code>. If we
wanted the new type to have every single method that the inner type has,
implementing the <code>Deref</code> trait (discussed in Chapter 15 in the “Treating Smart
Pointers like Regular References with the <code>Deref</code> Trait” section) on the
wrapper to return the inner type can be a solution. If we don’t want the
wrapper type to have all the methods of the inner type, in order to restrict
the wrapper type’s behavior for example, we’d have to implement just the
methods we do want ourselves.</p>
<p>That’s how the newtype pattern is used in relation to traits; it’s also a
useful pattern without having traits involved. Let’s switch focus now to talk
about some advanced ways to interact with Rust’s type system.</p>
<a class="header" href="print.html#advanced-types" id="advanced-types"><h2>Advanced Types</h2></a>
<p>The Rust type system has some features that we’ve mentioned in this book but
haven’t yet discussed. We’ll start our discussion on advanced types with a more
general discussion about why newtypes are useful as types. We’ll then move to
type aliases, a feature similar to newtypes but with slightly different
semantics. We’ll also discuss the <code>!</code> type and dynamically sized types.</p>
<a class="header" href="print.html#using-the-newtype-pattern-for-type-safety-and-abstraction" id="using-the-newtype-pattern-for-type-safety-and-abstraction"><h3>Using the Newtype Pattern for Type Safety and Abstraction</h3></a>
<blockquote>
<p>This section assumes you’ve read the newtype pattern section in the “Advanced
Traits” section.</p>
</blockquote>
<p>The newtype pattern is useful for other things beyond what we’ve discussed so
far, including statically enforcing that values are never confused, and as
indication of the units of a value. We actually had an example of this in
Listing 19-23: the <code>Millimeters</code> and <code>Meters</code> structs both wrap <code>u32</code> values in
a newtype. If we write a function with a parameter of type <code>Millimeters</code>, we
won’t be able to compile a program that accidentally tries to call that
function with a value of type <code>Meters</code> or a plain <code>u32</code>.</p>
<p>Another use is in abstracting away some implementation details of a type: the
wrapper type can expose a public API that’s different to the API of the private
inner type, if we used it directly to restrict the available functionality, for
example.</p>
<p>Newtypes can also hide internal generic types. For example, we could provide a
<code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID
associated with their name. Code using <code>People</code> would only interact with the
public API we provide, such as a method to add a name string to the <code>People</code>
collection, and that code wouldn’t need to know that we assign an <code>i32</code> ID to
names internally. The newtype pattern is a lightweight way to achieve
encapsulation to hide implementation details that we discussed in the
“Encapsulation that Hides Implementation Details” section of Chapter 17.</p>
<a class="header" href="print.html#type-aliases-create-type-synonyms" id="type-aliases-create-type-synonyms"><h3>Type Aliases Create Type Synonyms</h3></a>
<p>Alongside the newtype pattern, Rust provides the ability to declare a <em>type
alias</em> to give an existing type another name. For this we use the <code>type</code>
keyword. For example, we can create the alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;
#}</code></pre></pre>
<p>This means <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code> and
<code>Meters</code> types we created in Listing 19-23, <code>Kilometers</code> is not a separate, new
type. Values that have the type <code>Kilometers</code> will be treated exactly the same
as values of type <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
#}</code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code>, are the same type, we can add values of both
types, and we can also pass <code>Kilometers</code> values to functions that take <code>i32</code>
parameters. With this method, though, we don’t get the type checking benefits
that we get from the newtype pattern discussed in the previous section.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
may have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;Fn() + Send + 'static&gt;
</code></pre>
<p>Writing this out in function signatures and as type annotations all over the
place can be tiresome and error-prone. Imagine having a project full of code
like that in Listing 19-32:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-32: Using a long type in many places</span></p>
<p>A type alias makes this code more manageable by reducing the repetition. Here,
we’ve introduced an alias named <code>Thunk</code> for the verbose type, and can replace
all uses of the type with the shorter <code>Thunk</code> as shown in Listing 19-33:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Thunk = Box&lt;Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-33: Introducing a type alias <code>Thunk</code> to reduce
repetition</span></p>
<p>Much easier to read and write! Choosing a good name for a type alias can help
communicate your intent as well (<em>thunk</em> is a word for code to be evaluated at
a later time, so it’s an appropriate name for a closure that gets stored).</p>
<p>Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing
repetition. Consider the <code>std::io</code> module in the standard library. I/O
operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations
fail to work. This library has a <code>std::io::Error</code> struct that represents all
possible I/O errors. Many of the functions in <code>std::io</code> will be returning
<code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code>, such as these functions in
the <code>Write</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
#}</code></pre></pre>
<p>We have <code>Result&lt;..., Error&gt;</code> repeated a lot. As such, <code>std::io</code> has this type
alias declaration:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>Because this is in the <code>std::io</code> module, we can use the fully qualified alias
<code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code> filled in as
<code>std::io::Error</code>. The <code>Write</code> trait function signatures end up looking like
this:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>The type alias helps in two ways: this is easier to write <em>and</em> it gives us a
consistent interface across all of <code>std::io</code>. Because it’s an alias, it is just
another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, as well as special syntax like <code>?</code>.</p>
<a class="header" href="print.html#the--never-type-that-never-returns" id="the--never-type-that-never-returns"><h3>The <code>!</code> Never Type that Never Returns</h3></a>
<p>Rust has a special type named <code>!</code> that’s known in type theory lingo as the
<em>empty type</em>, because it has no values. We prefer to call it the <em>never type</em>,
because it stands in the place of the return type when a function will never
return. For example:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<p>This is read as “the function <code>bar</code> returns never.” Functions that return never
are called <em>diverging functions</em>. We can’t create values of the type <code>!</code>, so
<code>bar</code> can never possibly return.</p>
<p>But what use is a type you can never create values for? If you think all the
way back to Chapter 2, we had some code that looked like the code we’ve
reproduced here in Listing 19-34:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let guess = &quot;3&quot;;
# loop {
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
# break;
# }
#}</code></pre></pre>
<p><span class="caption">Listing 19-34: A <code>match</code> with an arm that ends in
<code>continue</code></span></p>
<p>At the time, we skipped over some details in this code. In Chapter 6 in “The
<code>match</code> Control Flow Operator” section, we covered that <code>match</code> arms must all
return the same type. This, for example, doesn’t work:</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse()  {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>The type of <code>guess</code> here would have to be both an integer and a string, and
Rust requires that <code>guess</code> can only have one type. So what does <code>continue</code>
return? How were we allowed to return a <code>u32</code> from one arm and have another arm
that ends with <code>continue</code> in Listing 19-34?</p>
<p>As you may have guessed, <code>continue</code> has a value of <code>!</code>. That is, when Rust goes
to compute the type of <code>guess</code>, it looks at both of the match arms, the former
with a value of <code>u32</code>, and the latter a value of <code>!</code>. Because <code>!</code> can never
have a value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can
be coerced into any other type. We’re allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn’t actually return a value; it instead moves
control back to the top of the loop, so in the <code>Err</code> case, we never actually
assign a value to <code>guess</code>.</p>
<!-- I'm not sure I'm following what would then occur in the event of an error,
literally nothing? -->
<!-- The block returns control to the enclosing loop; I'm not sure how to
clarify this other than what we already have here, do you have any suggestions?
I wouldn't say it's "literally nothing" because it does do something, it
returns control to the loop and the next iteration of the loop happens...
/Carol -->
<p>The never type is also useful with <code>panic!</code>. Remember the <code>unwrap</code> function
that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic? Here’s its
definition:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>Here, the same thing happens as in the <code>match</code> in Listing 19-34: we know that
<code>val</code> has the type <code>T</code>, and <code>panic!</code> has the type <code>!</code>, so the result of the
overall <code>match</code> expression is <code>T</code>. This works because <code>panic!</code> doesn’t produce
a value; it ends the program. In the <code>None</code> case, we won’t be returning a value
from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>Here, the loop never ends, so the value of the expression is <code>!</code>. This wouldn’t
be true if we included a <code>break</code>, however, as the loop would terminate when it
got to the <code>break</code>.</p>
<a class="header" href="print.html#dynamically-sized-types--sized" id="dynamically-sized-types--sized"><h3>Dynamically Sized Types &amp; <code>Sized</code></h3></a>
<p>Due to Rust’s need to know things like how much space to allocate for a value
of a particular type, there’s a corner of its type system that can be
confusing: the concept of <em>dynamically sized types</em>. Sometimes referred to as
‘DSTs’ or ‘unsized types’, these types let us talk about types whose size we
can only know at runtime.</p>
<p>Let’s dig into the details of a dynamically sized type that we’ve been using
this whole book: <code>str</code>. That’s right, not <code>&amp;str</code>, but <code>str</code> on its own, is a
DST. We can’t know how long the string is until runtime, meaning we can’t
create a variable of type <code>str</code>, nor can we take an argument of type <code>str</code>.
Consider this code, which does not work:</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<!-- Why do they need to have the same memory layout? Perhaps I'm not
understanding fully what is meant by the memory layout, is it worth explaining
that a little in this section? -->
<!-- I've reworded /Carol -->
<p>Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If we were
allowed to write this code, that would mean these two <code>str</code> values would need
to take up the exact same amount of space, but they have different lengths:
<code>s1</code> needs 12 bytes of storage, and <code>s2</code> needs 15. This is why it’s not
possible to create a variable holding a dynamically sized type.</p>
<p>So what to do? You already know the answer in this case: we make the types of
<code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than <code>str</code>. If you think back to the “String
Slices” section of Chapter 4, we said that the slice data structure stores the
starting position and the length of the slice.</p>
<p>So while a <code>&amp;T</code> is a single value that stores the memory address of where the
<code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its
length. As such, a <code>&amp;str</code> has a size we can know at compile time: it’s two
times the size of a <code>usize</code> in length. That is, we always know the size of a
<code>&amp;str</code>, no matter how long the string it refers to is. This is the general way
in which dynamically sized types are used in Rust; they have an extra bit of
metadata that stores the size of the dynamic information. This leads us to the
golden rule of dynamically sized types: we must always put values of
dynamically sized types behind a pointer of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: <code>Box&lt;str&gt;</code>, for example, or
<code>Rc&lt;str&gt;</code>. In fact, you’ve seen this before, but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the “Using Trait Objects that
Allow for Values of Different Types” section, we mentioned that in order to use
traits as trait objects, we have to put them behind a pointer like <code>&amp;Trait</code> or
<code>Box&lt;Trait&gt;</code> (<code>Rc&lt;Trait&gt;</code> would work too). Traits being dynamically sized is
the reason we have to do that!</p>
<a class="header" href="print.html#the-sized-trait" id="the-sized-trait"><h4>The <code>Sized</code> Trait</h4></a>
<!-- If we end up keeping the section on object safety in ch 17, we should add
a back reference here. /Carol -->
<!-- I think we dropped that one, right? -->
<!-- We cut a large portion of it, including the part about `Sized`, so I
didn't add a back reference. /Carol -->
<p>To work with DSTs, Rust has a particular trait to determine if a type’s size is
known at compile time or not: the <code>Sized</code> trait. This trait is automatically
implemented for everything whose size is known at compile time. In addition,
Rust implicitly adds a bound on <code>Sized</code> to every generic function. That is, a
generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>is actually treated as if we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>By default, generic functions will only work on types that have a known size at
compile time. There is, however, special syntax you can use to relax this
restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p>A trait bound on <code>?Sized</code> is the opposite of a trait bound on <code>Sized</code>; that is,
we would read this as “<code>T</code> may or may not be <code>Sized</code>”. This syntax is only
available for <code>Sized</code>, no other traits.</p>
<p>Also note we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>: because
the type might not be <code>Sized</code>, we need to use it behind some kind of pointer.
In this case, we’ve chosen a reference.</p>
<p>Next let’s talk about functions and closures!</p>
<a class="header" href="print.html#advanced-functions--closures" id="advanced-functions--closures"><h2>Advanced Functions &amp; Closures</h2></a>
<p>Finally, let’s discuss some advanced features related to functions and
closures: function pointers, diverging functions, and returning closures.</p>
<a class="header" href="print.html#function-pointers" id="function-pointers"><h3>Function Pointers</h3></a>
<!-- Maybe give an example of when we'd want to use this? -->
<!-- Added a short sentence, but we discuss interfacing with languages that
don't have closures below, which I don't think makes sense until we define how
function pointers are different than closures... /Carol -->
<p>We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This is useful when we want to pass a function we’ve
already defined rather than defining a new closure. We do this using function
pointers to allow us to use functions as arguments to other functions.
Functions coerce to the type <code>fn</code>, with a lower case ‘f’ not to be confused
with the <code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function pointer</em>. The
syntax for specifying that a parameter is a function pointer is similar to that
of closures, as shown in Listing 19-35:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Listing 19-35: Using the <code>fn</code> type to accept a function
pointer as an argument</span></p>
<p>This prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly, rather than declaring a generic type parameter with
one of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), so we can always pass a function pointer as an argument for a
function that expects a closure. Prefer to write functions using a generic type
and one of the closure traits, so that your functions can accept either
functions or closures.</p>
<p>An example of a case where you’d want to only accept <code>fn</code> and not closures is
when interfacing with external code that doesn’t have closures: C functions can
accept functions as arguments, but C doesn’t have closures.</p>
<p>For an example where we can use either a closure defined inline or a named
function, let’s look at a use of <code>map</code>. To use the <code>map</code> function to turn a
vector of numbers into a vector of strings, we could use a closure:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
#}</code></pre></pre>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
#}</code></pre></pre>
<p>Note that we do have to use the fully qualified syntax that we talked about in
the “Advanced Traits” section because there are multiple functions available
named <code>to_string</code>; here, we’re using the <code>to_string</code> function defined in the
<code>ToString</code> trait, which the standard library has implemented for any type that
implements <code>Display</code>.</p>
<p>Some people prefer this style, some people prefer to use closures. They end up
with the same code, so use whichever feels more clear to you.</p>
<a class="header" href="print.html#returning-closures" id="returning-closures"><h3>Returning Closures</h3></a>
<p>Closures are represented by traits, which means we can’t return closures
directly. In most cases where we may want to return a trait, we can instead use
the concrete type that implements the trait as the return value of the
function. We can’t do that with closures, though, because they don’t have a
concrete type that’s returnable; we’re not allowed to use the function pointer
<code>fn</code> as a return type, for example.</p>
<p>This code that tries to return a closure directly won’t compile:</p>
<pre><code class="language-rust ignore">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>The compiler error is:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + 'static`
  = note: the return type of a function must have a statically known size
</code></pre>
<p>Our error references the <code>Sized</code> trait again! Rust doesn’t know how much space
it will need to store the closure. We saw a solution to this in the previous
section: we can use a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<p>This code will compile just fine. For more about trait objects, refer back to
the “Trait Objects” section in Chapter 17.</p>
<a class="header" href="print.html#summary-14" id="summary-14"><h2>Summary</h2></a>
<p>Whew! Now we’ve gone over features of Rust that aren’t used often, but are
available if you need them in very particular circumstances. We’ve introduced a
lot of complex topics so that, when you encounter them in error message
suggestions or in others’ code, you’ll at least have seen these concepts and
syntax once before. You can use this chapter as a reference to guide you to
your solutions.</p>
<p>Now, let’s put everything we’ve learned throughout the book into practice with
one more project!</p>
<a class="header" href="print.html#final-project-building-a-multithreaded-web-server" id="final-project-building-a-multithreaded-web-server"><h1>Final Project: Building a Multithreaded Web Server</h1></a>
<p>It’s been a long journey, but here we are! The end of the book. Parting is such
sweet sorrow. But before we go, let’s build one more project together, to show
off some of the concepts we covered in these final chapters, as well as recap
some lessons from earlier.</p>
<p>For our final project we’re going to make a web server that only says “hello”;
which will look like Figure 20-1 in a web browser:</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 20-1: Our final shared project together</span></p>
<p>Here’s the plan of how we’ll build the web server:</p>
<ol>
<li>Learn a little bit about TCP and HTTP</li>
<li>Listen for TCP connections on a socket</li>
<li>Parse a small number of HTTP requests</li>
<li>Create a proper HTTP response</li>
<li>Improve the throughput of our server with a thread pool</li>
</ol>
<p>Before we get started, however, there’s one thing we should mention: the method
we use here will not be the best way to build a web server with Rust. There are
a number of production-ready crates available on <em>https://crates.io</em> that
provide much more complete web server and thread pool implementations than we
are going to build.</p>
<p>However, for this chapter, our intention is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we’re able to
choose what level of abstraction we want to work with, and can go to a lower
level than is possible or practical in other languages. We’ll therefore write
the basic HTTP server and thread pool ourselves so you can learn the general
ideas and techniques behind the crates you might use in the future.</p>
<a class="header" href="print.html#building-a-single-threaded-web-server" id="building-a-single-threaded-web-server"><h2>Building a Single Threaded Web Server</h2></a>
<p>First we’ll get a single threaded web server working, but before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a short overview will give you the information you need.</p>
<p>The two main protocols involved in web servers are the <em>Hypertext Transfer
Protocol</em> (<em>HTTP</em>) and the <em>Transmission Control Protocol</em> (<em>TCP</em>). Both
protocols are <em>request-response</em> protocols, meaning a <em>client</em> initiates
requests, and a <em>server</em> listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols themselves.</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another, but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the content of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’re going to work
with the raw bytes of TCP and HTTP requests and responses.</p>
<a class="header" href="print.html#listening-to-the-tcp-connection" id="listening-to-the-tcp-connection"><h3>Listening to the TCP Connection</h3></a>
<p>Our web server needs to be able to listen to a TCP connection, so that’s the
first part we’ll work on. The standard library offers a <code>std::net</code> module that
lets us do this. Let’s make a new project in the usual fashion:</p>
<pre><code class="language-text">$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 20-1 in <code>src/main.rs</code> to start. This code will
listen at the address <code>127.0.0.1:7878</code> for incoming TCP streams. When it gets
an incoming stream, it will print <code>Connection established!</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span></p>
<p>The <code>TcpListener</code> allows us to listen for TCP connections. We’ve chosen to
listen to the address <code>127.0.0.1:7878</code>. Breaking this address down, the section
before the colon is an IP address representing your own computer (this is the
same on each computer, and doesn’t represent the authors’ computer
specifically), and <code>7878</code> is the port. We’ve chosen this port for two reasons:
HTTP is normally accepted on this port and 7878 is &quot;rust&quot; typed on a telephone.
Note that connecting to port 80 requires administrator privileges;
non-administrators can only listen on ports higher than 1024.</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function, in that it
will return a new <code>TcpListener</code> instance. This function is called <code>bind</code>
because, in networking, connecting to a port to listen to is known as “binding
to a port”.</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that binding
might fail. For example, if we tried to connect to port 80 without being an
administrator, or if we ran two instances of our program and so had two
programs listening to the same port, binding wouldn’t work. Because we’re
writing a basic server for learning purposes here, we’re not going to worry
about handling these kinds of errors, so we use <code>unwrap</code> to stop the program if
errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request/response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, <code>TcpStream</code> will read from itself to see what
the client sent, and allow us to write our response to the stream. Overall,
this <code>for</code> loop will process each connection in turn and produce a series of
streams for us to handle.</p>
<!-- Below -- What if there aren't errors, how is the stream handled? Or is
there no functionality for that yet, only functionality for errors?
Also, highlighted below -- can you specify what errors we're talking
about---errors in *producing* the streams or connecting to the port?-->
<!--
There is no functionality for a stream without errors yet; I've clarified.
The errors happen when a client attempts to connect to the server; I've
clarified.
/Carol -->
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors, and if there aren’t any errors, then
print a message. We’ll add more functionality for the success case in the next
Listing. Receiving errors from the <code>incoming</code> method when a client connects to
the server is possible because we’re not actually iterating over connections,
we’re iterating over <em>connection attempts</em>. The connection might not be
successful for a number of reasons, many of them operating-system specific. For
example, many operating systems have a limit to the number of simultaneous open
connections they can support; new connection attempts beyond that number will
produce an error until some of the open connections are closed.</p>
<p>Let’s try this code out! First invoke <code>cargo run</code> in the terminal, then load up
<code>127.0.0.1:7878</code> in a web browser. The browser should show an error message
like “Connection reset”, because the server isn’t currently sending any data
back. If you look at your terminal, though, you should see a bunch of messages
that were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes, you’ll see multiple messages printed out for one browser request;
that might be because the browser is making a request for the page as well as a
request for other resources, like the <code>favicon.ico</code> icon that appears in the
browser tab.</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
thing is that we’ve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program with <span class="keystroke">ctrl-C</span> when
you’re done running a particular version of the code, and restart <code>cargo run</code>
after you’ve made each set of code changes to make sure you’re running the
newest code.</p>
<a class="header" href="print.html#reading-the-request" id="reading-the-request"><h3>Reading the Request</h3></a>
<p>Let’s implement the functionality to read in the request from the browser! To
separate out the concerns of getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new <code>handle_connection</code> function, we’ll read data from the TCP stream and
print it out so we can see the data being sent from the browser. Change the
code to look like Listing 20-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">Listing 20-2: Reading from the <code>TcpStream</code> and printing
out the data</span></p>
<p>We bring <code>std::io::prelude</code> into scope to get access to certain traits that let
us read from and write to the stream. In the <code>for</code> loop in the <code>main</code> function,
instead of printing a message that says we made a connection, we now call the
new <code>handle_connection</code> function and pass the <code>stream</code> to it.</p>
<p>In the <code>handle_connection</code> function, we’ve made the <code>stream</code> parameter mutable.
This is because the <code>TcpStream</code> instance keeps track of what data it returns to
us internally. It might read more data than we asked for and save that data for
the next time we ask for data. It therefore needs to be <code>mut</code> because its
internal state might change; usually we think of “reading” as not needing
mutation, but in this case we need the <code>mut</code> keyword.</p>
<!-- Above -- I'm not clear what state will change here, the content of stream
when the program tempers what data it takes? -->
<!-- Yes, which is what we mean by "internally". I've tried to reword a bit,
not sure if it's clearer. /Carol -->
<p>Next, we need to actually read from the stream. We do this in two steps: first,
we declare a <code>buffer</code> on the stack to hold the data that’s read in. We’ve made
the buffer 512 bytes in size, which is big enough to hold the data of a basic
request and sufficient for our purposes in this chapter. If we wanted to handle
requests of an arbitrary size, the management of the buffer would need to be
more complicated, but we’re keeping it simple for now. We pass the buffer to
<code>stream.read</code>, which will read bytes from the <code>TcpStream</code> and put them in the
buffer.</p>
<p>We then convert the bytes in the buffer to a string and print out that string.
The <code>String::from_utf8_lossy</code> function takes a <code>&amp;[u8]</code> and produces a <code>String</code>
from it. The ‘lossy’ part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with �, the <code>U+FFFD REPLACEMENT CHARACTER</code>. You might see replacement
characters for characters in the buffer that aren’t filled by request data.</p>
<p>Let’s give this a try! Start up the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but the output
of our program in the terminal will now look similar to this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>You’ll probably get slightly different output depending on your browser. Now
that we’re printing out the request data, we can see why we get multiple
connections from one browser request by looking at the path after <code>Request: GET</code>. If the repeated connections are all requesting <code>/</code>, we know the browser
is trying to fetch <code>/</code> repeatedly because it’s not getting a response from our
program.</p>
<p>Let’s break down this request data to understand what the browser is asking of
our program.</p>
<a class="header" href="print.html#a-closer-look-at-an-http-request" id="a-closer-look-at-an-http-request"><h4>A Closer Look at an HTTP Request</h4></a>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>First we have the <em>request line</em> that holds information about what the client
is requesting. The first part of the request line tells us the <em>method</em> being
used, like <code>GET</code> or <code>POST</code>, that describes how the client is making this
request. Our client used a <code>GET</code> request.</p>
<!-- Below, is that right that the / part is the URI *being requested*, and not
the URI of the requester? -->
<!-- Yes /Carol -->
<p>The next part of the <code>Request</code> line is <code>/</code> which tells us the <em>URI</em> (Uniform
Resource Identifier) that the client is requesting---a URI is almost, but not
quite, the same as a URL (<em>Uniform Resource Locator</em>). The difference between
URIs and URLs isn’t important for our purposes of this chapter, but the HTTP
spec uses the term URI, so we can just mentally substitute URL for URI here.</p>
<p>Finally, we’re given the HTTP version used by the client, and then the request
line ends in a CRLF sequence. The CRLF sequence can also be written as <code>\r\n</code>:
<code>\r</code> is a <em>carriage return</em> and <code>\n</code> is a <em>line feed</em>. (These terms come from
the typewriter days!) The CRLF sequence separates the request line from the
rest of the request data. Note that when CRLF is printed out, we see a new line
started rather than <code>\r\n</code>.</p>
<!-- Above, I don't see a CRLF here in the request line in the actual output,
is it just implied because the next line begins on the next line? -->
<!-- Yes, I've clarified. /Carol -->
<p>Taking a look at the request line data we received rom running our program so
far, we see that <code>GET</code> is the method, <code>/</code> is the Request URI, and <code>HTTP/1.1</code> is
the version.</p>
<p>The remaining lines starting from <code>Host:</code> onward are headers; <code>GET</code> requests
have no body.</p>
<p>Try making a request from a different browser, or asking for a different
address like <code>127.0.0.1:7878/test</code> to see how the request data changes, if
you’d like.</p>
<p>Now that we know what the browser is asking for, let’s send some data back!</p>
<a class="header" href="print.html#writing-a-response" id="writing-a-response"><h3>Writing a Response</h3></a>
<p>We’re going to implement the sending of data in response to a client request.
Responses have the following format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence comes any headers, another CRLF sequence, and the body of the
response.</p>
<p>Here’s an example response that uses version 1.1 of HTTP, has a status code of
<code>200</code>, a reason phrase of <code>OK</code>, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request!</p>
<p>From the <code>handle_connection</code> function, we need to remove the <code>println!</code> that
was printing the request data, and replace it with the code in Listing 20-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span></p>
<!-- Flagging for addition of wingdings later -->
<p>The first new line defines the <code>response</code> variable that holds the data of the
success message. Then we call <code>as_bytes</code> on our <code>response</code> to convert the
string data to bytes. The <code>write</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends
those bytes directly down the connection.</p>
<!-- Above--So what does adding as_bytes actually do, *allow* us to send bytes
directly? -->
<!-- It converts the string data to bytes, I've clarified /Carol -->
<p>Because the <code>write</code> operation could fail, we use <code>unwrap</code> on any error result
as before. Again, in a real application you would add error-handling here.
Finally, <code>flush</code> will wait and prevent the program from continuing until all of
the bytes are written to the connection; <code>TcpStream</code> contains an internal
buffer to minimize calls into the underlying operating system.</p>
<!-- Above -- Will flush wait until all bytes are written and then do
something? I'm not sure what task it's performing -->
<!-- `flush` just makes sure all the bytes we sent to `write` are actually
written to the stream before the function ends. Because writing to a stream
takes time, the `handle_connection` function could potentially finish and
`stream` could go out of scope before all the bytes given to `write` are sent,
unless we call `flush`. This is how streams work in many languages and is a
small detail I don't think is worth going into in depth. /Carol -->
<p>With these changes, let’s run our code and make a request! We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. Load <code>127.0.0.1:7878</code> in a web browser, though, and you
should get a blank page instead of an error. How exciting! You’ve just
hand-coded an HTTP request and response.</p>
<a class="header" href="print.html#returning-real-html" id="returning-real-html"><h3>Returning Real HTML</h3></a>
<p>Let’s implement returning more than a blank page. Create a new file,
<em>hello.html</em>, in the root of your project directory---that is, not in the <code>src</code>
directory. You can put in any HTML you want; Listing 20-4 shows one possibility:</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: A sample HTML file to return in a
response</span></p>
<p>This is a minimal HTML 5 document with a heading and some text. To return this
from the server when a request is received, let’s modify <code>handle_connection</code> as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
use std::fs::File;

// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let mut file = File::open(&quot;hello.html&quot;).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-5: Sending the contents of <em>hello.html</em> as the
body of the response</span></p>
<p>We’ve added a line at the top to bring the standard library’s <code>File</code> into
scope. The code for opening files and reading code should look familiar from
Chapter 12, when we read the contents of a file for our I/O project in Listing
12-4.</p>
<p>Next, we’re using <code>format!</code> to add the file’s contents as the body of the
success response.</p>
<p>Run this code with <code>cargo run</code>, load up <code>127.0.0.1:7878</code> in your browser, and
you should see your HTML rendered!</p>
<p>Currently we’re ignoring the request data in <code>buffer</code> and just sending back the
contents of the HTML file unconditionally. That means if you try requesting
<code>127.0.0.1:7878/something-else</code> in your browser you’ll still get back this same
HTML response. This makes for a pretty limited server and is not what most web
servers do. We’d like to customize our responses depending on the request, and
only send back the HTML file for a well-formed request to <code>/</code>.</p>
<a class="header" href="print.html#validating-the-request-and-selectively-responding" id="validating-the-request-and-selectively-responding"><h3>Validating the Request and Selectively Responding</h3></a>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting <code>/</code> before returning the HTML file, and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for <code>/</code> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let mut file = File::open(&quot;hello.html&quot;).unwrap();

        let mut contents = String::new();
        file.read_to_string(&amp;mut contents).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-6: Matching the request and handling requests
to <code>/</code> differently than other requests</span></p>
<p>First, we hardcode the data corresponding to the <code>/</code> request into the <code>get</code>
variable. Because we’re reading raw bytes into the buffer, we transform <code>get</code>
into a byte string by adding the <code>b&quot;&quot;</code> byte string syntax at the start of the
content data. Then, we check to see if <code>buffer</code> starts with the bytes in <code>get</code>.
If it does, it means we’ve received a well-formed request to <code>/</code>, which is the
success case we’ll handle in the <code>if</code> block that returns the contents of our
HTML file.</p>
<p>If <code>buffer</code> does <em>not</em> start with the bytes in <code>get</code>, it means we’ve received
some other request. We’ll add code to the <code>else</code> block in a moment to respond
to all other requests.</p>
<p>Run this code now and request <code>127.0.0.1:7878</code>, and you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<code>127.0.0.1:7878/something-else</code>, you’ll get a connection error like we saw when
running the code in Listing 20-1 and Listing 20-2.</p>
<p>Now let’s add the code in Listing 20-7 to the <code>else</code> block to return a response
with the status code <code>404</code>, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating as such to the end user:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
# fn handle_connection(mut stream: TcpStream) {
# if true {
// --snip--

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let mut file = File::open(&quot;404.html&quot;).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
# }
#}</code></pre></pre>
<p><span class="caption">Listing 20-7: Responding with status code <code>404</code> and an
error page if anything other than <code>/</code> was requested</span></p>
<p>Here, our response has a status line with status code <code>404</code> and the reason
phrase <code>NOT FOUND</code>. We’re still not returning headers, and the body of the
response will be the HTML in the file <em>404.html</em>. You’ll need to create a
<em>404.html</em> file next to <em>hello.html</em> for the error page; again feel free to use
any HTML you’d like or use the example HTML in Listing 20-8:</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Sample content for the page to send back
with any <code>404</code> response</span></p>
<p>With these changes, try running your server again. Requesting <code>127.0.0.1:7878</code>
should return the contents of <em>hello.html</em>, and any other request, like
<code>127.0.0.1:7878/foo</code>, should return the error HTML from <em>404.html</em>!</p>
<a class="header" href="print.html#a-touch-of-refactoring" id="a-touch-of-refactoring"><h3>A Touch of Refactoring</h3></a>
<p>At the moment our <code>if</code> and <code>else</code> blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make our code more
concise by pulling those differences out into an <code>if</code> and <code>else</code> of one line
each that will assign the values of the status line and the filename to
variables; we can then use those variables unconditionally in the code to read
the file and write the response. The resulting code after replacing the large
<code>if</code> and <code>else</code> blocks is shown in Listing 20-9:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
#
#     let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let mut file = File::open(filename).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-9: Refactoring so that the <code>if</code> and <code>else</code>
blocks only contain the code that differs between the two cases</span></p>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement like we discussed in Chapter 18.</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
exactly what’s different between the two cases, and means we have only one
place to update the code if we want to change how the file reading and response
writing works. The behavior of the code in Listing 20-9 will be exactly the
same as that in Listing 20-8.</p>
<p>Awesome! We have a simple little web server in about 40 lines of Rust code that
responds to one request with a page of content and responds to all other
requests with a <code>404</code> response.</p>
<p>Currently our server runs in a single thread, meaning it can only serve one
request at a time. Let’s see how that can be a problem by simulating some slow
requests, and then fix it so our server can handle multiple requests at once.</p>
<a class="header" href="print.html#turning-our-single-threaded-server-into-a-multithreaded-server" id="turning-our-single-threaded-server-into-a-multithreaded-server"><h2>Turning our Single Threaded Server into a Multithreaded Server</h2></a>
<!-- Reading ahead, the original heading didn't seem to fit all of the sub
headings -- this might not be totally right either, so feel free to replace
with something more appropriate -->
<!-- This is fine! /Carol -->
<p>Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If this
server were to receive more and more requests, this sort of serial execution
would prove to be less and less optimal. If the server receives a request that
takes a long time to process, subsequent requests will have to wait until the
long request is finished, even if the new requests can be processed quickly.
We’ll need to fix this, but first, we’ll look at the problem in action.</p>
<a class="header" href="print.html#simulating-a-slow-request-in-the-current-server-implementation" id="simulating-a-slow-request-in-the-current-server-implementation"><h3>Simulating a Slow Request in the Current Server Implementation</h3></a>
<p>Let’s see how a slow-processing request can affect other requests made to our
current server implementation. Listing 20-10 implements handling a request to
<code>/sleep</code> with a simulated slow response that will cause the server to sleep for
five seconds before responding.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
    // --snip--

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-10: Simulating a slow request by recognizing
<code>/sleep</code> and sleeping for 5 seconds</span></p>
<p>This code is a bit messy, but it’s good enough for our simulation purposes! We
created a second request <code>sleep</code>, whose data our server recognizes. We added an
<code>else if</code> after the <code>if</code> block to check for the request to <code>/sleep</code>, and when
that request is received, our server will sleep for five seconds before
rendering the successful HTML page.</p>
<p>You can really see how primitive our server is here; real libraries would
handle the recognition of multiple requests in a much less verbose way!</p>
<p>Start the server with <code>cargo run</code>, and then open up two browser windows: one
for <code>http://localhost:7878/</code> and one for <code>http://localhost:7878/sleep</code>. If you
enter the <code>/</code> URI a few times, as before, you’ll see it respond quickly. But if
you enter <code>/sleep</code>, and then load up <code>/</code>, you’ll see that <code>/</code> waits until
<code>sleep</code> has slept for its full five seconds before loading.</p>
<p>There are multiple ways we could change how our web server works in order to
avoid having all requests back up behind a slow request; the one we’re going to
implement is a thread pool.</p>
<a class="header" href="print.html#improving-throughput-with-a-thread-pool" id="improving-throughput-with-a-thread-pool"><h3>Improving Throughput with a Thread Pool</h3></a>
<!--There seems to be some repetition throughout these thread pool sections, is
there any way to condense it? I've edited with this in mind, but am wary of
changing too much -->
<!-- Your edits that removed repetition are fine! /Carol -->
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to
handle some task. When the program receives a new task, it will assign one of
the threads in the pool to the task, and that thread will go off and process
the task. The remaining threads in the pool are available to handle any other
tasks that come in while the first thread is processing. When the first thread
is done processing its task, it’s returned to the pool of idle threads ready to
handle a new task. A thread pool will allow us to process connections
concurrently, increasing the throughput of our server.</p>
<p>We’ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it comes in, someone making ten million requests to our
server could create havoc by using up all of our server’s resources and
grinding the processing of all requests to a halt.</p>
<p>Rather than spawning unlimited threads, then, we’ll have a fixed number of
threads waiting in the pool. As requests come in, they’ll be sent to the pool
for processing. The pool will maintain a queue of incoming requests. Each of
the threads in the pool will pop a request off of this queue, handle the
request, and then ask the queue for another request. With this design, we can
process <code>N</code> requests concurrently, where <code>N</code> is the number of threads. If each
thread is responding to a long-running request, subsequent requests can still
back up in the queue, but we’ve increased the number of long-running requests
we can handle before that point.</p>
<p>This is just one of many ways to improve the throughput of our web server.
Other options you might explore are the fork/join model and the single threaded
async I/O model. If you’re interested in this topic, you may want to read more
about other solutions and try to implement them in Rust; with a low-level
language like Rust, all of these options are possible.</p>
<p>Before we begin, let’s talk about what using the pool should look like. When
trying to design code, writing the client interface first can really help guide
your design. Write the API of the code so that it’s structured in the way you’d
want to call it, then implement the functionality within that structure, rather
than implementing the functionality then designing the public API.</p>
<p>Similar to how we used Test Driven Development in the project in Chapter 12,
we’re going to use Compiler Driven Development here. We’ll write the code that
calls the functions we wish we had, then we’ll look at errors from the compiler
to tell us what we should change next to get things working.</p>
<a class="header" href="print.html#code-structure-if-we-could-spawn-a-thread-for-each-request" id="code-structure-if-we-could-spawn-a-thread-for-each-request"><h4>Code Structure if We Could Spawn a Thread for Each Request</h4></a>
<p>First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned, this isn’t our final plan due to the problems
with potentially spawning an unlimited number of threads, but it’s a starting
point. Listing 20-11 shows the changes to make to <code>main</code> to spawn a new thread
to handle each stream within the <code>for</code> loop:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">Listing 20-11: Spawning a new thread for each
stream</span></p>
<p>As we learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
<code>/sleep</code> in your browser, then <code>/</code> in two more browser tabs, you’ll indeed see
the requests to <code>/</code> don’t have to wait for <code>/sleep</code> to finish. But as we
mentioned, this will eventually overwhelm the system because we’re making new
threads without any limit.</p>
<a class="header" href="print.html#creating-a-similar-interface-for-a-finite-number-of-threads" id="creating-a-similar-interface-for-a-finite-number-of-threads"><h4>Creating a Similar Interface for a Finite Number of Threads</h4></a>
<p>We want our thread pool to work in a similar, familiar way so that switching
from threads to a thread pool doesn’t require large changes to the code using
our API. Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code>
struct we’d like to use instead of <code>thread::spawn</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# struct ThreadPool;
# impl ThreadPool {
#    fn new(size: u32) -&gt; ThreadPool { ThreadPool }
#    fn execute&lt;F&gt;(&amp;self, f: F)
#        where F: FnOnce() + Send + 'static {}
# }
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">Listing 20-12: Our ideal <code>ThreadPool</code> interface</span></p>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a
similar interface as <code>thread::spawn</code>, in that it takes a closure of what code
the pool should run for each stream. We need to implement <code>pool.execute</code> such
that it takes the closure and gives it to a thread in the pool to run. This
code won’t yet compile, but we’re going to try so the compiler can guide us in
how to fix it.</p>
<!-- Can you be more specific here about how pool.execute will work? -->
<!-- So clarified. I hope this helps with some of the future confusion as well
/Carol -->
<a class="header" href="print.html#building-the-threadpool-struct-using-compiler-driven-development" id="building-the-threadpool-struct-using-compiler-driven-development"><h4>Building the <code>ThreadPool</code> Struct Using Compiler Driven Development</h4></a>
<p>Go ahead and make the changes in Listing 20-12 to <em>src/main.rs</em>, and let’s use
the compiler errors from <code>cargo check</code> to drive our development. Here’s the
first error we get:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<p>Great, this is telling us we need a <code>ThreadPool</code> type or module, so we’ll build
one now. Our <code>ThreadPool</code> implementation will be independent of the kind of
work our web server is doing, so let’s switch the <code>hello</code> crate from a binary
crate to a library crate to hold our <code>ThreadPool</code> implementation. This also
means we could use the separate thread pool library for whatever work we want
to do, not just for serving web requests.</p>
<p>Create a <em>src/lib.rs</em> that contains the following, which is simplest definition
of a <code>ThreadPool</code> struct that we can have for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;
#}</code></pre></pre>
<p>Then create a new directory, <em>src/bin</em>, and move the binary crate rooted in
<em>src/main.rs</em> into <em>src/bin/main.rs</em>. This will make the library crate the
primary crate in the <em>hello</em> directory; we can still run the binary in
<em>src/bin/main.rs</em> using <code>cargo run</code> though. After moving the <em>main.rs</em> file,
edit it to bring the library crate in and bring <code>ThreadPool</code> into scope by
adding the following code to the top of <em>src/bin/main.rs</em>:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;
</code></pre>
<p>This still won’t work, but let’s try checking it again in order to get the next
error that we need to address:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type
`hello::ThreadPool` in the current scope
 --&gt; src/bin/main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ function or associated item not found in
   `hello::ThreadPool`
</code></pre>
<p>Cool, this tells us that next we need to create an associated function named
<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter
that can accept <code>4</code> as an argument, and should return a <code>ThreadPool</code> instance.
Let’s implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
#}</code></pre></pre>
<p>We picked <code>usize</code> as the type of the <code>size</code> parameter, because we know that a
negative number of threads makes no sense. We also know we’re going to use this
4 as the number of elements in a collection of threads, which is what the
<code>usize</code> type is for, as discussed in the “Integer Types” section of Chapter 3.</p>
<p>Let’s check the code again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<!--Can you say a few words on why we would need an execute method, what Rust
needs it for? Also why we need a closure/what indicated that we need a closure
here? -->
<!-- *Rust* doesn't need it, the thread pool functionality we're working on
implementing needs it. I've tried to clarify without getting too repetitive
with the "Creating a Similar Interface for a Finite Number of Threads" section
/Carol -->
<p>Now we get a warning and an error. Ignoring the warning for a moment, the error
occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>. Recall from
the “Creating a Similar Interface for a Finite Number of Threads” section that
we decided our thread pool should have an interface similar to that of
<code>thread::spawn</code>, and that we’re going to implement the <code>execute</code> function to
take the closure that it’s given and give it to an idle thread in the pool to
run.</p>
<p>We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a
parameter. If you remember from the “Storing Closures Using Generic Parameters
and the <code>Fn</code> Traits” section in Chapter 13, we can take closures as parameters
with three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. We need to decide
which kind of closure to use here. We know we’re going to end up doing
something similar to the standard library <code>thread::spawn</code> implementation, so we
can look at what bounds the signature of <code>thread::spawn</code> has on its parameter.
The documentation tells us:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>F</code> is the parameter we care about here; <code>T</code> is related to the return value and
we’re not concerned with that. We can see that <code>spawn</code> uses <code>FnOnce</code> as the
trait bound on <code>F</code>. This is probably what we want as well, because we’ll
eventually be passing the argument we get in <code>execute</code> to <code>spawn</code>. We can be
further confident that <code>FnOnce</code> is the trait we want to use because the thread
for running a request is only going to execute that request’s closure one time,
which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<!-- Above -- why does that second reason mean FnOnce is the trait to use, can
you remind us? -->
<!-- Attempted, we're just pointing out that it's in the name Fn*Once* /Carol
-->
<p><code>F</code> also has the trait bound <code>Send</code> and the lifetime bound <code>'static</code>, which are
useful for our situation: we need <code>Send</code> to transfer the closure from one
thread to another, and <code>'static</code> because we don’t know how long the thread will
take to execute. Let’s create an <code>execute</code> method on <code>ThreadPool</code> that will
take a generic parameter <code>F</code> with these bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
#}</code></pre></pre>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> is representing a
closure that takes no parameters and doesn’t return a value. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.</p>
<p>Again, we’ll add the simplest implementation of the <code>execute</code> method, which
does nothing, just to get our code compiling. Let’s check it again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

warning: unused variable: `f`
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using `_f` instead
</code></pre>
<p>We’re receiving only warnings now! That means it compiles! Note, though, that
if you try <code>cargo run</code> and make a request in the browser, you’ll see the errors
in the browser that we saw in the beginning of the chapter. Our library isn’t
actually calling the closure passed to <code>execute</code> yet!</p>
<blockquote>
<p>A saying you might hear about languages with strict compilers like Haskell
and Rust is “if the code compiles, it works.” This is a good time to remember
that this is not actually universally true. Our project compiles, but it does
absolutely nothing! If we were building a real, complete project, this would
be a great time to start writing unit tests to check that the code compiles
<em>and</em> has the behavior we want.</p>
</blockquote>
<a class="header" href="print.html#validating-the-number-of-threads-in-new" id="validating-the-number-of-threads-in-new"><h4>Validating the Number of Threads in <code>new</code></h4></a>
<p>We’re still getting warnings because we aren’t doing anything with the
parameters to <code>new</code> and <code>execute</code>. Let’s implement the bodies of these
functions with the behavior we want. To start, let’s think about <code>new</code>.</p>
<p>Earlier we chose an unsigned type for the <code>size</code> parameter, because a pool with
a negative number of threads makes no sense. However, a pool with zero threads
also makes no sense, yet zero is a perfectly valid <code>usize</code>. Let’s add code to
check that <code>size</code> is greater than zero before we return a <code>ThreadPool</code>
instance, and have the program panic if a zero is received by using the
<code>assert!</code> macro as shown in Listing 20-13:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if
<code>size</code> is zero</span></p>
<p>We’ve taken this opportunity to add some documentation for our <code>ThreadPool</code>
with doc comments. Note that we followed good documentation practices by adding
a section that calls out the situations in which our function can panic as we
discussed in Chapter 14. Try running <code>cargo doc --open</code> and clicking on the
<code>ThreadPool</code> struct to see what the generate docs for <code>new</code> look like!</p>
<p>Instead of adding the <code>assert!</code> macro as we’ve done here, we could make <code>new</code>
return a <code>Result</code> like we did with <code>Config::new</code> in the I/O project in Listing
12-9, but we’ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you’re feeling
ambitious, try to write a version of <code>new</code> with this signature to see how you
feel about both versions:</p>
<pre><code class="language-rust ignore">fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<a class="header" href="print.html#creating-space-to-store-the-threads" id="creating-space-to-store-the-threads"><h4>Creating Space to Store the Threads</h4></a>
<p>Now that we have a way to know we have a valid number of threads to store in
the pool, we can actually create those threads and store them in the
<code>ThreadPool</code> struct before returning it.</p>
<p>This raises a question: how do we “store” a thread? Let’s take another look at
the signature of <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>spawn</code> returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that’s returned from
the closure. Let’s try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>The code in Listing 20-14 will compile, but isn’t actually creating any threads
yet. We’ve changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // --snip--
}
</code></pre>
<p><span class="caption">Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold
the threads</span></p>
<p>We’ve brought <code>std::thread</code> into scope in the library crate, because we’re using
<code>thread::JoinHandle</code> as the type of the items in the vector in <code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can
hold <code>size</code> items. We haven’t used the <code>with_capacity</code> function in this book
yet, which does the same thing as <code>Vec::new</code>, but with an important difference:
it pre-allocates space in the vector. Because we know that we need to store
<code>size</code> elements in the vector, doing this allocation up-front is slightly more
efficient than using <code>Vec::new</code>, which resizes itself as elements get inserted.</p>
<p>If you run <code>cargo check</code> again, you’ll get a few more warnings, but it should
succeed.</p>
<a class="header" href="print.html#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread" id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"><h4>A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</h4></a>
<!-- I wasn't sure what this next paragraph was relevant to, can you connect it
up more clearly?-->
<!-- This is where we're actually getting into the meat of the implementation,
I've tried to make it clearer :( /Carol-->
<p>We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of
threads. How do we actually create threads? This is a tough question. The way
to create a thread provided by the standard library, <code>thread::spawn</code>, expects
to get some code that the thread should run as soon as the thread is created.
However, we want to start up the threads and have them wait for code that we
will send them later. The standard library’s implementation of threads doesn’t
include any way to do that; we have to implement it.</p>
<!-- Can you say how doing this refactoring will improve the code -- why don't
we want the pool to store threads directly? (I got that from the listing
caption because I wasn't sure what the end game was) -->
<!-- I hope the end game is now clearer in the previous paragraph: we *can't*
store the threads directly and get the behavior we want. /Carol -->
<p>The way we’re going to implement the behavior of creating threads and sending
code later is to introduce a new data structure between the <code>ThreadPool</code> and
the threads that will manage this new behavior. We’re going to call this data
structure <code>Worker</code>; this is a common term in pooling implementations. Think of
people working in the kitchen at a restaurant: the workers wait until orders
come in from customers, then they’re responsible for taking those orders and
fulfilling them.</p>
<!-- I was unclear on what a worker actually is here -- is this a
programming/Rust term, or just what we're calling the struct? Can you make it
clearer what the worker is and its responsibilities? -->
<!-- I've tried in the previous paragraph; it's a common term in job
queue/pooling implementations in programming in general but I think should make
sense in plain English with the real-life metaphor I've added /Carol -->
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,
we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single
<code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will
take a closure of code to run and send it to the already-running thread for
execution. We’ll also give each worker an <code>id</code> so we can tell the different
workers in the pool apart when logging or debugging.</p>
<p>First, let’s make these changes to what happens when we create a <code>ThreadPool</code>.
We’ll implement the code that sends the closure to the thread after we have
<code>Worker</code> set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code></li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance that holds the allocated <code>id</code> and a thread spawned with an
empty closure</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector</li>
</ol>
<p>If you’re up for a challenge, try implementing these changes on your own before
taking a look at the code in Listing 20-15.</p>
<p>Ready? Here’s Listing 20-15 with one way to make these modifications:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>
instances instead of holding threads directly</span></p>
<p>We’ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>
because it’s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>
instances. We use the counter in the <code>for</code> loop as an argument to
<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>External code (like our server in <em>src/bin/main.rs</em>) doesn’t need to know the
implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,
so we make the <code>Worker</code> struct and its <code>new</code> function private. The
<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>
instance that’s created by spawning a new thread using an empty closure.</p>
<p>This code will compile and and will store the number of <code>Worker</code> instances we
specified as an argument to <code>ThreadPool::new</code>, but we’re <em>still</em> not processing
the closure that we get in <code>execute</code>. Let’s talk about how to do that next.</p>
<a class="header" href="print.html#sending-requests-to-threads-via-channels" id="sending-requests-to-threads-via-channels"><h4>Sending Requests to Threads Via Channels</h4></a>
<p>The next problem to tackle is that the closures given to <code>thread::spawn</code> do
absolutely nothing. Currently, we get the closure we want to execute in the
<code>execute</code> method, but we need to give <code>thread::spawn</code> a closure to run when we
create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch code to run from a
queue held in the <code>ThreadPool</code>, and send that code to its thread to run.</p>
<p>In Chapter 16, we learned about <em>channels</em>---a simple way to communicate
between two threads---that would be perfect for this use-case. We’ll use a
channel to function as the queue of jobs, and <code>execute</code> will send a job from
the <code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its
thread. Here’s the plan:</p>
<ol>
<li><code>ThreadPool</code> will create a channel and hold on to the sending side of the
channel.</li>
<li>Each <code>Worker</code> will hold on to the receiving side of the channel.</li>
<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send
down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute down the sending
side of the channel.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiving side of the channel
and execute the closures of any jobs it receives.</li>
</ol>
<p>Let’s start by creating a channel in <code>ThreadPool::new</code> and holding the sending
side in the <code>ThreadPool</code> instance, as shown in Listing 20-16. <code>Job</code> is a struct
that doesn’t hold anything for now, but will be the type of item we’re sending
down the channel:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}
#
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
# impl Worker {
#     fn new(id: usize) -&gt; Worker {
#         let thread = thread::spawn(|| {});
#
#         Worker {
#             id,
#             thread,
#         }
#     }
# }
#}</code></pre></pre>
<p><span class="caption">Listing 20-16: Modifying <code>ThreadPool</code> to store the
sending end of a channel that sends <code>Job</code> instances</span></p>
<p>In <code>ThreadPool::new</code>, we create our new channel, and have the pool hold the
sending end. This will successfully compile, still with warnings.</p>
<p>Let’s try passing a receiving end of the channel into each worker as the thread
pool creates them. We know we want to use the receiving end in the thread that
the workers spawn, so we’re going to reference the <code>receiver</code> parameter in the
closure. The code shown here in Listing 20-17 won’t quite compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span></p>
<p>These are small and straightforward changes: we pass the receiving end of the
channel into <code>Worker::new</code>, and then we use it inside of the closure.</p>
<p>If we try to check this, we get this error:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This
won’t work, as we recall from Chapter 16: the channel implementation provided
by Rust is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t just
clone the consuming end of the channel to fix this. Even if we could, that’s
not the technique we’d want to use; we want to distribute the jobs across
threads by sharing the single <code>receiver</code> between all of the workers.</p>
<!-- Above - you may be able to tell I struggled to follow this explanation,
can you double check my edits and correct here? -->
<!-- Yep, the text we had here was nonsensical. The edits are fine! /Carol -->
<p>Additionally, taking a job off the channel queue involves mutating the
<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>,
otherwise we might get race conditions (as covered in Chapter 16).</p>
<p>Remembering the thread-safe smart pointers that we discussed in Chapter 16, in
order to share ownership across multiple threads and allow the threads to
mutate the value, we need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. <code>Arc</code> will let multiple
workers own the receiver, and <code>Mutex</code> will make sure that only one worker is
getting a job from the receiver at a time. Listing 20-18 shows the changes we
need to make:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

// --snip--

# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# struct Job;
#
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // --snip--
}

# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
#         let thread = thread::spawn(|| {
#            receiver;
#         });
#
#         Worker {
#             id,
#             thread,
#         }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-18: Sharing the receiving end of the channel
between the workers using <code>Arc</code> and <code>Mutex</code></span></p>
<p>In <code>ThreadPool::new</code>, we put the receiving end of the channel in an <code>Arc</code> and a
<code>Mutex</code>. For each new worker, we clone the <code>Arc</code> to bump the reference count so
the workers can share ownership of the receiving end.</p>
<p>With these changes, the code compiles! We’re getting there!</p>
<a class="header" href="print.html#implementing-the-execute-method" id="implementing-the-execute-method"><h4>Implementing the <code>execute</code> Method</h4></a>
<p>Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’re also going
to change <code>Job</code> from a struct to a type alias for a trait object that holds the
type of closure that <code>execute</code> receives. As we discussed in the “Type Aliases
Create Type Synonyms” section of Chapter 19, type aliases allow us to make long
types shorter. Take a look at Listing 20-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// --snip--
# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# use std::sync::mpsc;
# struct Worker {}

type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
#}</code></pre></pre>
<p><span class="caption">Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>
that holds each closure, then sending the job down the channel</span></p>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we
send that job down the sending end of the channel. We’re calling <code>unwrap</code> on
<code>send</code> for the case that sending fails, which might happen if, for example, we
stop all of our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, though, we can’t stop our threads
executing; our threads continue executing as long as the pool exists. The
reason we use <code>unwrap</code>, then, is that we we know the failure case won’t happen
but the compiler can’t tell that.</p>
<p>But we’re not quite done yet! In the worker, our closure being passed to
<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job, and running the job when it gets one. Let’s make the change
shown in Listing 20-20 to <code>Worker::new</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker’s thread</span></p>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, then
<code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex is in
a <em>poisoned</em> state, which can happen if some other thread panicked while
holding the lock, rather than releasing the lock. In this situation, calling
<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to
change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to
you if you’d like.</p>
<p>If we get the lock on the mutex, then we call <code>recv</code> to receive a <code>Job</code> from
the channel. A final <code>unwrap</code> moves past any errors here as well, which might
occur if the thread holding the sending side of the channel has shut down,
similar to how the <code>send</code> method returns <code>Err</code> if the receiving side shuts down.</p>
<p>The call to <code>recv</code> <em>blocks</em>, so if there’s no job yet, the current thread will
sit until a job becomes available. The <code>Mutex&lt;T&gt;</code> makes sure that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p>Theoretically, this code should compile. Unfortunately, the Rust compiler isn’t
perfect yet, and we get this error:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<p>This error is fairly cryptic, and that’s because the problem is fairly cryptic.
In order to call a <code>FnOnce</code> closure that is stored in a <code>Box&lt;T&gt;</code> (which is what
our <code>Job</code> type alias is), the closure needs to be able to move itself <em>out</em> of
the <code>Box&lt;T&gt;</code> because the closure takes ownership of <code>self</code> when we call it. In
general, Rust doesn’t allow us to move value out of a <code>Box&lt;T&gt;</code> because Rust
doesn’t know how big the value inside the <code>Box&lt;T&gt;</code> is going to be; recall in
Chapter 15 that we used <code>Box&lt;T&gt;</code> precisely because we had something of an
unknown size that we wanted to store in a <code>Box&lt;T&gt;</code> to get a value of a known
size.</p>
<p>We saw in Chapter 17, Listing 17-15 that we can write methods that use the
syntax <code>self: Box&lt;Self&gt;</code>, which allows the method to take ownership of a <code>Self</code>
value stored in a <code>Box&lt;T&gt;</code>. That’s exactly what we want to do here, but
unfortunately Rust won’t let us: the part of Rust that implements behavior when
a closure is called isn’t implemented using <code>self: Box&lt;Self&gt;</code>. So Rust doesn’t
yet understand that it could use <code>self: Box&lt;Self&gt;</code> in this situation in order
to take ownership of the closure and move the closure out of the <code>Box&lt;T&gt;</code>.</p>
<p>Rust is still a work in progress with places that the compiler could be
improved, but in the future, the code in Listing 20-20 should work just fine.
There are people just like you working to fix this and other issues! Once
you’ve finished the book, we would love for you to join in.</p>
<p>But for now, let’s work around this problem with a handy trick. We can tell
Rust explicitly that in this case we can take ownership of the value inside the
<code>Box&lt;T&gt;</code> using <code>self: Box&lt;Self&gt;</code>, and once we have ownership of the closure, we
can call it. This involves defining a new trait <code>FnBox</code> with the method
<code>call_box</code> that will use <code>self: Box&lt;Self&gt;</code> in its signature, defining <code>FnBox</code>
for any type that implements <code>FnOnce()</code>, changing our type alias to use the new
trait, and changing <code>Worker</code> to use the <code>call_box</code> method. These changes are
shown in Listing 20-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-21: Adding a new trait <code>FnBox</code> to work around
the current limitations of <code>Box&lt;FnOnce()&gt;</code></span></p>
<p>First, we create a new trait named <code>FnBox</code>. This trait has the one method
<code>call_box</code>, which is similar to the <code>call</code> methods on the other <code>Fn*</code> traits
except that it takes <code>self: Box&lt;Self&gt;</code> in order to take ownership of <code>self</code> and
move the value out of the <code>Box&lt;T&gt;</code>.</p>
<p>Next, we implement the <code>FnBox</code> trait for any type <code>F</code> that implements the
<code>FnOnce()</code> trait. Effectively, this means that any <code>FnOnce()</code> closures can use
our <code>call_box</code> method. The implementation of <code>call_box</code> uses <code>(*self)()</code> to
move the closure out of the <code>Box&lt;T&gt;</code> and call the closure.</p>
<p>We now need our <code>Job</code> type alias to be a <code>Box</code> of anything that implements our
new trait <code>FnBox</code>. This will allow us to use <code>call_box</code> in <code>Worker</code> when we get
a <code>Job</code> value. Implementing the <code>FnBox</code> trait for any <code>FnOnce()</code> closure means
we don’t have to change anything about the actual values we’re sending down the
channel.</p>
<p>Finally, in the closure run in the thread in <code>Worker::new</code>, we use <code>call_box</code>
instead of invoking the closure directly. Now Rust is able to understand that
what we want to do is fine.</p>
<p>This is a very sneaky, complicated trick. Don’t worry too much if it doesn’t
make perfect sense; someday, it will be completely unnecessary.</p>
<p>With this trick, our thread pool is in a working state! Give it a <code>cargo run</code>,
and make some requests:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
     Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool executing connections asynchronously. There
are never more than four threads created, so our system won’t get overloaded if
the server receives a lot of requests. If we make a request to <code>/sleep</code>, the
server will be able to serve other requests by having another thread run them.</p>
<p>After learning about the <code>while let</code> loop in Chapter 18, you might be
wondering why we didn’t write the worker thread like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-22: An alternative implementation of
<code>Worker::new</code> using <code>while let</code></span></p>
<p>This code compiles and runs, but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason why is somewhat subtle: the <code>Mutex</code> struct has no public
<code>unlock</code> method because the ownership of the lock is based on the lifetime of
the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>
method returns. This allows the borrow checker to enforce at compile time that
we never access a resource guarded by a <code>Mutex</code> without holding the lock, but
it can also result in holding the lock longer than intended if we don’t think
carefully about the lifetime of the <code>MutexGuard&lt;T&gt;</code>. Because the values in the
the <code>while</code> expression remain in scope for the duration of the block, the lock
remains held for the duration of the call to <code>job.call_box()</code>, meaning other
workers cannot receive jobs.</p>
<p>By using <code>loop</code> instead and acquiring the lock and a job within the block
rather than outside it, the <code>MutexGuard</code> returned from the <code>lock</code> method is
dropped as soon as the <code>let job</code> statement ends. This ensures that the lock is
held during the call to <code>recv</code>, but it is released before the call to
<code>job.call_box()</code>, allowing multiple requests to be serviced concurrently.</p>
<a class="header" href="print.html#graceful-shutdown-and-cleanup" id="graceful-shutdown-and-cleanup"><h2>Graceful Shutdown and Cleanup</h2></a>
<p>The code in Listing 20-21 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the <code>workers</code>,
<code>id</code>, and <code>thread</code> fields that we’re not using in a direct way that reminds us
we’re not cleaning anything up. When we use the less elegant <span
class="keystroke">ctrl-C</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they’re in the middle of
serving a request.</p>
<p>We’re now going to implement the <code>Drop</code> trait to call <code>join</code> on each of the
threads in the pool so they can finish the requests they’re working on before
closing. Then we’ll implement a way to tell the threads they should stop
accepting new requests and shut down. To see this code in action, we’ll modify
our server to only accept two requests before gracefully shutting down its
thread pool.</p>
<a class="header" href="print.html#implementing-the-drop-trait-on-threadpool" id="implementing-the-drop-trait-on-threadpool"><h3>Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></h3></a>
<p>Let’s start with implementing <code>Drop</code> for our thread pool. When the pool is
dropped, our threads should all join on to make sure they finish their work.
Listing 20-23 shows a first attempt at a <code>Drop</code> implementation; this code won’t
quite work yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-23: Joining each thread when the thread pool
goes out of scope</span></p>
<p>First we loop through each of the thread pool <code>workers</code>. We use <code>&amp;mut</code> for this
because <code>self</code> is itself a mutable reference and we also need to be able to
mutate <code>worker</code>. For each worker, we print a message saying that this
particular worker is shutting down, and then we call <code>join</code> on that worker’s
thread. If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust panic and go
into an ungraceful shutdown.</p>
<p>Here’s the error we get if we compile this code:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>This tells use we can’t call <code>join</code> because we only have a mutable borrow of
each <code>worker</code>, and <code>join</code> takes ownership of its argument. In order to solve
this, we need a way to move the thread out of the <code>Worker</code> instance that owns
<code>thread</code> so that <code>join</code> can consume the thread. We saw a way to do this in
Listing 17-15: if <code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;</code> instead, we
can call the <code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code>
variant and leave a <code>None</code> variant in its place. In other words, a <code>Worker</code>
that is running will have a <code>Some</code> variant in <code>thread</code>, and when we want to
clean up a worker, we’ll replace <code>Some</code> with <code>None</code> so the worker doesn’t have
a thread to run.</p>
<p>So we know we want to update the definition of <code>Worker</code> like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
#}</code></pre></pre>
<p>Now let’s lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>Let’s address the second error, which points to the code at the end of
<code>Worker::new</code>; we need to wrap the <code>thread</code> value in <code>Some</code> when we create a
new <code>Worker</code>. Make the following changes to fix this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>The first error is in our <code>Drop</code> implementation. We mentioned earlier that we
intended to call <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>.
The following changes will do so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>As we saw in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code> variant
out and leaves <code>None</code> in its place. We’re using <code>if let</code> to destructure the
<code>Some</code> and get the thread, then we call <code>join</code> on the thread. If a worker’s
thread is already <code>None</code>, we know that worker has already had its thread
cleaned up, so nothing happens in that case.</p>
<a class="header" href="print.html#signaling-to-the-threads-to-stop-listening-for-jobs" id="signaling-to-the-threads-to-stop-listening-for-jobs"><h3>Signaling to the Threads to Stop Listening for Jobs</h3></a>
<p>With this, our code compiles without any warnings. Bad news though, this code
doesn’t function the way we want it to yet. The key is the logic in the
closures run by the threads of the <code>Worker</code> instances: at the moment we call
<code>join</code>, but that won’t shut down the threads because they <code>loop</code> forever looking
for jobs. If we try to drop our <code>ThreadPool</code> with this implementation, the main
thread will block forever waiting for the first thread to finish.</p>
<p>To fix this, we’re going to modify the threads so they listen for either a
<code>Job</code> to run or a signal that they should stop listening and exit the infinite
loop. Instead of <code>Job</code> instances, then, our channel will send one of these two
enum variants:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Job;
enum Message {
    NewJob(Job),
    Terminate,
}
#}</code></pre></pre>
<p>This <code>Message</code> enum will either be a <code>NewJob</code> variant that holds the <code>Job</code> the
thread should run, or it will be a <code>Terminate</code> variant that will cause the
thread to exit its loop and stop.</p>
<p>We need to adjust the channel to use values of type <code>Message</code> rather than type
<code>Job</code>, as shown in Listing 20-24:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-24: Sending and receiving <code>Message</code> values and
exiting the loop if a <code>Worker</code> receives <code>Message::Terminate</code></span></p>
<p>To incorporate the <code>Message</code> enum we need to change <code>Job</code> to <code>Message</code> in two
places: the definition of <code>ThreadPool</code> and the signature of <code>Worker::new</code>. The
<code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped in the
<code>Message::NewJob</code> variant. Then, in <code>Worker::new</code> where a <code>Message</code> is received
from the channel, the job will be processed if the <code>NewJob</code> variant is
received, and the thread will break out of the loop if the <code>Terminate</code> variant
is received.</p>
<p>With these changes, the code will compile and continue to function in the same
way as it has been. We will get a warning, though, because we aren’t creating
any messages of the <code>Terminate</code> variety. Let’s fix this by changing our <code>Drop</code>
implementation to look like Listing 20-25:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-25: Sending <code>Message::Terminate</code> to the
workers before calling <code>join</code> on each worker thread</span></p>
<p>We’re now iterating over the workers twice, once to send one <code>Terminate</code>
message for each worker, and once to call <code>join</code> on each worker’s thread. If we
tried to send a message and <code>join</code> immediately in the same loop, we couldn’t
guarantee that the worker in the current iteration would be the one to get the
message from the channel.</p>
<p>To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and <code>join</code>
called on the first worker’s thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We’d be left waiting on the first worker to
shut down, but it never will because the second thread picked up the terminate
message. Deadlock!</p>
<p>To prevent this, we first put all of our <code>Terminate</code> messages on the channel in
one loop, and then we join on all the threads in another loop. Each worker will
stop receiving requests on the channel once it gets a terminate message,
meaning we can be sure that if we send the same number of terminate messages as
there are workers, each worker will receive a terminate message before <code>join</code>
is called on its thread.</p>
<p>In order to see this code in action, let’s modify <code>main</code> to only accept two
requests before gracefully shutting the server down as shown in Listing 20-26:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<p><span class="caption">Listing 20-26: Shut down the server after serving two
requests by exiting the loop</span></p>
<p>You wouldn’t want a real-world web server to shut down after serving only two
requests, this just demonstrates the graceful shutdown and cleanup in working
order.</p>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait, and limits the iteration
to the first 2 items at most. The <code>ThreadPool</code> will go out of scope at the end
of <code>main</code>, and we’ll see the <code>drop</code> implementation run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output that looks similar to
this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You may see a different ordering of workers and messages printed. We can see
how this works from the messages: workers zero and three got the first two
requests, and then on the third request the server stopped accepting
connections. When the <code>ThreadPool</code> goes out of scope at the end of <code>main</code>, its
<code>Drop</code> implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls <code>join</code> to shut down each worker thread.</p>
<p>One interesting aspect of this particular execution: notice that the
<code>ThreadPool</code> sent the terminate messages down the channel, and before any
worker received the messages, we tried to join worker 0. Worker 0 had not yet
gotten the terminate message, so the main thread blocked waiting for worker 0
to finish. In the meantime, each of the workers received the termination
messages. Once worker 0 finished, the main thread waited for the rest of the
workers to finish, and they had all received the termination message and were
able to shut down at that point.</p>
<p>Congrats! We have now completed our project, and we have a basic web server
that uses a thread pool to respond asynchronously. We’re able to perform a
graceful shutdown of the server, which cleans up all the threads in the pool.
Here’s the full code for reference:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
#}</code></pre></pre>
<p>There’s more we could do here! If you’d like to continue enhancing this
project, here are some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods</li>
<li>Add tests of the library’s functionality</li>
<li>Change calls to <code>unwrap</code> to more robust error handling</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests</li>
<li>Find a thread pool crate on crates.io and implement a similar web server
using the crate instead and compare its API and robustness to the thread pool
we implemented</li>
</ul>
<a class="header" href="print.html#summary-15" id="summary-15"><h2>Summary</h2></a>
<p>Well done! You’ve made it to the end of the book! We’d like to thank you for
joining us on this tour of Rust. You’re now ready to go out and implement your
own Rust projects and help with other people’s. Remember there’s a community of
other Rustaceans who would love to help you with any challenges you encounter
on your Rust journey.</p>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<p>The following sections contain reference material you may find useful in your
Rust journey.</p>
<a class="header" href="print.html#Ключові-слова-1" id="Ключові-слова-1"><h2>Ключові слова</h2></a>
<p>Наступні ключові слова зарезервовано мовою Rust і не можуть бути використані як назва функцій, змінних, макросів, модулів, крейтов (пакетов), констант, статичних значень, атрибутів, полів структур або параметрів.</p>
<ul>
<li><code>abstract</code></li>
<li><code>alignof</code></li>
<li><code>as</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>break</code></li>
<li><code>const</code></li>
<li><code>continue</code></li>
<li><code>crate</code></li>
<li><code>do</code></li>
<li><code>else</code></li>
<li><code>enum</code></li>
<li><code>extern</code></li>
<li><code>false</code></li>
<li><code>final</code></li>
<li><code>fn</code></li>
<li><code>for</code></li>
<li><code>if</code></li>
<li><code>impl</code></li>
<li><code>in</code></li>
<li><code>let</code></li>
<li><code>loop</code></li>
<li><code>macro</code></li>
<li><code>match</code></li>
<li><code>mod</code></li>
<li><code>move</code></li>
<li><code>mut</code></li>
<li><code>offsetof</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>proc</code></li>
<li><code>pub</code></li>
<li><code>pure</code></li>
<li><code>ref</code></li>
<li><code>return</code></li>
<li><code>Self</code></li>
<li><code>self</code></li>
<li><code>sizeof</code></li>
<li><code>static</code></li>
<li><code>struct</code></li>
<li><code>super</code></li>
<li><code>trait</code></li>
<li><code>true</code></li>
<li><code>type</code></li>
<li><code>typeof</code></li>
<li><code>unsafe</code></li>
<li><code>unsized</code></li>
<li><code>use</code></li>
<li><code>virtual</code></li>
<li><code>where</code></li>
<li><code>while</code></li>
<li><code>yield</code></li>
</ul>
<a class="header" href="print.html#appendix-b-operators-and-symbols" id="appendix-b-operators-and-symbols"><h2>Appendix B: Operators and Symbols</h2></a>
<a class="header" href="print.html#operators" id="operators"><h3>Operators</h3></a>
<p>The following lists the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.</p>
<ul>
<li><code>!</code> (<code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>): denotes macro expansion.</li>
<li><code>!</code> (<code>!expr</code>): bitwise or logical complement. Overloadable (<code>Not</code>).</li>
<li><code>!=</code> (<code>var != expr</code>): nonequality comparison. Overloadable (<code>PartialEq</code>).</li>
<li><code>%</code> (<code>expr % expr</code>): arithmetic remainder. Overloadable (<code>Rem</code>).</li>
<li><code>%=</code> (<code>var %= expr</code>): arithmetic remainder and assignment. Overloadable (<code>RemAssign</code>).</li>
<li><code>&amp;</code> (<code>&amp;expr</code>, <code>&amp;mut expr</code>): borrow.</li>
<li><code>&amp;</code> (<code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code>): borrowed pointer type.</li>
<li><code>&amp;</code> (<code>expr &amp; expr</code>): bitwise AND. Overloadable (<code>BitAnd</code>).</li>
<li><code>&amp;=</code> (<code>var &amp;= expr</code>): bitwise AND and assignment. Overloadable (<code>BitAndAssign</code>).</li>
<li><code>&amp;&amp;</code> (<code>expr &amp;&amp; expr</code>): logical AND.</li>
<li><code>*</code> (<code>expr * expr</code>): arithmetic multiplication. Overloadable (<code>Mul</code>).</li>
<li><code>*</code> (<code>*expr</code>): dereference.</li>
<li><code>*</code> (<code>*const type</code>, <code>*mut type</code>): raw pointer.</li>
<li><code>*=</code> (<code>var *= expr</code>): arithmetic multiplication and assignment. Overloadable (<code>MulAssign</code>).</li>
<li><code>+</code> (<code>trait + trait</code>, <code>'a + trait</code>): compound type constraint.</li>
<li><code>+</code> (<code>expr + expr</code>): arithmetic addition. Overloadable (<code>Add</code>).</li>
<li><code>+=</code> (<code>var += expr</code>): arithmetic addition and assignment. Overloadable (<code>AddAssign</code>).</li>
<li><code>,</code>: argument and element separator.</li>
<li><code>-</code> (<code>- expr</code>): arithmetic negation. Overloadable (<code>Neg</code>).</li>
<li><code>-</code> (<code>expr - expr</code>): arithmetic subtraction. Overloadable (<code>Sub</code>).</li>
<li><code>-=</code> (<code>var -= expr</code>): arithmetic subtraction and assignment. Overloadable (<code>SubAssign</code>).</li>
<li><code>-&gt;</code> (<code>fn(…) -&gt; type</code>, <code>|…| -&gt; type</code>): function and closure return type.</li>
<li><code>.</code> (<code>expr.ident</code>): member access.</li>
<li><code>..</code> (<code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>): right-exclusive range literal.</li>
<li><code>..</code> (<code>..expr</code>): struct literal update syntax.</li>
<li><code>..</code> (<code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>): “and the rest” pattern binding.</li>
<li><code>...</code> (<code>...expr</code>, <code>expr...expr</code>) <em>in an expression</em>: inclusive range expression.</li>
<li><code>...</code> (<code>expr...expr</code>) <em>in a pattern</em>: inclusive range pattern.</li>
<li><code>/</code> (<code>expr / expr</code>): arithmetic division. Overloadable (<code>Div</code>).</li>
<li><code>/=</code> (<code>var /= expr</code>): arithmetic division and assignment. Overloadable (<code>DivAssign</code>).</li>
<li><code>:</code> (<code>pat: type</code>, <code>ident: type</code>): constraints.</li>
<li><code>:</code> (<code>ident: expr</code>): struct field initializer.</li>
<li><code>:</code> (<code>'a: loop {…}</code>): loop label.</li>
<li><code>;</code>: statement and item terminator.</li>
<li><code>;</code> (<code>[…; len]</code>): part of fixed-size array syntax</li>
<li><code>&lt;&lt;</code> (<code>expr &lt;&lt; expr</code>): left-shift. Overloadable (<code>Shl</code>).</li>
<li><code>&lt;&lt;=</code> (<code>var &lt;&lt;= expr</code>): left-shift and assignment. Overloadable (<code>ShlAssign</code>).</li>
<li><code>&lt;</code> (<code>expr &lt; expr</code>): less-than comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>&lt;=</code> (<code>expr &lt;= expr</code>): less-than or equal-to comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>=</code> (<code>var = expr</code>, <code>ident = type</code>): assignment/equivalence.</li>
<li><code>==</code> (<code>expr == expr</code>): equality comparison. Overloadable (<code>PartialEq</code>).</li>
<li><code>=&gt;</code> (<code>pat =&gt; expr</code>): part of match arm syntax.</li>
<li><code>&gt;</code> (<code>expr &gt; expr</code>): greater-than comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;=</code> (<code>expr &gt;= expr</code>): greater-than or equal-to comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;&gt;</code> (<code>expr &gt;&gt; expr</code>): right-shift. Overloadable (<code>Shr</code>).</li>
<li><code>&gt;&gt;=</code> (<code>var &gt;&gt;= expr</code>): right-shift and assignment. Overloadable (<code>ShrAssign</code>).</li>
<li><code>@</code> (<code>ident @ pat</code>): pattern binding.</li>
<li><code>^</code> (<code>expr ^ expr</code>): bitwise exclusive OR. Overloadable (<code>BitXor</code>).</li>
<li><code>^=</code> (<code>var ^= expr</code>): bitwise exclusive OR and assignment. Overloadable (<code>BitXorAssign</code>).</li>
<li><code>|</code> (<code>pat | pat</code>): pattern alternatives.</li>
<li><code>|</code> (<code>|…| expr</code>): closures.</li>
<li><code>|</code> (<code>expr | expr</code>): bitwise OR. Overloadable (<code>BitOr</code>).</li>
<li><code>|=</code> (<code>var |= expr</code>): bitwise OR and assignment. Overloadable (<code>BitOrAssign</code>).</li>
<li><code>||</code> (<code>expr || expr</code>): logical OR.</li>
<li><code>_</code>: “ignored” pattern binding. Also used to make integer-literals readable.</li>
<li><code>?</code> (<code>expr?</code>): Error propagation.</li>
</ul>
<a class="header" href="print.html#non-operator-symbols" id="non-operator-symbols"><h3>Non-operator Symbols</h3></a>
<a class="header" href="print.html#standalone-syntax" id="standalone-syntax"><h4>Standalone Syntax</h4></a>
<ul>
<li><code>'ident</code>: named lifetime or loop label</li>
<li><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, <em>etc.</em>: numeric literal of specific type.</li>
<li><code>&quot;…&quot;</code>: string literal.</li>
<li><code>r&quot;…&quot;</code>, <code>r#&quot;…&quot;#</code>, <code>r##&quot;…&quot;##</code>, <em>etc.</em>: raw string literal, escape characters are not processed.</li>
<li><code>b&quot;…&quot;</code>: byte string literal, constructs a <code>[u8]</code> instead of a string.</li>
<li><code>br&quot;…&quot;</code>, <code>br#&quot;…&quot;#</code>, <code>br##&quot;…&quot;##</code>, <em>etc.</em>: raw byte string literal, combination of raw and byte string literal.</li>
<li><code>'…'</code>: character literal.</li>
<li><code>b'…'</code>: ASCII byte literal.</li>
<li><code>|…| expr</code>: closure.</li>
<li><code>!</code>: always empty bottom type for diverging functions.</li>
</ul>
<a class="header" href="print.html#path-related-syntax" id="path-related-syntax"><h4>Path-related Syntax</h4></a>
<ul>
<li><code>ident::ident</code>: namespace path.</li>
<li><code>::path</code>: path relative to the crate root (<em>i.e.</em> an explicitly absolute path).</li>
<li><code>self::path</code>: path relative to the current module (<em>i.e.</em> an explicitly relative path).</li>
<li><code>super::path</code>: path relative to the parent of the current module.</li>
<li><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code>: associated constants, functions, and types.</li>
<li><code>&lt;type&gt;::…</code>: associated item for a type which cannot be directly named (<em>e.g.</em> <code>&lt;&amp;T&gt;::…</code>, <code>&lt;[T]&gt;::…</code>, <em>etc.</em>).</li>
<li><code>trait::method(…)</code>: disambiguating a method call by naming the trait which defines it.</li>
<li><code>type::method(…)</code>: disambiguating a method call by naming the type for which it’s defined.</li>
<li><code>&lt;type as trait&gt;::method(…)</code>: disambiguating a method call by naming the trait <em>and</em> type.</li>
</ul>
<a class="header" href="print.html#generics" id="generics"><h4>Generics</h4></a>
<ul>
<li><code>path&lt;…&gt;</code> (<em>e.g.</em> <code>Vec&lt;u8&gt;</code>): specifies parameters to generic type <em>in a type</em>.</li>
<li><code>path::&lt;…&gt;</code>, <code>method::&lt;…&gt;</code> (<em>e.g.</em> <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>): specifies parameters to generic type, function, or method <em>in an expression</em>. Often referred to as <em>turbofish</em>.</li>
<li><code>fn ident&lt;…&gt; …</code>: define generic function.</li>
<li><code>struct ident&lt;…&gt; …</code>: define generic structure.</li>
<li><code>enum ident&lt;…&gt; …</code>: define generic enumeration.</li>
<li><code>impl&lt;…&gt; …</code>: define generic implementation.</li>
<li><code>for&lt;…&gt; type</code>: higher-ranked lifetime bounds.</li>
<li><code>type&lt;ident=type&gt;</code> (<em>e.g.</em> <code>Iterator&lt;Item=T&gt;</code>): a generic type where one or more associated types have specific assignments.</li>
</ul>
<a class="header" href="print.html#trait-bound-constraints" id="trait-bound-constraints"><h4>Trait Bound Constraints</h4></a>
<ul>
<li><code>T: U</code>: generic parameter <code>T</code> constrained to types that implement <code>U</code>.</li>
<li><code>T: 'a</code>: generic type <code>T</code> must outlive lifetime <code>'a</code>. When we say that a type ‘outlives’ the lifetime, we mean that it cannot transitively contain any references with lifetimes shorter than <code>'a</code>.</li>
<li><code>T : 'static</code>: The generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones.</li>
<li><code>'b: 'a</code>: generic lifetime <code>'b</code> must outlive lifetime <code>'a</code>.</li>
<li><code>T: ?Sized</code>: allow generic type parameter to be a dynamically-sized type.</li>
<li><code>'a + trait</code>, <code>trait + trait</code>: compound type constraint.</li>
</ul>
<a class="header" href="print.html#macros-and-attributes" id="macros-and-attributes"><h4>Macros and Attributes</h4></a>
<ul>
<li><code>#[meta]</code>: outer attribute.</li>
<li><code>#![meta]</code>: inner attribute.</li>
<li><code>$ident</code>: macro substitution.</li>
<li><code>$ident:kind</code>: macro capture.</li>
<li><code>$(…)…</code>: macro repetition.</li>
</ul>
<a class="header" href="print.html#comments" id="comments"><h4>Comments</h4></a>
<ul>
<li><code>//</code>: line comment.</li>
<li><code>//!</code>: inner line doc comment.</li>
<li><code>///</code>: outer line doc comment.</li>
<li><code>/*…*/</code>: block comment.</li>
<li><code>/*!…*/</code>: inner block doc comment.</li>
<li><code>/**…*/</code>: outer block doc comment.</li>
</ul>
<a class="header" href="print.html#tuples" id="tuples"><h4>Tuples</h4></a>
<ul>
<li><code>()</code>: empty tuple (<em>a.k.a.</em> unit), both literal and type.</li>
<li><code>(expr)</code>: parenthesized expression.</li>
<li><code>(expr,)</code>: single-element tuple expression.</li>
<li><code>(type,)</code>: single-element tuple type.</li>
<li><code>(expr, …)</code>: tuple expression.</li>
<li><code>(type, …)</code>: tuple type.</li>
<li><code>expr(expr, …)</code>: function call expression. Also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants.</li>
<li><code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>: macro invocation.</li>
<li><code>expr.0</code>, <code>expr.1</code>, …: tuple indexing.</li>
</ul>
<a class="header" href="print.html#curly-brackets" id="curly-brackets"><h4>Curly Brackets</h4></a>
<ul>
<li><code>{…}</code>: block expression.</li>
<li><code>Type {…}</code>: <code>struct</code> literal.</li>
</ul>
<a class="header" href="print.html#square-brackets" id="square-brackets"><h4>Square Brackets</h4></a>
<ul>
<li><code>[…]</code>: array literal.</li>
<li><code>[expr; len]</code>: array literal containing <code>len</code> copies of <code>expr</code>.</li>
<li><code>[type; len]</code>: array type containing <code>len</code> instances of <code>type</code>.</li>
<li><code>expr[expr]</code>: collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>).</li>
<li><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>: collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, <code>RangeFull</code> as the “index”.</li>
</ul>
<a class="header" href="print.html#c---derivable-traits" id="c---derivable-traits"><h1>C - Derivable Traits</h1></a>
<p>In various places in the book, we discussed the <code>derive</code> attribute that is
applied to a struct or enum. This attribute generates code that implements a
trait on the annotated type with a default implementation. In this example, the
<code>#[derive(Debug)]</code> attribute implements the <code>Debug</code> trait for the <code>Point</code>
struct:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}
#}</code></pre></pre>
<p>The code that the compiler generates for the implementation of <code>Debug</code> is
similar to this code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
impl ::std::fmt::Debug for Point {
    fn fmt(&amp;self, __arg_0: &amp;mut ::std::fmt::Formatter) -&gt; ::std::fmt::Result {
        match *self {
            Point { x: ref __self_0_0, y: ref __self_0_1 } =&gt; {
                let mut builder = __arg_0.debug_struct(&quot;Point&quot;);
                let _ = builder.field(&quot;x&quot;, &amp;&amp;(*__self_0_0));
                let _ = builder.field(&quot;y&quot;, &amp;&amp;(*__self_0_1));
                builder.finish()
            }
        }
    }
}
#}</code></pre></pre>
<p>The generated code implements sensible default behavior for the <code>Debug</code> trait’s
<code>fmt</code> function: a <code>match</code> expression destructures a <code>Point</code> instance into its
field values. Then it builds up a string containing the struct’s name and each
field’s name and value. This means we’re able to use debug formatting on a
<code>Point</code> instance to see what value each field has.</p>
<p>The generated code isn’t particularly easy to read because it’s only for the
compiler to consume, rather than for programmers to read! The <code>derive</code>
attribute and the default implementation of <code>Debug</code> has saved us all of the
work of writing this code for every struct or enum that we want to be able to
print using debug formatting.</p>
<p>The <code>derive</code> attribute has default implementations for the following traits
provided by the standard library. If you want different behavior than what the
<code>derive</code> attribute provides, consult the standard library documentation for
each trait for the details needed for manual implementation of the traits.</p>
<a class="header" href="print.html#standard-library-traits-that-can-be-derived" id="standard-library-traits-that-can-be-derived"><h2>Standard Library Traits that Can Be Derived</h2></a>
<p>The following sections list all of the traits in the standard library that can
be used with <code>derive</code>. Each section covers:</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you’re allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<a class="header" href="print.html#debug-for-programmer-output" id="debug-for-programmer-output"><h3><code>Debug</code> for Programmer Output</h3></a>
<p>The <code>Debug</code> trait enables debug formatting in format strings, indicated by
adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p>The <code>Debug</code> trait signifies that instances of a type may be printed by
programmers in order to debug their programs by inspecting an instance of a
type at a particular point in a program’s execution.</p>
<p>An example of when <code>Debug</code> is required is the <code>assert_eq!</code> macro, which prints
the values of the instances given as arguments if the equality assertion fails
so that programmers can see why the two instances weren’t equal.</p>
<a class="header" href="print.html#partialeq-and-eq-for-equality-comparisons" id="partialeq-and-eq-for-equality-comparisons"><h3><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons</h3></a>
<p>The <code>PartialEq</code> trait signifies that instances of a type can be compared to
each other for equality, and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When derived on structs, two
instances are equal if all fields are equal, and not equal if any fields are
not equal. When derived on enums, each variant is equal to itself and not equal
to the other variants.</p>
<p>An example of when <code>PartialEq</code> is required is the <code>assert_eq!</code> macro, which
needs to be able to compare two instances of a type for equality.</p>
<p>The <code>Eq</code> trait doesn’t have any methods. It only signals that for every value
of the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be
applied to types that also implement <code>PartialEq</code>. An example of types that
implements <code>PartialEq</code> but that cannot implement <code>Eq</code> are floating point number
types: the implementation of floating point numbers says that two instances of
the not-a-number value, <code>NaN</code>, are not equal to each other.</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap</code> so that the
<code>HashMap</code> can tell whether two keys are the same.</p>
<a class="header" href="print.html#partialord-and-ord-for-ordering-comparisons" id="partialord-and-ord-for-ordering-comparisons"><h3><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons</h3></a>
<p>The <code>PartialOrd</code> trait signifies that instances of a type can be compared to
each other to see which is larger than the other for sorting purposes. A type
that implements <code>PartialOrd</code> may be used with the <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>
operators. The <code>PartialOrd</code> trait can only be applied to types that also
implement <code>PartialEq</code>.</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an
<code>Option&lt;Ordering&gt;</code> that may be <code>None</code> if comparing the given values does not
produce an ordering. When derived on structs, two instances of the struct are
compared by comparing the value in each field in the order in which the fields
appear in the struct definition. When derived on enums, variants of the enum
declared earlier in the enum definition are greater than the variants listed
later.</p>
<p>An example of when <code>PartialOrd</code> is required is the <code>gen_range</code> method in the
<code>rand</code> crate that generates a random value in the range specified by a low
value and a high value.</p>
<p>The <code>Ord</code> trait signifies that for any two value of the annotated type, a valid
ordering exists. The <code>Ord</code> trait implements the <code>cmp</code> method, which returns an
<code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid ordering will
always be possible. The <code>Ord</code> trait can only be applied to types that also
implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When derived
on structs and enums, <code>cmp</code> behaves the same way as the derived implementation
for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>,
a data structure that stores data based on the sort order of the values.</p>
<a class="header" href="print.html#clone-and-copy-for-duplicating-values" id="clone-and-copy-for-duplicating-values"><h3><code>Clone</code> and <code>Copy</code> for Duplicating Values</h3></a>
<p>The <code>Clone</code> trait signifies there is a way to explicitly create a duplicate of
a value, and the duplication process might involve running arbitrary code.
Deriving <code>Clone</code> implements the <code>clone</code> method. When derived, the
implementation of <code>clone</code> for the whole type calls <code>clone</code> on each of the parts
of the type, so all of the fields or values in the type must also implement
<code>Clone</code> to derive <code>Clone</code>.</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a
slice containing instances of some type. The slice doesn’t own the instances
but the vector returned from <code>to_vec</code> will need to own its instances, so the
implementation of <code>to_vec</code> calls <code>clone</code> on each item. Thus, the type stored in
the slice must implement <code>Clone</code>.</p>
<p>The <code>Copy</code> trait signifies that a value can be duplicated by only copying bits;
no other code is necessary. The <code>Copy</code> trait does not define any methods to
prevent programmers from overloading those methods violating the assumption
that no arbitrary code is being run. You can derive <code>Copy</code> on any type whose
parts all implement <code>Copy</code>. The <code>Copy</code> trait can only be applied to types that
also implement <code>Clone</code>, as a type that implements <code>Copy</code> has a trivial
implementation of <code>Clone</code>, doing the same thing as <code>Copy</code>.</p>
<p><code>Copy</code> is rarely required; when types implement <code>Copy</code>, there are optimizations
that can be applied and the code becomes nicer because you don’t have to call
<code>clone</code>. Everything possible with <code>Copy</code> can also be accomplished with <code>Clone</code>,
but the code might be slower or have to use <code>clone</code> in places.</p>
<a class="header" href="print.html#hash-for-mapping-a-value-to-a-value-of-fixed-size" id="hash-for-mapping-a-value-to-a-value-of-fixed-size"><h3><code>Hash</code> for Mapping a Value to a Value of Fixed Size</h3></a>
<p>The <code>Hash</code> trait signifies there is a way to take an instance of a type that
takes up an arbitrary amount of size and map that instance to a value of fixed
size by using a hash function. Deriving <code>Hash</code> implements the <code>hash</code> method.
When derived, the implementation of <code>hash</code> for the whole type combines the
result of calling <code>hash</code> on each of the parts of the type, so all of the fields
or values in the type must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p>An example of when <code>Hash</code> is required is for keys in a <code>HashMap</code> so that the
<code>HashMap</code> can store data efficiently.</p>
<a class="header" href="print.html#default-for-default-values" id="default-for-default-values"><h3><code>Default</code> for Default Values</h3></a>
<p>The <code>Default</code> trait signifies there is a way to create a default value for a
type. Deriving <code>Default</code> implements the <code>default</code> method. When derived, the
implementation of <code>Default</code> for the whole type calls the <code>default</code> method on
each of the parts of the type, so all of the fields or values in the type must
also implement <code>Default</code> to derive <code>Default.</code></p>
<p>A common use of <code>Default::default</code> is in combination with the struct update
syntax discussed in the “Creating Instances From Other Instances With Struct
Update Syntax” section in Chapter 5. You can customize a few fields of a struct
and then use the default values for the rest by using <code>..Default::default()</code>.</p>
<p>An example of when <code>Default</code> is required is the <code>unwrap_or_default</code> method on
<code>Option&lt;T&gt;</code> instances. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the <code>unwrap_or_default</code>
method will return the result of <code>Default::default</code> for the type <code>T</code> stored in
the <code>Option&lt;T&gt;</code>.</p>
<a class="header" href="print.html#standard-library-traits-that-cant-be-derived" id="standard-library-traits-that-cant-be-derived"><h2>Standard Library Traits that Can’t Be Derived</h2></a>
<p>The rest of the traits defined in the standard library can’t be implemented on
your types using <code>derive</code>. These traits don’t have a sensible default behavior
they could have, so you are required to implement them in the way that makes
sense for what you are trying to accomplish with your code.</p>
<p>An example of a trait that can’t be derived is <code>Display</code>, which handles
formatting of a type for end users of your programs. You should put thought
into the appropriate way to display a type to an end user: what parts of the
type should an end user be allowed to see? What parts would they find relevant?
What format of the data would be most relevant to them? The Rust compiler
doesn’t have this insight into your application, so you must provide it.</p>
<a class="header" href="print.html#making-custom-traits-derivable" id="making-custom-traits-derivable"><h2>Making Custom Traits Derivable</h2></a>
<p>The above list is not comprehensive, however: libraries can implement <code>derive</code>
for their own types! In this way, the list of traits you can use <code>derive</code> with
is truly open-ended. Implementing <code>derive</code> involves using a procedural macro,
which is covered in the next appendix, “Macros.”</p>
<a class="header" href="print.html#d---macros" id="d---macros"><h1>D - Macros</h1></a>
<p>We’ve used macros, such as <code>println!</code>, throughout this book. This appendix will
explain:</p>
<ul>
<li>What macros are and how they differ from functions</li>
<li>How to define a declarative macro to do metaprogramming</li>
<li>How to define a procedural macro to create custom <code>derive</code> traits</li>
</ul>
<p>Macros are covered in an appendix because they’re still evolving. They have
changed and will change more than the rest of the language and standard library
since Rust 1.0, so this section will likely get out of date more than the rest
of this book. The code shown here will still continue to work due to Rust’s
stability guarantees, but there may be additional capabilities or easier ways
to write macros that aren’t available at the time of this publication.</p>
<a class="header" href="print.html#macros-are-more-flexible-and-complex-than-functions" id="macros-are-more-flexible-and-complex-than-functions"><h2>Macros are More Flexible and Complex than Functions</h2></a>
<p>Fundamentally, macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em>. In the previous appendix, we discussed the
<code>derive</code> attribute, which generates an implementation of various traits for
you. We’ve also used the <code>println!</code> and <code>vec!</code> macros. All of these macros
<em>expand</em> to produce more code than what you’ve written in your source code.</p>
<p>Metaprogramming is useful to reduce the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t have, as we discussed in Chapter 1.
A function signature has to declare the number and type of parameters the
function has. Macros can take a variable number of parameters: we can call
<code>println!(&quot;hello&quot;)</code> with one argument, or <code>println!(&quot;hello {}&quot;, name)</code> with two
arguments. Also, macros are expanded before the compiler interprets the meaning
of the code, so a macro can, for example, implement a trait on a given type,
whereas a function can’t because a function gets called at runtime and a trait
needs to be implemented at compile time.</p>
<p>The downside to implementing a macro rather than a function is that macro
definitions are more complex than function definitions. You’re writing Rust
code that writes Rust code, and macro definitions are generally more difficult
to read, understand, and maintain than function definitions.</p>
<p>Another difference between macros and functions is that macro definitions
aren’t namespaced within modules like function definitions are. In order to
prevent unexpected name clashes when using a crate, when bringing an external
crate into the scope of your project, you have to explicitly bring the macros
into the scope of your project as well with the <code>#[macro_use]</code> annotation. This
example would bring all the macros defined in the <code>serde</code> crate into the scope
of the current crate:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate serde;
</code></pre>
<p>If <code>extern crate</code> also brought macros into scope by default, you wouldn’t be
allowed to use two crates that happened to define macros with the same name. In
practice this conflict doesn’t come up much, but the more crates you use, the
more likely it is.</p>
<p>One last important difference between macros and functions: macros must be
defined or brought into scope before they’re called in a file. Unlike
functions, where we can define a function at the bottom of a file yet call it
at the top, we always have to define macros before we’re able to call them.</p>
<a class="header" href="print.html#declarative-macros-with-macro_rules-for-general-metaprogramming" id="declarative-macros-with-macro_rules-for-general-metaprogramming"><h2>Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</h2></a>
<p>The first form of macros in Rust, and the one that’s most widely used, is
called <em>declarative macros</em>. These are also sometimes referred to as <em>macros by
example</em>, <em><code>macro_rules!</code> macros</em>, or just plain <em>macros</em>. At their core,
declarative macros allow you to write something similar to a Rust <code>match</code>
expression. As discussed in Chapter 6, <code>match</code> expressions are control
structures that take an expression, compare the resulting value of the
expression to patterns, and then choose the code specified with the matching
pattern when the program runs. Macros also have a value that is compared to
patterns that have code associated with them, but the value is the literal Rust
code passed to the macro, the patterns match the structure of that source code,
and the code associated with each pattern is the code that is generated to
replace the code passed to the macro. This all happens during compilation.</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let’s explore how to
use <code>macro_rules!</code> by taking a look at how the <code>vec!</code> macro is defined. Chapter
8 covered how we can use the <code>vec!</code> macro to create a new vector that holds
particular values. For example, this macro creates a new vector with three
integers inside:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;u32&gt; = vec![1, 2, 3];
#}</code></pre></pre>
<p>We can also use <code>vec!</code> to make a vector of two integers or a vector of five
string slices. Because we don’t know the number or type of values, we can’t
define a function that is able to create a new vector with the given elements
like <code>vec!</code> can.</p>
<p>Let’s take a look at a slightly simplified definition of the <code>vec!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
#}</code></pre></pre>
<blockquote>
<p>Note: the actual definition of the <code>vec!</code> macro in the standard library also
has code to pre-allocate the correct amount of memory up-front. That code
is an optimization that we’ve chosen not to include here for simplicity.</p>
</blockquote>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made
available when other crates import the crate in which we’re defining this
macro. Without this annotation, even if someone depending on this crate uses
the <code>#[macro_use]</code> annotation, this macro would not be brought into scope.</p>
<p>Macro definitions start with <code>macro_rules!</code> and the name of the macro we’re
defining without the exclamation mark, which in this case is <code>vec</code>. This is
followed by curly brackets denoting the body of the macro definition.</p>
<p>Inside the body is a structure similar to the structure of a <code>match</code>
expression. This macro definition has one arm with the pattern <code>( $( $x:expr ),* )</code>, followed by <code>=&gt;</code> and the block of code associated with this pattern. If
this pattern matches, then the block of code will be emitted. Given that this
is the only pattern in this macro, there’s only one valid way to match; any
other will be an error. More complex macros will have more than one arm.</p>
<p>The pattern syntax valid in macro definitions is different than the pattern
syntax covered in Chapter 18 because the patterns are for matching against Rust
code structure rather than values. Let’s walk through what the pieces of the
pattern used here mean; for the full macro pattern syntax, see <a href="../../reference/macros.html">the reference</a>.</p>
<p>The <code>$x:expr</code> part of the pattern matches any Rust expression and gives the
expression the name <code>$x</code>. The <code>*</code> specifies that the pattern matches zero or
more of whatever precedes the <code>*</code>. In this case, <code>*</code> is preceded by <code>$(),</code> so
this pattern matches zero or more of whatever is inside the parentheses,
delimited by a comma. When we call this macro with <code>vec![1, 2, 3];</code>, the
pattern matches the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>In the body of the code associated with this arm, the <code>$()*</code> part is generated
for each part that matches <code>$()</code> in the pattern, zero or more times depending
on how many times the pattern matches. The <code>$x</code> in the code associated with the
arm is replaced with each expression matched. When we call this macro with
<code>vec![1, 2, 3];</code>, the code generated that replaces this macro call will be:</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.</p>
<p>Given that most Rust programmers will <em>use</em> macros more than <em>write</em> macros,
that’s all we’ll discuss about <code>macro_rules!</code> in this book. To learn more about
how to write macros, consult the online documentation or other resources such
as <a href="https://danielkeep.github.io/tlborm/book/index.html">The Little Book of Rust Macros</a>.</p>
<a class="header" href="print.html#procedural-macros-for-custom-derive" id="procedural-macros-for-custom-derive"><h2>Procedural Macros for Custom <code>derive</code></h2></a>
<p>The second form of macros is called <em>procedural macros</em> because they’re more
like functions (which are a type of procedure). Procedural macros accept some
Rust code as an input, operate on that code, and produce some Rust code as an
output, rather than matching against patterns and replacing the code with other
code as declarative macros do. Today, the only thing you can define procedural
macros for is to allow your traits to be implemented on a type by specifying
the trait name in a <code>derive</code> annotation.</p>
<p>Let’s create a crate named <code>hello-world</code> that defines a trait named
<code>HelloWorld</code> with one associated function named <code>hello_world</code>. Rather than
making users of our crate implement the <code>HelloWorld</code> trait for each of their
types, we’d like users to be able to annotate their type with
<code>#[derive(HelloWorld)]</code> to get a default implementation of the <code>hello_world</code>
function associated with their type. The default implementation will print
<code>Hello world, my name is TypeName!</code> where <code>TypeName</code> is the name of the type on
which this trait has been defined.</p>
<p>In other words, we’re going to write a crate that enables another programmer to
write code that looks like Listing A4-1 using our crate:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello_world;
#[macro_use]
extern crate hello_world_derive;

use hello_world::HelloWorld;

#[derive(HelloWorld)]
struct Pancakes;

fn main() {
    Pancakes::hello_world();
}
</code></pre>
<p><span class="caption">Listing A4-1: The code a user of our crate will be able
to write when we’ve written the procedural macro</span></p>
<p>This code will print <code>Hello world, my name is Pancakes!</code> when we’re done. Let’s
get started!</p>
<p>Let’s make a new library crate:</p>
<pre><code class="language-text">$ cargo new hello-world
</code></pre>
<p>First, we’ll define the <code>HelloWorld</code> trait and associated function:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait HelloWorld {
    fn hello_world();
}
#}</code></pre></pre>
<p>At this point, a user of our crate could implement the trait themselves to
achieve the functionality we wanted to enable, like so:</p>
<pre><code class="language-rust ignore">extern crate hello_world;

use hello_world::HelloWorld;

struct Pancakes;

impl HelloWorld for Pancakes {
    fn hello_world() {
        println!(&quot;Hello world, my name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_world();
}
</code></pre>
<p>However, they would need to write out the implementation block for each type
they wanted to be able to use with <code>hello_world</code>; we’d like to make using our
trait more convenient for other programmers by saving them this work.</p>
<p>Additionally, we can’t provide a default implementation for the <code>hello_world</code>
function that has the behavior we want of printing out the name of the type the
trait is implemented on: Rust doesn’t have reflection capabilities, so we can’t
look up the type’s name at runtime. We need a macro to generate code at compile
time.</p>
<a class="header" href="print.html#defining-procedural-macros-requires-a-separate-crate" id="defining-procedural-macros-requires-a-separate-crate"><h3>Defining Procedural Macros Requires a Separate Crate</h3></a>
<p>The next step is to define the procedural macro. At the moment, procedural
macros need to be in their own crate. Eventually, this restriction may be
lifted, but for now, it’s required. As such, there’s a convention: for a crate
named <code>foo</code>, a custom derive procedural macro crate is called <code>foo-derive</code>.
Let’s start a new crate called <code>hello-world-derive</code> inside our <code>hello-world</code>
project:</p>
<pre><code class="language-text">$ cargo new hello-world-derive
</code></pre>
<p>We’ve chosen to create the procedural macro crate within the directory of our
<code>hello-world</code> crate because the two crates are tightly related: if we change
the trait definition in <code>hello-world</code>, we’ll have to change the implementation
of the procedural macro in <code>hello-world-derive</code> as well. The two crates will
need to be published separately, and programmers using these crates will need
to add both as dependencies and bring them both into scope. It’s possible to
have the <code>hello-world</code> crate use <code>hello-world-derive</code> as a dependency and
re-export the procedural macro code, but structuring the project this way makes
it possible for programmers to easily decide they only want to use
<code>hello-world</code> if they don’t want the <code>derive</code> functionality.</p>
<p>We need to declare that the <code>hello-world-derive</code> crate is a procedural macro
crate. We also need to add dependencies on the <code>syn</code> and <code>quote</code> crates to get
useful functionality for operating on Rust code. To do these two things, add
the following to the <em>Cargo.toml</em> for <code>hello-world-derive</code>:</p>
<p><span class="filename">Filename: hello-world-derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</code></pre>
<p>To start defining the procedural macro, place the code from Listing A4-2 in
<em>src/lib.rs</em> for the <code>hello-world-derive</code> crate. Note that this won’t compile
until we add a definition for the <code>impl_hello_world</code> function. We’ve split the
code into functions in this way because the code in Listing A4-2 will be the
same for almost every procedural macro crate; it’s code that makes writing a
procedural macro more convenient. What you choose to do in the place where the
<code>impl_hello_world</code> function is called will be different and depend on the
purpose of your procedural macro.</p>
<p><span class="filename">Filename: hello-world-derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloWorld)]
pub fn hello_world_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // Build the impl
    let gen = impl_hello_world(&amp;ast);

    // Return the generated impl
    gen.parse().unwrap()
}
</code></pre>
<p><span class="caption">Listing A4-2: Code that most procedural macro crates will
need to have for processing Rust code</span></p>
<p>We have introduced three new crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, and <a href="https://crates.io/crates/quote"><code>quote</code></a>. The
<code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the
dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate allows us to convert Rust
code into a string containing that Rust code. The <code>syn</code> crate parses Rust code
from a string into a data structure that we can perform operations on. The
<code>quote</code> crate takes <code>syn</code> data structures and turns them back into Rust code.
These crates make it much simpler to parse any sort of Rust code we might want
to handle: writing a full parser for Rust code is no simple task.</p>
<p>The <code>hello_world_derive</code> function is the code that will get called when a user
of our library specifies the <code>#[derive(HelloWorld)]</code> annotation on a type
because we’ve annotated the <code>hello_world_derive</code> function here with
<code>proc_macro_derive</code> and specified the same name, <code>HelloWorld</code>. This name
matches our trait named <code>HelloWorld</code>; that’s the convention most procedural
macros follow.</p>
<p>The first thing this function does is convert the <code>input</code> from a <code>TokenStream</code>
to a <code>String</code> by calling <code>to_string</code>. This <code>String</code> is a string representation
of the Rust code for which we are deriving <code>HelloWorld</code>. In the example in
Listing A4-1, <code>s</code> will have the <code>String</code> value <code>struct Pancakes;</code> because
that’s the Rust code we added the <code>#[derive(HelloWorld)]</code> annotation to.</p>
<p>At the moment, the only thing you can do with a <code>TokenStream</code> is convert it to
a string. A richer API will exist in the future.</p>
<p>What we really need is to be able to parse the Rust code <code>String</code> into a data
structure that we can then interpret and perform operations on. This is where
<code>syn</code> comes to play. The <code>parse_derive_input</code> function in <code>syn</code> takes a
<code>String</code> and returns a <code>DeriveInput</code> struct representing the parsed Rust code.
Here’s the relevant parts of the <code>DeriveInput</code> struct we get from parsing the
string <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident(
        &quot;Pancakes&quot;
    ),
    body: Struct(
        Unit
    )
}
</code></pre>
<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code>. There are more
fields on this struct for describing all sorts of Rust code; check the <a href="https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html"><code>syn</code>
API docs for <code>DeriveInput</code></a> for more information.</p>
<p>We haven’t defined the <code>impl_hello_world</code> function; that’s where we’ll build
the new Rust code we want to include. Before we get to that, the last part of
this <code>hello_world_derive</code> function is using the <code>quote</code> crate’s <code>parse</code>
function to turn the output of the <code>impl_hello_world</code> function back into a
<code>TokenStream</code>. The returned <code>TokenStream</code> is added to the code that users of
our crate write so that when they compile their crate, they get extra
functionality we provide.</p>
<p>You may have noticed that we’re calling <code>unwrap</code> to panic if the calls to the
<code>parse_derive_input</code> or <code>parse</code> functions fail because they’re unable to parse
the <code>TokenStream</code> or generate a <code>TokenStream</code>. Panicking on errors is necessary
in procedural macro code because <code>proc_macro_derive</code> functions must return
<code>TokenStream</code> rather than <code>Result</code> in order to conform to the procedural macro
API. We’ve chosen to keep this example simple by using <code>unwrap</code>; in production
code you should provide more specific error messages about what went wrong by
using <code>expect</code> or <code>panic!</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>
into a <code>String</code> and into a <code>DeriveInput</code> instance, let’s write the code that
will generate the code implementing the <code>HelloWorld</code> trait on the annotated
type:</p>
<p><span class="filename">Filename: hello-world-derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_world(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloWorld for #name {
            fn hello_world() {
                println!(&quot;Hello, World! My name is {}&quot;, stringify!(#name));
            }
        }
    }
}
</code></pre>
<p>We are able to get an <code>Ident</code> struct instance containing the name (identifier)
of the annotated type using <code>ast.ident</code>. With the code from Listing A4-1,
<code>name</code> will be <code>Ident(&quot;Pancakes&quot;)</code>.</p>
<p>The <code>quote!</code> macro from the <code>quote</code> crate lets us write up the Rust code that
we wish to return and convert it into <code>quote::Tokens</code>. The <code>quote!</code> macro lets
us use some really cool templating mechanics; we can write <code>#name</code> and <code>quote!</code>
will replace it with the value in the variable named <code>name</code>. You can even do
some repetition similar to the way regular macros work. Check out <a href="https://docs.rs/quote">the <code>quote</code>
crate’s docs</a> for a thorough introduction.</p>
<p>What we want to do for our procedural macro is generate an implementation of
our <code>HelloWorld</code> trait for the type the user of our crate has annotated, which
we can get by using <code>#name</code>. The trait implementation has one function,
<code>hello_world</code>, and the function body contains the functionality we want to
provide: printing <code>Hello, World! My name is</code> and then the name of the type the
user of our crate has annotated. The <code>stringify!</code> macro used here is built into
Rust. It takes a Rust expression, such as <code>1 + 2</code>, and at compile time turns
the expression into a string literal, such as <code>&quot;1 + 2&quot;</code>. This is different than
<code>format!</code> or <code>println!</code>, which evaluate the expression and then turn the result
into a <code>String</code>. There’s a possibility that <code>#name</code> would be an expression that
we would want to print out literally, and <code>stringify!</code> also saves an allocation
by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello-world</code>
and <code>hello-world-derive</code>. Let’s hook these crates up to the code in Listing
A4-1 to see it in action! Create a new binary project in your <code>projects</code>
directory with <code>cargo new --bin pancakes</code>. We need to add both <code>hello-world</code>
and <code>hello-world-derive</code> as dependencies in the <code>pancakes</code> crate’s
<em>Cargo.toml</em>. If you’ve chosen to publish your versions of <code>hello-world</code> and
<code>hello-world-derive</code> to <em>https://crates.io</em> they would be regular dependencies;
if not, you can specify them as <code>path</code> dependencies as follows:</p>
<pre><code class="language-toml">[dependencies]
hello_world = { path = &quot;../hello-world&quot; }
hello_world_derive = { path = &quot;../hello-world/hello-world-derive&quot; }
</code></pre>
<p>Put the code from Listing A4-1 into <em>src/main.rs</em>, and executing <code>cargo run</code>
should print <code>Hello, World! My name is Pancakes</code>! The implementation of the
<code>HelloWorld</code> trait from the procedural macro was included without the
<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloWorld)]</code> took care
of adding the trait implementation.</p>
<a class="header" href="print.html#the-future-of-macros" id="the-future-of-macros"><h2>The Future of Macros</h2></a>
<p>In the future, we’ll be expanding both declarative and procedural macros. A
better declarative macro system will be used with the <code>macro</code> keyword, and
we’ll add more types of procedural macros, for more powerful tasks than only
<code>derive</code>. These systems are still under development at the time of publication;
please consult the online Rust documentation for the latest information.</p>
<a class="header" href="print.html#appendix-e-translations-of-the-book" id="appendix-e-translations-of-the-book"><h2>Appendix E: Translations of the Book</h2></a>
<p>For resources in languages other than English. Most are still in progress; see
<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/hngnaig/rust-lang-book/tree/vi-VN">Tiếng việt</a></li>
<li><a href="http://www.broadview.com.cn/article/144">简体中文</a>, <a href="https://github.com/KaiserY/trpl-zh-cn">alternate</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">українська мова</a></li>
<li><a href="https://github.com/thecodix/book">Español</a></li>
<li><a href="https://github.com/CodelessFuture/trpl2-it">Italiano</a></li>
<li><a href="https://github.com/iDeBugger/rust-book-ru">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/hazama-yuinyan/book">日本語</a></li>
<li><a href="https://github.com/quadrifoglio/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
</ul>
<a class="header" href="print.html#appendix-f---newest-features" id="appendix-f---newest-features"><h1>Appendix F - Newest Features</h1></a>
<p>This appendix documents features that have been added to stable Rust since the
main part of the book was completed.</p>
<a class="header" href="print.html#field-init-shorthand" id="field-init-shorthand"><h2>Field init shorthand</h2></a>
<p>We can initialize a data structure (struct, enum, union) with named
fields, by writing <code>fieldname</code> as a shorthand for <code>fieldname: fieldname</code>.
This allows a compact syntax for initialization, with less duplication:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let name = String::from(&quot;Peter&quot;);
    let age = 27;

    // Using full syntax:
    let peter = Person { name: name, age: age };

    let name = String::from(&quot;Portia&quot;);
    let age = 27;

    // Using field init shorthand:
    let portia = Person { name, age };

    println!(&quot;{:?}&quot;, portia);
}
</code></pre></pre>
<a class="header" href="print.html#returning-from-loops" id="returning-from-loops"><h2>Returning from loops</h2></a>
<p>One of the uses of a <code>loop</code> is to retry an operation you know can fail, such as
checking if a thread completed its job. However, you might need to pass the
result of that operation to the rest of your code. If you add it to the <code>break</code>
expression you use to stop the loop, it will be returned by the broken loop:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<a class="header" href="print.html#nested-groups-in-use-declarations" id="nested-groups-in-use-declarations"><h2>Nested groups in <code>use</code> declarations</h2></a>
<p>If you have a complex module tree with many different submodules and you need
to import a few items from each one, it might be useful to group all the
imports in the same declaration to keep your code clean and avoid repeating the
base modules' name.</p>
<p>The <code>use</code> declaration supports nesting to help you in those cases, both with
simple imports and glob ones. For example this snippets imports <code>bar</code>, <code>Foo</code>,
all the items in <code>baz</code> and <code>Bar</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_imports, dead_code)]
#
# mod foo {
#     pub mod bar {
#         pub type Foo = ();
#     }
#     pub mod baz {
#         pub mod quux {
#             pub type Bar = ();
#         }
#     }
# }
#
use foo::{
    bar::{self, Foo},
    baz::{*, quux::Bar},
};
#
# fn main() {}
</code></pre></pre>
<a class="header" href="print.html#appendix-g---how-rust-is-made-and-nightly-rust" id="appendix-g---how-rust-is-made-and-nightly-rust"><h1>Appendix G - How Rust is Made and “Nightly Rust”</h1></a>
<p>This appendix is about how Rust is made and how that affects you as a Rust
developer. We mentioned that the output in this book was generated by stable
Rust 1.21.0, but any examples that compile should continue to compile in any
stable version of Rust greater than that. This section is to explain how we
ensure this is true!</p>
<a class="header" href="print.html#stability-without-stagnation" id="stability-without-stagnation"><h3>Stability Without Stagnation</h3></a>
<p>As a language, Rust cares a <em>lot</em> about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.</p>
<p>Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.</p>
<a class="header" href="print.html#choo-choo-release-channels-and-riding-the-trains" id="choo-choo-release-channels-and-riding-the-trains"><h3>Choo, Choo! Release Channels and Riding the Trains</h3></a>
<p>Rust development operates on a <em>train schedule</em>. That is, all development is
done on the <code>master</code> branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three <em>release channels</em> for Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.</p>
<p>Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the <code>master</code>
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Every six weeks, it’s time to prepare a new release! The <code>beta</code> branch of the
Rust repository branches off from the <code>master</code> branch used by nightly. Now,
there are two releases:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to <code>master</code>, so that nightly is fixed, and then the fix is backported to the
<code>beta</code> branch, and a new release of beta is produced:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Six weeks after the first beta was created, it’s time for a stable release! The
<code>stable</code> branch is produced from the <code>beta</code> branch:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the <em>next</em> version of Rust, 1.6.
So after <code>stable</code> branches off of <code>beta</code>, the next version of <code>beta</code> branches
off of <code>nightly</code> again:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.</p>
<p>Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.</p>
<p>Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
<code>rustc</code> is still a piece of software, and bugs do exist.</p>
<a class="header" href="print.html#unstable-features" id="unstable-features"><h3>Unstable Features</h3></a>
<p>There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
<code>master</code>, and therefore, in nightly, but behind a <em>feature flag</em>. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.</p>
<p>If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.</p>
<p>This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.</p>
<a class="header" href="print.html#rustup-and-the-role-of-rust-nightly" id="rustup-and-the-role-of-rust-nightly"><h3>Rustup and the Role of Rust Nightly</h3></a>
<p>Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<p>You can see all of the <em>toolchains</em> (releases of Rust and associated
components) you have installed with <code>rustup</code> as well. Here’s an example on one
of your authors’ computers:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use <code>rustup override</code> in that project’s directory to set the
nightly toolchain as the one <code>rustup</code> should use when you’re in that directory:</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override add nightly
</code></pre>
<p>Now, every time you call <code>rustc</code> or <code>cargo</code> inside of
<em>~/projects/needs-nightly</em>, <code>rustup</code> will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!</p>
<a class="header" href="print.html#the-rfc-process-and-teams" id="the-rfc-process-and-teams"><h3>The RFC Process and Teams</h3></a>
<p>So how do you learn about these new features? Rust’s development model follows
a <em>Request For Comments (RFC) process</em>. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.</p>
<p>Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams <a href="https://www.rust-lang.org/en-US/team.html">on Rust’s
website</a>, which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.</p>
<p>If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the <code>master</code> branch behind a feature gate, as we discussed
in the “Unstable Features” section.</p>
<p>After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
